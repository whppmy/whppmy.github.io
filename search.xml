<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[什么是微服务架构]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[微服务架构微服务架构是一种架构模式或者架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行在其独立的进程中，服务间互相协调、互相配合，为用户提供最终价值。服务间采用轻量级通信机制（通常基于HTTP的RESTful API）。每个服务都围绕着具体业务进行构建，并且能独立部署到生产环境。应尽量避免统一的、集中式的服务管理机制，对具体的服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有非常轻量的集中式管理来协调这些服务，可以使用不同的语言，也可以使用不同的数据存储。 由All in one，拆分成不同的模块（进程），一个服务做一件事，进行解耦。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运输层基本概念]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E8%BF%90%E8%BE%93%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[UDP无连接，TCP三次握手、四次挥手TCP规定，即使接收窗口为0，也要接收零窗口探测报文、确认报文、带有紧急数据的报文 慢开始会以2倍数增长拥塞窗口，拥塞避免是线性增加1不等超时，就进行重传，需要接收连续三个确认 不推荐发送窗口前沿收缩，有可能这些数据已经发送了 建立连接前，服务器会先创建传输控制块（TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针、当前的发送和接收序号、。。。），然后进行LISTEN客户端要发起连接时，也先创建传输控制块第三次握手是为了防止多连接，而消耗掉服务器资源SYN=1的报文段不能携带数据，但要消耗一个序号、普通确认报文如果不带数据，则不消耗序号x客户端选择作为初始序号，y为服务端选择的初始序号 FIN=1的报文段不能携带数据，但要消耗一个序号。v等于TCP客户进程之前收到的最后一个字节序号+1。u等于TCP客户进程之前已传送过数据的最后一个字节序号+1。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层基本概念]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E5%BA%94%E7%94%A8%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[请求中会带有《事务ID》，用带确保是自己发出而得到的回应路由器不会转发广播，需要在上面配置DHCP服务器IP，才能进行单播传送 DNS服务器，用于查找域名-&gt;IP 使用UDP 端口53 控制连接会保持打开，数据连接传输完成就关闭 基于TCPSTMP只能传输ASCII，因而引进了MIME，将图片、文件转为ASCII或者将ASCII进行逆转换。MIME同样应用于HTTP]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层基本概念]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E7%BD%91%E7%BB%9C%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[32比特的IPV4地址不便阅读、记录、输入，因此采用点分十进制表示方法，8个一组，用.分开 增加子网时候，需要申请新的网络号，等待时间和钱，增加路由路中路由表记录数量，浪费原网络中剩余的IP。此时需要引入子网掩码，通过与运算，取出IPV4地址所在子网的网络地址 定长即使用同一个子网掩码来划分子网，只能划分出2^n个子网，从主机号借用的。容易造成IP地址浪费。使用不同的子网掩码来划分子网，更灵活，按需分配，子网数量可以不同，减少浪费。 路由器收到出错的数据报，丢弃后，向源主机发送ICMP数据报。 产生环路，会使用TTL进行计算，为零时抛弃，或者加入黑洞路由，使用默认路由后，当不知道转发给哪里就会转发到默认路由 在两个自治系统中，内部使用的是IGP或IRP内部网关（路由）协议，之间使用的是EGP或ERP外部网关（路由）协议，仅表示协议，不表示实际使用什么算法路由器会定期发送自己的路由信息 减少信息洪泛，一个区域一般最多200个路由 BGP-4报文封装在TCP报文段中 R1与R2之间类似点对点，也称IP隧道技术]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集线器与交换机基本概念]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[总线型使用大量机械接头和无源电缆并不可靠 可以使用集线器HUB在物理层扩展以太网，将多个碰撞域（冲突域）合并成一个更大的冲突域，在一系中的一台主机要发送给二系中一台主机，该帧信号会传输到整个网络的各个主机。 交换机会把单播帧转发到目的主机（忽略ARP过程，假设交换机的帧交换表已“学习好了”） 集线器一般使用CSMA/CD争取总线资源，只能半双工，而交换机可以进行全双工，同时进行收发工作。 交换机工作在数据链路层（也包括物理层—），集线器工作在物理层，前者性能快 以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。是即插即用设备，刚上电内部帧交换表是空的，随通信进行处学习算法，自动逐渐建立起帧交换表。 盲目泛洪类似广播，登录会在发送方时登记，每条记录都有时效，到期自动删除，MAC与交换机接口关系不是永久性的，更换主机、更换网卡。ARP高速缓存表中IP与MAC对应关系同样会到期自动删除。 使用生成树协议，保证没有环路网络 当交换机以太网足够大时，进行广播会有很大的开销路由器工作在网络层，一般不转发广播，可以将交换机以太网分割成小的广播域 交换机端口类型有以下三种：Access Trunk Hybrid交换机各端口的缺少VLAN ID 思科上称为Native VLAN 即本征VLAN 华为上称Port VLAN ID即端口VLAN ID,PVID]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC、IP、ARP基本概念]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2Fmac%E3%80%81ip%E3%80%81arp%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[单播：表示只传给指定MAC地址，多播：表示该网络接口所在的多播地址，一个接口可以在多个多播地址，与帧的目的MAC地址符合，即接收该帧，广播：地址为FF:FF:FF:FF:FF:FF，所有人都接收 ARP只能在同一个链路或者同一个网络上使用]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据链路层基本概念]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[封装成帧：在链路层会对IP数据报文添加帧头和帧尾 帧头和帧尾包含重要的控制信息 帧头和帧尾作为帧定界，可以通过物理层交付的比特流中提取一个个的帧（PPP帧），并不是所有都包含帧定界标志（以太网V2 MAC帧），而物理层会在传输前增加8字节前导码（前7位是同步码，作为时钟同步，之后一字节作为定界符）再转为电信号发送，以太网规定帧间间隔（96比特时间） 透明传输，指数据链路层对上层交付的传输数据没有任何限制，若数据中存在帧尾字段，链路层会在该位置做字符标记（在前增加esc ascill=27）做比特处理（每5位1后插入1个0）等，以防止在解析时提前结束帧（字符填充或者零比特填充） 差错检测：比特在实际传输过程中可能会产生差错，称为比特差错或误码。一段时间内，传输错误的比特占总传输比特的比率为误码率BER。检错后一般进行重传来纠正传输中的差错或者仅仅是德育检测到差错的帧，取决于是可靠传输还是不可靠传输 在以太网V2 MAC帧中，帧尾包含4字节的帧检验序列FCS字段，检测是否有误码 在PPP帧中，帧尾包含2字节FCS 奇偶校验，在待发送数据后面添加1位奇偶校验，使整个数据（包括校验位）中1的个数为奇数或者偶数，漏检率高 循环冗余校验，约定一个生成多项式，基于数据和多项式计算出冗余码，添加到数据后面一起传输，漏检率非常低，易于硬件实现，广泛用于数据链路层 检测码只能检测出是否出错，不能定位，无法纠正错误，可以使用冗余信息更多的纠错码进行前向纠错，开销较大 可靠传输：根据数据链路层向上层提供的服务类型，其可靠性不一定由数据链路层实现，其它各层均可选择实现可靠传输 不可靠传输服务：仅仅丢弃有误码的帧 可靠传输服务：想办法实现发送端发送什么，接收端就收到什么 有线误码率低，不要求数据链路层向上提供可靠传输。即使出现误码，可靠传输的问题由其上层处理。 无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。 传输差错类型，比特差错、分组丢失、分组失序、分组重复，分组表示的是帧 可靠传输实现机制的原理，不仅限于数据链路层 停止-等待协议SW（自动请求重传ARQ） 回退N帧协议GBN（连续ARQ，滑动窗口协议） 制定比特给分组编号，发送窗口尺寸，表示一次发多个组，尺寸不能大于分组号-1，接收窗口尺寸为1，（若发送尺寸==分组数，则会接口窗口检测不到错误，依然把0号放置于0号，认为正确，实际是忽略了一个组），接收窗口只能等于1，只能按序接收，数据分组内出现误码后面的分组都会丢弃。 由停止-等待发送1个改为多个，串行改并行 累积确认，在接收到前N组时，可以直接发送ACKn表示已经接收到N组数据，减少资源占用 当多个到达接收方时，出现误码，不仅会丢弃该帧，还会把序号不匹配的丢弃，重新发送多个已经接收到最大序号的ACKn 选择重传协议SR 对回退N帧进行扩展，发送滑动窗口&gt;=接收窗口&gt;=1，可进行多组分别确认，但是取消累积确认 点对点协议PPP：目前使用最广泛的点对点数据链路层协议，向上不提供可靠传输 实现透明传输，面向字节的异步链路，字节填充法，对特殊字符前插入转义字符，转义字符再插入转义字符。面向比特的同步链路，比特填充法，对于连续5位1的后面插入一个0。 信道复用： 频分复用FDM：根据频带划分出多个了频带（信道），频带间需要有隔离频带 时分复用TDM：将传输带宽资源按时隙轮流分配给不同用户，用户只能在对应的时隙进行通信，周期性出现，一周期就是一个TDM帧 波分复用WDM：即光的频分复用，将每路（1310nm波长，2.5Gb/s）变换到1550~1561.2nm，共8路，相隔1.6nm，在同一根光纤传输，光传输会损失，中间需要掺铒光纤放大器EDFA。 码分复用CDM： 动态接入控制：CSMA-CD适用于有线CSMA/CA适用于无线等待DIFS表示有高优先级让其先传。等待SIFS表示最短帧间间隔，用来分隔属于一次对话的各帧。请求发送RTS:帧包括源地址、目的地址及所需要时间 允许发送CTS:也包括此次通信时间解决A C互为隐蔽站的问题，C通过CTS知道B被占用的时间]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[三种电路交换优缺点对比：电路交换（比特流直达）优点：通信时延小、有序、没有冲突、适用范围广、实时性强、控制简单缺点：建立连接时间长、线路独占，使用效率低、灵活性差、难以规格化报文交换（整组报文转发）优点：无需建立连接、动态分配线路、线路可靠性、线路利用率高、多目标服务缺点：转发时延、较大存储缓存空间、传输额外的信息量分组交换优点：无需建立连接、线路利用率高、简化存储管理、加速传输、减少出错和重发数据量缺点：转发时延、传输额外的信息量、采用数据报服务时存在失序、丢失或者重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程。 时延=发送时延（分组长度/发送数率）+传播时延（信道长度/电磁波传播速率）+处理时延（硬件相关） 时延带宽积=传播时延*带宽 利用率：信道利用率 用来表示信道百分之几的时间是有数据通过网络利用率 全网络的信道利用率的加权平均当前时延=空闲时延/(1-利用率) 当得用率达到50%以上时，则时延会增大，可以考虑扩容，增大线路的带宽。尽量动态控制通信量，保持在合理范围内。 丢包：接口、结点、链路、路径、网络丢包。分组丢失：分组在传输过程中出现误码，被结点丢弃；到达一台队列已满的分组交换机时被丢弃。 OSI体系结构，七层协议物理、数据链路、网络、运输、会话、表示、应用层TCP/IP体系结构、四层协议网络接口 网络接口网际 IP将网络接口互联、向TCP、UDP提供网络互联服务(IP over everythins、Everything over IP)运输 TCP(在IP服务的基础上，向应用层提供可靠性传输服务) UDP(…不可靠传输服务)应用层 HTTP SMTP DNS RTP 原理体系结构（适用教学）应用 解决通过应用进程的交互来实现特定网络应用的问题 应用进程间交互来完成特定的网络应用运输 解决进程之间基于网络的通信问题 解决进程间、传输错误处理网络 解决分组在多个网络上传输（路由）的问题 路由功能，如使用IP数据链路 解决分组在一个网络（或链路）上传输的问题 如使用MAC标记主机物理层 解决使用何种信号来传输比特的问题 硬件如网络网口、传输方式 由应用层向物理层转变 http（报文） -&gt; http+TCP（TCP报文段） -&gt; http+TCP+IP（IP数据报） -&gt; ETH+http+TCP+IP+ETH（帧） -&gt; ….+前导码（比特流） 协议的三要素语法 定义所交换信息的格式语义 定义收发双方所要完成的操作同步 定义收发双方的时序关系 协议数据单元PDU 对等层次之间传送的数据包称为该层的协议数据单元服务数据单元SDU 同一系统内，层与层之间交换的数据包称为服务数据单元多个SDU可以合成一个PDU，一个SDU可以划分为几个PDU]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物理层基本概念]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么 物理层协议主要任务：机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置电气特性：指明在接口电缆的各条线上出现的电压范围功能特性：指明某条线上出现的某一电平的电压表示何种意义过程特性：指明对于不同功能的各种可能事的出现顺序 传输媒体（不同媒体对应不同的物理层协议）：1、导引型：双绞线（网线）、同轴电缆、光纤、电力线2、非导引型：微波通信（2~40GHz)、无线电波、红外线、可见光 传输方式1、串行（远距离传输，如计算机网络）。并行（CPU与内存之间，通过总线进行传输）2、同步：以稳定的比特流传输，字节间没有间隔，接收端在中间时刻进行检测0或1，此时会有时钟累计误差。需要保持时钟同步。外同步：在收发双方间添加一条单独的时钟信号线。内同步：发送端将时钟同步信号编码到发送数据中一起传输（曼彻斯特编码）。异步：以一个字节为单位传输，字节间异步，在字节前后增加头和尾作为判断。3、单工：单向通信（收音机）。半双工：双向交替通信，可以相互通信但不能同时（对讲机）。全双工：双向同时通信（电话） 常用编码：不归零编码（存在同步问题，需要额外传输时钟，不常用），归零编码（自同步，编码效率低，用零电频做隔断），曼彻斯特编码（用码元间跳变表示时钟，又表示数据），差分曼彻斯特编码 频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位中的一个。相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。 信号在信道中传输会存在失帧的可能，其中因素娄：码元传输速率，信号传输距离，噪声干扰，传输媒体质量。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式总结创建型1.简单工厂根据参数，如字符串、枚举等，反回创建的类。不属于Gof所说的。 2.工厂模式抽象一层，选择一个需要的工厂，工厂有一个获取产品的方法，再从工厂取要的东西。 3.抽象工厂对工厂抽象和产品抽象，创建一个产品族工厂，从产品族工厂中取东西。理论上每个工厂都能取到同类型的东西，但是属性不一样。 4.构建者模式抽象一个item做衍生，以此做为产品，里面有公共的方法。使用一个builder，选装Item，把东西存起来。产品可以动态增删。 5.原型模式使用当前已经存在的类，给予一个clone接口，用于克隆一份一样的、独立存在的类。 6.单例模式一个对象，只有一个实例，私有创建的方法。大家共用同一个。懒汉式，在第一次使用时才创建饿汉式，编译构建时就创建,static成员 结构型7.适配器模式由底部根据需求实现匹配，自动返回适应的类型或者执行某些动作。 8.桥接模式根据不同的上层产品，给入不同的内部数据，通过上层产品操作间接使用数据，展示的效果会不一样。 9.组合模式把东西按关系进行划分，构成一棵树级结构。 10.装饰者模式大家都会一个动作，但是又可以相互包装，A会画圆，B会画方，C的画画方法可以是让A、B一起来画，还可以加别的。 11.外观模式使用一个上层包装，把多个具有某个关系的类放到一起。 12.享元模式大家共享某部分数据，在没有的时候进行创建，下次再要这个类型时返回该值，减少创建。 13.代理模式给一个类做一层包装，做一层扩展，做为代理人进行控制。 行为型14.职责链模式根据类关系，构建一条关系链，在上层需要处理数据时，可能需要和下层进行交互，可以达到相互传递，以完成处理。 15.命令模式把需要做的事情包装成一个事件，通过一个中心控制，命令事件执行。 16.解释器模式通过特定的功能分类，拆成一个一个解析器，使用不同的解析器去处理对应的数据，达到整体划分。 17.迭代器模式常见于Stl中，用于高效遍历内容。 18.中介者模式大家根据某个关系，注册在一个中心。然后都可以通过中心给的接口，查询到别人的信息和被别人找到。 19.备忘录模式处理一个事件，在需要的时候保存一下（新建一份数据）存起来，使用者后面可以根据索引去找到这份保存的数据。 20.观察者模式大家往一个地方注册，当发生事件时，注册了的类会收到需要的信息。参考QT信号槽。 21.状态模式给一个物体塑造多个外表，根据需要设置外表，用该外表做为当前的状态，可随时切换。 22.策略模式当前有一组数据，但是可以有多个处理的方法，其方法可能可以进行组合，把方法单独做为策略。组合出需要的场景。 23.模板模式抽象一个模板，模板会有很多动作调用。实体可以选择实现某些动作，不需要的可以空实现。 24.访问者模式每个事物关注同一个东西的角度都不同。通过元素的回调或者访问者主动查看，可以做不同的动作。 以上为Gof(Gang of Four)四人组提出的 25.pimplqt源码实现方式，将成员藏在cpp，不对外暴露。 26.业务代表其中包含client、Delegate、lookup、service。使用者通过代理缓存，查找需要的服务。通过这样将业务进行分层解耦。 27.组合实体模式 组合实体太学术化了，不通俗。组合实体是个对象，是个管理者，管家，掌柜的，经理，它是直接面向客户的。组合实体下面是几个小组，也就是假如说它是个经理的话，那么它下面管理着几个小组长。小组长下面就是组员了呗，也就是真正干活的人了。所以组合实体是个层层管理的机制，并且下层的生命周期决定于上层的生命周期。就这么简单。我想它的作用只不过是简化了每一环的复杂程度而已。 https://www.it610.com/article/1177358433989488640.htm 28.过滤器模式字面意思，通过一个过滤器，把输入的数据过滤掉不合理的，然后得到结果。 29.空模式对于不些不合理的数据，给予一个空的对象，而不是空值。 30.mvcmodel，存数据，更新时告诉C,view将数据做显示，controller作为中间传递数据和中间处理的一方。Qt中是MVD D是代理，包括C的功能，还有告诉V怎么去定制和绘制。 31.数据访问对象模式将一些不好使用的接口包装进来，通过更上一层封装，使用时更便捷。 32.前端控制器模式通过一个前端，把请求进行汇总再分发给特定的处理器。 33.拦截过滤器模式通过实现多个过滤器，在发生事件时，使用注册了的过滤器对事件进行处理，通过后再去做相应的操作，否则拦截。 34.服务定位器模式根据一个中心缓存，去查找或者说定位之前使用过的东西。 35.传输对象模式把对象打包传送与接收。]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GTest接口测试]]></title>
    <url>%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%2Fgtest%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Gtest运行参数可以通过系统环境变量设置GTEST_FLAG，可以通过内部代码testing::GTEST_FLAG(output)=””设定，后设置的生效。 –gtest_list_tests 输出所有用例 –gtest_filter 过滤用例，支持通配符 ?*-:(:”是或) –gtest_repeat=[COUNT] 用例执行次数 -1为一直执行，默认出错依然执行，但是增加 –gtest_color=(yes/no/auto) 输出颜色 –gtest_print_time 打印执行时间 –gtest_output=后缀:路径\文件名 –gtest_break_on_failure 则出错后停止 –gtest_throw_on_failure 失败抛异常 –gtest_catch_exceptions 是否捕捉异常，只在Win有效 Gtest断言ASSERT_系列：如果当前点检测失败则退出当前测试EXPECT_系列：如果当前点检测失败则继续往下执行 *_TRUE(condition) 条件为true则通过 *_FALSE(condition) 条件为false则通过 *_EQ(expected, actual) == *_NE(val1, val2) != *_LT(val1, val2) &lt; *_LE(val1, val2) &lt;= *_GT(val1, val2) &gt; *_GE(val1, val2) &gt;= _STREQ(expected_str, actual_str) == 接收char wchar * *_STRNE(str1, str2) != _STRCASEEQ(expected_str, actual_str) 忽略大小写== ,只接收char _STRCASENE(str1, str2) 忽略大小写!= ,只接收char *_THROW(statement, exception_type) 语句抛出指定类型的异常 *_ANY_THROW(statement) 抛出任何异常 *_NO_THROW(statement) 不抛出 *_FLOAT_EQ(expected, actual) 浮点对比 *_DOUBLE_EQ(expected, actual) *_NEAR(val1, val2, abs_error) 近似对比 *_PRED1(pred1, val1) pred1表示函数名，val1是参数，验证返回值，最多可以到5，传5个参数。 *_PRED_FORMAT1(pred_format1, val1) 错误时可自定义输出，函数返回值 return testing::AssertionFailure(testring::Message()) *_HRESULT_SUCCEEDED(expression) 表达式是成功的 *_HRESULT_FAILED(expression) SUCCEED() 用例成功，不往下走 FAIL() 用例失败，不往下走 ADD_FAILURE() 失败，但是往下走 testing::StaticAssertTypeEq&lt;int, T&gt; 判断模板是否为int _DEATH(statement, regex) 语句crash，其regex匹配stderr中内容，实现其实就是调用了 _EXIT *_DEATH_IF_SUPPORTED 系统不支持则不执行 *_EXIT(statement, predicate, regex) 其中predicate必须是接收int返回bool，可用系统 testing::ExitedWithCode(exit_code)如果程序正常退出并且退出码与exit_code相同则返回true testing::KilledBySignal(signal_number) 被signal_number杀掉则为true _DEBUG_DEATH(statement, regex) 在Debug中 实际是调用 _DEATH，否则只是执行statement 死亡测试注意 可以在main中设置，也可以在用例中设置，用例完成会复原。 testing::FLAGS_gtest_death_test_style = “fast”; testing::FLAGS_gtest_death_test_style = “threadsafe”; 不要在死亡测试用例释放内存，在父进程释放内存，不要在程序中使用内存堆检查 Gtest事件 全局事件 全局事件需要继承testing::Environment类，实现SetUp和TearDown，类似构造与析构，然后在main中使用testing::AddGlobalTestEnvironment进行注册 TestSuite 每一组用例前后 需要继承testing::Test类，实现SetUpTestCase和TearDownTestCase，在该组用例前和结束执行 TestCase 每个用例前后 同上，实现SetUp()和TearDown()即可，在每个用例前后执行 Gtest测试宏TEST(test_suite_name,test_name)宏一个测试特例，套件名和样例名，构成一个测试用例，不能有_,因为会将其设置为专有的类名 TEST_F(test_fixture,test_name)宏结合testing::Test使用 TEST_P宏配合继承testing::TestWithParam的类使用,其中1234567891011121314template&lt;typename T&gt;class TestWithParam:public Test,public WithParamInterface&lt;T&gt;&#123;&#125;;static const T&amp; GetParam()&#123;&#125;//内部的参数由友元类修改，所以Getparam()可以获得新属性template&lt;class TestClass&gt; friend class internal::ParameterizedTestFactor;INSTANTIATE_TEST_CASE_P(test_pre_name,继承TestWithParam的类名,testing::Values());//其中第三个可以使用Range(begin,end[,step])//Values(v1,v2...,vN)//ValuesIn(container) and ValuesIn(begin,end) 从容器或者迭代器取//Bool() true和false//Combine(g1,g2,...,gN) 排列组合传入，参数是Tuple 模板参数化123456789101112template &lt;typename T&gt;class TemplateClass : public testing::Test &#123;&#125;typedef testing::Types&lt;char, int, unsigned int&gt; MyTypes;TYPED_TEST_SUITE(TemplateClass, MyTypes);//验证TemplateClass是否支持MyTypes这些类型TYPED_TEST(TemplateClass,TestName)//或者TYPED_TEST_CASE_P(TemplateClass)TYPED_TEST_P(TemplateClass,TestName)REGISTER_TYPED_TEST_CASE_P(TemplateClass,TestName,...)INSTANTIATE_TYPED_TEST_CASE_P(test_pre_name, TemplateClass, MyTypes)]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>Cpp基础</tag>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[CMake小结]]></title>
    <url>%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%2Fcmake%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899cmake -B build -DCMAKE_BUILD_TYPE=Releasecmake --build build -j4cmake --build build --target install如上设置了-D 当不清除Cache时，下次不加-D，也是Release-G 指定构建系统生成器 在cmake --help里面可以看到动态库链接静态库，需要开启PIC set(CMAKE_POSITION_INDEPENDENT_CODE ON)或者 set_property(TRGET lib PROPERTY POSITION_INDEPENDENT_CODE ON)设定find_package路径，把路径加入CMAKE_MODULE_PATH、查看包搜索路径，如Qt会找Qt5_DIR，把路径放这里也好使、环境变量的Qt5_DIR也行生成器表达式语法：$&lt;$&lt;类型:值&gt;:为真时的表达式&gt;比如 $&lt;$&lt;PLATFORM_ID:Windows,ABC&gt;:MY_NAME="Bill Gates"&gt;在 Windows或者ABC 平台上会变为 MY_NAME="Bill Gates"set(abc HELLO)set(HELLO ccc)if(abc MATCH HELLO) doneif($&#123;abc&#125; MATCH HELLO) no 其会展开为HELLO变量 再变成cccif("$&#123;abc&#125;" MATCH HELLO) done__declspec(dllexport) 导出__declspec(dllimport) 导入aux_source_directory(&lt;dir&gt; &lt;variable&gt;) #搜索dir目录内文件所有源文件，将列表写到var里list() #对列表操作include(&lt;file|module&gt; [OPTIONAL] [RESULT_VARIABLE &lt;var&gt;] [NO_POLICY_SCOPE]) #导入CMake代码。OPTIONAL，文件不存在不报错，RESULT_VARIABLE &lt;var&gt;，var将设置为完整文件名，失败为NOTFOUND。 # 若指定为module则在CMAKE_MODULE_PATH中找&lt;modulename&gt;.cmake，再去CMake模块路径找。除非文件在CMake内置模块路径中。set(&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE]) #value可以是0或多个，0即unset，多个时使用；分割。PARENT_SCOPE会向上一层传递，当在function中时，会向调用者传递，但是在当前层不生效，不加则会取时生效并向下传递。set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]) #默认情况下值不会被覆盖，除非使用了FORCE。可以通过GUI界面add entry添加，类似环境变量。 #BOOL复选框、FILEPATH文件选择框、PATH目录选择框、STRING文本框、STRINGS下拉框、INTERNAL不对外呈现，主要用于运行过程存储，该type意味着使用FORCE #docstring文本表示选项摘要 #缓存值是无法覆盖已经存同名的，除非设置了FORCE。如果条目是通过-Dvar=val创建，则会给其指定类型，而set命令会给予类型。若val是相对路径，set会将其转为绝对路径。set(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;]) #设置环境变量，只影响当前进程，不修改调用者进程和系统变量。CMake中的 [环境变量](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html) 也可以修改。file(read &lt;filename&gt; &lt;variable&gt; [OFFSET &lt;offset&gt;] [LIMIT &lt;max-in&gt;] [HEX]) #将文件读到var变量中，偏移量、读取长度、16进度读。file(STRINGS &lt;filename&gt; &lt;variable&gt; [&lt;options&gt; ...]) #以ASCII读取到var中，将忽略二进度、回车和\r。LENGTH_MAXMUN &lt;max-len&gt;、LENGTH_MINIMUN &lt;min-len&gt;、LIMIT_COUNT &lt;max-num&gt;限制字符串数量、LIMIT_OUTPUT &lt;max-out&gt;限制var总长度、NEWLINE_CONSUME不忽略换行、NO_HEX_CONVERSION不对16进度转换、REGX &lt;regex&gt;、ENCODING &lt;encoding-type&gt;。file(&lt;HASH&gt; &lt;filename&gt; &lt;variable&gt;) #将文件加密读入到var，HASH支持MD5、SHA!、SHA224、SHA256、SHA384、SHA512、SHA3_224、SHA3_256、SHA3_384、SHA3_512等。file(TIMESTAMP &lt;filename&gt; &lt;variable&gt; [&lt;format&gt;] [UTC]) #读取文件最后修改时间搓，format指定格式。file(WRITE &lt;filename&gt; &lt;content&gt; ... ) #可创建，覆盖定入file(APPEND &lt;filename&gt; &lt;content&gt; ... ) #可创建，追加file(TOUCH [&lt;files&gt; ...]) #创建空白文件，文件存在只刷新修改时间file(TOUCH_NOCREATE [&lt;files&gt; ...]) #文件不存在，不创建file（GENERATE OUTPUT output-file &lt;INPUT input-file|CONTENT content&gt; [CONDITION expression]) #在构建时将信息写到文件中，保证是本次构建的内容，仅当CONDITION &lt;expression&gt;为true时，才输出到文件 file(GLOB &lt;variable&gt; [LIST_DIRECTORIES true|false] [RELATIVE &lt;path&gt;] [&lt;globbing-expressions&gt;...]) #将当前目录内符合expressions的写到var里，LIST_D...表示是否输出文件夹名，RELATIVE &lt;path&gt;表示是否以相对path为相对路径输出file(GLOB_RECURSE &lt;variable&gt; [FOLLOW_SYMLINKS] [LIST_DIRECTORIES true|false] [RELATIVE &lt;path&gt;] [&lt;globbing-expressions&gt;...]) #FOLLOW_SYMLINKS设定和LIST_DIRECTORIES为true可以遍历子文件夹file(RENAME &lt;oldname&gt; &lt;newname&gt; [RESULT &lt;result&gt;] [NO_REPLACE]) #重命名file(REMOVE [&lt;files&gt;...]) #删除文件file(REMOVE_RECURSE [&lt;files&gt;...]) #会删除指定的文件及子目录，包括非空文件夹file(MAKE_DIRECTORY [&lt;directories&gt; ...]) #创建目录file(COPY_FILE &lt;oldname&gt; &lt;newname&gt; [RESULT &lt;result&gt;] [ONLY_IF_DIFFERENT])file(&lt;COPY|INSTALL&gt; &lt;files&gt;... DESTINATION &lt;dir&gt; [FILE_PERMISSIONS &lt;permissions&gt;...] [DIRECTORY_PERMISSIONS &lt;permissions&gt;...] [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS] [FILES_MATCHING] [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;] [EXCLUDE] [PERMISSIONS &lt;permissions&gt;...]] [...]) #OWNER_READO、WNER_WRITE、OWNER_EXECUTE、GROUP_READ、GROUP_WRITE、GROUP_EXECUTE、WORLD_READ、WORLD_WRITE、WORLD_EXECUTEfile(SIZE &lt;filename&gt; &lt;variable&gt;)file(READ_SYMLINK &lt;linkname&gt; &lt;variable&gt;) #获取符号文件的路径file(CREATE_LINK &lt;original&gt; &lt;linkname&gt; [RESULT &lt;result&gt;] [COPY_ON_ERROR] [SYMBOLIC]) #创建符号链接，默认是硬连接file(CHMOD|CHMOD_RECURSE &lt;files&gt;... &lt;directories&gt;... [PERMISSIONS &lt;permissions&gt;...] [FILE_PERMISSIONS &lt;permissions&gt;...] [DIRECTORY_PERMISSIONS &lt;permissions&gt;...]) #设置权限file(REAL_PATH &lt;path&gt; &lt;out-var&gt; [BASE_DIRECTORY &lt;dir&gt;] [EXPAND_TILDE]) #计算已解析符号链接的现有文件或目录的绝对路径file(RELATIVE_PATH &lt;variable&gt; &lt;directory&gt; &lt;file&gt;) #根据file推出相对dir的相对路径file(TO_CMAKE_PATH "&lt;path&gt;" &lt;variable&gt;) #转为CMake格式的路径file(TO_NATIVE_PATH "&lt;path&gt;" &lt;variable&gt;) #转换为特定平台格式的路径file(DOWNLOAD &lt;url&gt; [&lt;file&gt;] [&lt;options&gt;...]) #从指定URL下载文件file(UPLOAD &lt;file&gt; &lt;url&gt; [&lt;options&gt;...]) #上传file(LOCK &lt;path&gt; [DIRECTORY] [RELEASE] [GUARD &lt;FUNCTION|FILE|PROCESS&gt;] [RESULT_VARIABLE &lt;variable&gt;] [TIMEOUT &lt;seconds&gt;]) #对指定文件上锁file(ARCHIVE_CREATE OUTPUT &lt;archive&gt; PATHS &lt;paths&gt;... [FORMAT &lt;format&gt;] [COMPRESSION &lt;compression&gt; [COMPRESSION_LEVEL &lt;compression-level&gt;]] [MTIME &lt;mtime&gt;] [VERBOSE]) #根据 &lt;paths&gt; 中的文件或目录 创建归档文件 &lt;archive&gt;。FORMAT 指定归档格式，支持的值为 7zip、gnutar、pax、paxr、raw 和 zip，默认格式为 paxrfile(ARCHIVE_EXTRACT INPUT &lt;archive&gt; [DESTINATION &lt;dir&gt;] [PATTERNS &lt;patterns&gt;...] [LIST_ONLY] [VERBOSE] [TOUCH]) #提取归档文件 &lt;archive&gt;，并输出到 DESTINATION 目录中，如果目录不存在，它将被创建，默认情况下输出目录为 CMAKE_CURRENT_BINARY_DIR 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182add_library(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUED_FROM_ALL] [&lt;source&gt;...]) #使用指定的source生成对应平台的库。static、shared、module则表示类型，module则是在使用时使用dlopen动态加载的模块。add_library(&lt;name&gt; OBJECT [&lt;source&gt;...]) #添加OBJECT库，可以使用$&lt;TARGET_OBJECTS:objlib&gt;方式使用，感觉就是一个集合add_library(&lt;name&gt; INTERFACE) #其不编译也不生成东西，一般用于携带属性传递add_library(&lt;name&gt; &lt;type&gt; IMPORTED [GLOBAL]) #导入一个已经存在的库，type为STATIC, SHARED, MODULE, UNKNOWN其一，通过IMPORTED导入的类，其属性以IMPORTED_开头，否则为INTERFACE_开头。IMPORTED_LOCATION标明library硬盘位置，可加DEBUG/RELEASE进行具体；IMPORTED_OBJECTS标明对象Library在硬盘的位置，也可加...。PUBLIC_HEADER保存install头文件目录add_library(&lt;name&gt; ALIAS &lt;target&gt;) #设置别名add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1] [source2 ...]) #WIN32将WIN32_EXECUTABLE设置为true，其会创建一个使用WinMain()入口的GUI可执行文件，而不是控制台应用程序。MACOSX_BUNDLE将在macOS或者iOS设置为true，使其可以在Finder启动GUI可执行文件。EXCLUDE_FORM_ALL表示可执行文件会排除在alltarget列表外，当执行默认的make或者nmake时，不会编译，需要make name手动指明才会编译。add_executable(&lt;name&gt; IMPORTED [GLOBAL]) #从外部导入可执行文件，不指定GLOBAL则只向下传递，其属性IMPORTED会设置为true。add_executable(&lt;name&gt; ALIAS &lt;target&gt;)target_sources(&lt;target&gt; &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) #给target添加编译文件 按执行顺序添加文件target_sources(&lt;target&gt; [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [FILE_SET &lt;set&gt; [TYPE &lt;type&gt;] [BASE_DIRS &lt;dirs&gt;...] [FILES &lt;files&gt;...]]... ]...) #每个target有多个文件集，文件集有自己的属性。会给PRIVATE和PUBLIC的文件设置为源文件，HEADERS文件设置HEADER_FILE_ONLY为true。FILE_SET &lt;set&gt;，文件集名，有预留的是HEADERS，然后不能以_和大写字母开头。TYPE &lt;type&gt;，若为HEADERS则可省，否则加。BASE_DIRS &lt;dirs&gt;...，文件集目录列表，首次创建可填CMAKE_CURRENT_SOURCE_DIR。FILES &lt;files&gt;...，文件列表，文件要位于目录列表中。target_compile_definitions(&lt;target&gt; &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) #给target添加编译定义target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) #AFTER、BEFORE 添加到列表的前面或者后面，默认后面，CMAKE_INCLUDE_DIRECTORIES_BEFORE可以修改默认值；SYSTEM则表示指定目录为系统目录，仅当前CMakeList.txt生效 #INTERFACE、PUBLIC填充INTERFACE_INCLUDE_DIRECTORIES属性，而PRIVATE和PUBLIC填充填充INCLUDE_DIRECTORIES属性include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) #添加头文件搜索目录 相当于-l 从当前文件开始向下传递link_directories([AFTER|BEFORE] directory1 [directory2 ...]) #添加库搜索目录 相当于-L 用在add_executable之前link_libraries([item1 [item2 [...]]] [[debug|optimized|general] &lt;item&gt;] ...) #添加库文件路径 全路径包括库名target_link_libraries(&lt;target&gt; ... &lt;item&gt;... ...) #用在add_executable之后#item 可能是library target name、full path to a library file、plain library name、link flag、generator expression、A debug, optimized, or general keyword immediately followed by another &lt;item&gt;。 ex: hello libhello.a libhello.so -lhelloget_filename_component(&lt;var&gt; &lt;FileName&gt; &lt;mode&gt; [CACHE]) #根据mode获取文件路径中指定项到var中 3.20以后被cmake_path取代option(&lt;variable&gt; "&lt;help_text&gt;" [value]) #提供用户可选的布尔选项，若var已经定义或者在CACHE里，则不生效configure_file(&lt;input&gt; &lt;output&gt; [NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS | FILE_PERMISSIONS &lt;permissions&gt;...] [COPYONLY] [ESCAPE_QUOTES] [@ONLY] [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ]) 将文件复制到其它位置并修改内容，将input文件中@var@或者$&#123;var&#125;替换为cmake指定的值，#cmakedefine var关键字替换成#define var或者#undef var，取决是否定义了var；input，一定是要文件；output，可以是路径，那就会使用intput的名字；COPYONLY，直接拷贝，啥也不干；ESCAPE_QUOTES，不转义；@ONLY，只替换@，不替换$；NEWLINE_STYLE，指定Output换行风格。需要先include(CheckCXXCompilerFlag)check_cxx_compiler_flag(&lt;flag&gt; &lt;var&gt;) 检测编译器是否支持CXX，结果在var里mark_as_advanced([CLEAR|FORCE] &lt;var1&gt; ...) #清除或者标记var变量为advanced变量，advance变量不会显示在GUI中，除非advanced选项开启source_group(&lt;name&gt; [FILES &lt;src&gt;...] [REGULAR_EXPRESSION &lt;regex&gt;])source_group(TREE &lt;root&gt; [PREFIX &lt;prefix&gt;] [FILES &lt;src&gt;...]) #给IDE的源码分组，TREE，会根据root路径将src转为相对路径，自动的将文件结构分出来。PREFIX，TREE会放在该group里，可以使用\\指定子group。REGULAR_EXPRESSION，一个文件只会加入最后一个符合条件的group，如果没有则优先与最后一个组。set_property(&lt;GLOBAL | DIRECTORY [&lt;dir&gt;] | TARGET [&lt;target1&gt; ...] | SOURCE [&lt;src1&gt; ...] [DIRECTORY &lt;dirs&gt; ...] [TARGET_DIRECTORY &lt;targets&gt; ...] | INSTALL [&lt;file1&gt; ...] | TEST [&lt;test1&gt; ...] | CACHE [&lt;entry1&gt; ...] &gt; [APPEND] [APPEND_STRING] PROPERTY &lt;name&gt; [&lt;value1&gt; ...]) #GLOBAL，属性全局有效；DIRECTORY，在指定目录有效，类似set_directory_proerties；TARGET，设置target属性，类似set_target_properties；SOURCE，指定属性对应多个源文件，默认仅对同一目录中的目标可见，类似set_source_files_properties，DIRECTORY，源文件在每个dirs有效，dirs必须已知，TARGET_DIRECTORY在指定的targets中有效，targets必须有效；INSTALL，属性对应多个安装文件路径；TEST，对应多个测试，类似set_tests_properties；CACHE，对应缓存条目。APPEND，以列表形式附加到属性后面。APPEND_STRING，以字符串形式添加到属性后面。get_property(&lt;variable&gt; &lt;GLOBAL | DIRECTORY [&lt;dir&gt;] | TARGET &lt;target&gt; | SOURCE &lt;source&gt; [DIRECTORY &lt;dir&gt; | TARGET_DIRECTORY &lt;target&gt;] | INSTALL &lt;file&gt; | TEST &lt;test&gt; | CACHE &lt;entry&gt; | VARIABLE &gt; PROPERTY &lt;name&gt; [SET | DEFINED | BRIEF_DOCS | FULL_DOCS]) #VARIABLE，范围内唯一，不接收名字。SET，变量设为布尔，表示是否设置了属性；DEFINED，变量设置为布尔，表示属性是否定义；BRIEF_DOCS | FULL_DOCS，设置为字符串，包含请示的属性，没有会写NOTFOUND。set_target_properties(target1 target2 ... PROPERTIES prop1 value1 prop2 value2 ...) #同时设置多个target的多个属性get_target_property(&lt;VAR&gt; target property) #获取target属性add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) #添加子目录进行构建，source_dir，子目录CMakeList.txt的位置；binary_dir，输出目录；EXCLUDE_FROM_ALL，是否排除自动构建add_compile_options(&lt;option&gt; ...) #添加选项到编译源文件，对当前目录的targets和向下有效target_compile_options(&lt;target&gt; [BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) #给target添加编译参数，BEFORE，放到所有属性前，默认是追加add_definitions(-DFOO -DBAR ...) #将定义添加到编译器命令行，不管写在前后都生效，并向下目录传递，相当于-Dadd_dependencies(&lt;target&gt; [&lt;target-dependency&gt;]...) #确保依赖的target在自己前生成message([&lt;mode&gt;] "message text" ...) #FATAL_ERROR，会中断编译；SEND_ERROR，继续处理，但是会跳过生成；WARNING，发出警告，继续处理。AUTHOR_WARNING，警告dev，继续处理；DEPRECATION，根据CMAKE_ERROR_DEPRECATED或者CMAKE_WARN_DEPRECATED状态决定是警告还是错误；(none) or NOTICE，重要标准错误；STATUS，信息；VERBOSE，更详细的信息；DEBUG，项目开发人员；TRACE，临时信息。message(&lt;checkState&gt; "message text" ...) #CHECK_START，记录将要执行检查的消息；CHECK_PASS，记录一个成功结果；CHECK_FAIL，记录一个失败结果。project(&lt;PROJECT-NAME&gt; [&lt;language-name&gt;...]) #指定cmake工程名，&lt;language-name&gt; 语言project(&lt;PROJECT-NAME&gt; [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]] [DESCRIPTION &lt;project-description-string&gt;] [HOMEPAGE_URL &lt;url-string&gt;] [LANGUAGES &lt;language-name&gt;...]) #VERSION，版本；DESCRIPTION，描述；HOMEPAGE_URL，主页URL；LANGUAGES，语言。当指定了project，会自动定义如下变量，则PROJECT_NAME工程名；PROJECT_SOURCE_DIR源码路径；&lt;PROJECT-NAME&gt;_SOURCE_DIR源码路径，与前者区别就是后者是指定工程的，前者是当前工程的；PROJECT_BINARY_DIR二进制路径；&lt;PROJECT-NAME&gt;_BINARY_DIR同意思；CMAKE_PROJECT_NAME顶层工程名。 指定了VERSION，会定义出一堆PROJECT_VERSION*和&lt;PROJECT-NAME&gt;_VERSION*。其它两个也一样。目前支持C、CXX、CUDA、OBJC、OBJCXX、Fortran、ASM，不指定则是C和CXX，指定为NONE或者LANGUAGES则表示不支持任何语言。检测CMAKE_&lt;LANGUAGES&gt;_COMPILER指定编译器是否存在。多次调用，则以最近一次为准。add_custom_target(Name [ALL] [command1 [args1...]] [COMMAND command2 [args2...] ...] [DEPENDS depend depend depend ... ] [BYPRODUCTS [files...]] [WORKING_DIRECTORY dir] [COMMENT comment] [JOB_POOL job_pool] [VERBATIM] [USES_TERMINAL] [COMMAND_EXPAND_LISTS] [SOURCES src1 [src2...]]) #根据命令生成一个target，且默认不在all target中，目标没有输出文件。ALL，加入all target；DEPENDS，依赖其它target或者文件；COMMAND，执行的命令，可以使用configure_file或者GENERATE生成脚本再执行；BYPRODUCTS，声明target随之生成的文件，需要有COMMAND命令否则报错；WORKING_DIRECTORY，修改当前COMMAND执行命令的目录；COMMENT，构建时执行COMMAND前的消息；JOB_POOL，指定一个池给Ninja生成器，VERBATIM，所有参数都根据构建工具转义，以保证COMMAND正确接收参数，否则行为依赖平台行为；USES_TERMINAL，直接访问终端的权限；COMMAND_EXPAND_LISTS，参数列表将展开，包括生成器表达式列表；SOURCES，将文件附加到目标中，在IDE中显示。add_custom_command(OUTPUT output1 [output2 ...] COMMAND command1 [ARGS] [args1...] [COMMAND command2 [ARGS] [args2...] ...] [MAIN_DEPENDENCY depend] [DEPENDS [depends...]] [BYPRODUCTS [files...]] [IMPLICIT_DEPENDS &lt;lang1&gt; depend1 [&lt;lang2&gt; depend2] ...] [WORKING_DIRECTORY dir] [COMMENT comment] [DEPFILE depfile] [JOB_POOL job_pool] [VERBATIM] [APPEND] [USES_TERMINAL] [COMMAND_EXPAND_LISTS]) #在生成的构建系统中添加自定义构建规则，当没有output1或者DEPENDS的东西发生变化时，则生成；MAIN_DEPENDENCY，指定主要输入文件，源文件只能作为一个命令的主依赖项；IMPLICIT_DEPENDS，请求扫描输入文件的隐式依赖关系；DEPFILE，为Ninja生成器制定一个depfile文件；APPEND将其追加到第一个自定义输出命令；add_custom_command(TARGET &lt;target&gt; PRE_BUILD | PRE_LINK | POST_BUILD COMMAND command1 [ARGS] [args1...] [COMMAND command2 [ARGS] [args2...] ...] [BYPRODUCTS [files...]] [WORKING_DIRECTORY dir] [COMMENT comment] [VERBATIM] [USES_TERMINAL] [COMMAND_EXPAND_LISTS]) #为目标添加自定义命令，目标构建时执行，PRE_BUILD | PRE_LINK | POST_BUILD表示命令执行相对构建的时机&gt; 当add_custom_target所要生成的target依赖add_custom_command所生成的文件时，这个文件就是一个纽带；add_custom_command命令输出的OUTPUT文件和命令里的command之间的关系是：每当这个文件需要被重新生成时，都会执行这段command；开始构建target，依赖add_custom_command的输出文件，再查看其是否构建，其构建就会执行COMMAND。execute_process(COMMAND &lt;cmd1&gt; [&lt;arguments&gt;] [COMMAND &lt;cmd2&gt; [&lt;arguments&gt;]]... [WORKING_DIRECTORY &lt;directory&gt;] [TIMEOUT &lt;seconds&gt;] [RESULT_VARIABLE &lt;variable&gt;] [RESULTS_VARIABLE &lt;variable&gt;] [OUTPUT_VARIABLE &lt;variable&gt;] [ERROR_VARIABLE &lt;variable&gt;] [INPUT_FILE &lt;file&gt;] [OUTPUT_FILE &lt;file&gt;] [ERROR_FILE &lt;file&gt;] [OUTPUT_QUIET] [ERROR_QUIET] [COMMAND_ECHO &lt;where&gt;] [OUTPUT_STRIP_TRAILING_WHITESPACE] [ERROR_STRIP_TRAILING_WHITESPACE] [ENCODING &lt;name&gt;] [ECHO_OUTPUT_VARIABLE] [ECHO_ERROR_VARIABLE] [COMMAND_ERROR_IS_FATAL &lt;ANY|LAST&gt;]) #命令作为管道同时执行，其输出管道作为下个管道的输入，共享一个错误管道。COMMAND，子进程命令行，CMake使用API直接执行子进程，中间不能使用shell脚本，像重定义等操作符都当普通参数；WORKING_DIRECTORY，指定子进程的工作目录；TIMEOUT，超时时间；RESULT_VARIABLE，执行进程的返回结果，最后一个子进程整数或者错误描述字符串；RESULTS_VARIABLE，接收第条命令返回结果；OUTPUT_VARIABLE，ERROR_VARIABLE，设置为输出管道和错误管道的内容，若命名相同，则输出将按生成的顺序合并；INPUT_FILE, OUTPUT_FILE, ERROR_FILE，第一个标准输入名，最后一个标准输出名，所有的标准错误名；OUTPUT_QUIET, ERROR_QUIET，输出和错误将忽略；COMMAND_ECHO &lt;where&gt;重置命令到指定标准输出，如STDERR、STDOUT、NONE；OUTPUT_STRIP_TRAILING_WHITESPACE、ERROR_STRIP_TRAILING_WHITESPACE删除输出空白符；ENCODING &lt;name&gt;，在win上指定解码方式，NONE、AUTO、ANSI、OEM、UTF8、UTF-8；ECHO_OUTPUT_VARIABLE, ECHO_ERROR_VARIABLE，不会专门重定向到配置的变量，将发送到配置的变量中和标准输出或错误中；COMMAND_ERROR_IS_FATAL &lt;ANY|LAST&gt;，决定出错时的行为ANY出错则停止报错，LAST则只看最后一个find_package目的是帮助我们调用对应的cmake文件，导入某个库，这个cmake文件是官方、安装、自行编写的，其格式为Find&lt;lib_name&gt;.cmake、。一般会产生&lt;lib_name&gt;_FOUND、&lt;lib_name&gt;_INCLUDE_DIR、&lt;lib_name&gt;_INCLUDES、&lt;lib_name&gt;_LIBRARY、&lt;lib_name&gt;_LIBRARIES，需要根据cmake文件中实现决定，并不统一。其引入模式分为两种，Module和Config，其中Module是从CMAKE_MODULE_PATH和cmake安装路径/Modules中，找的是Find&lt;lib_name&gt;.cmake；Config找的是&lt;lib_name&gt;Config.cmake或&lt;lib_name&gt;-config.cmake，其一般是通过安装添加到/usr/local/lib/cmake/...目录的。find_package(&lt;PackageName&gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [[COMPONENTS] [components...]] [OPTIONAL_COMPONENTS components...] [REGISTRY_VIEW (64|32|64_32|32_64|HOST|TARGET|BOTH)] [GLOBAL] [NO_POLICY_SCOPE] [BYPASS_PROVIDER]) #MODULE，只在该模式找；version，找的版本；EXACT，查找的版本要精确匹配；QUIET，找到包时，不输出信息；REQUIRED，找不到会终止；COMPONENTS，要查找的子组件；OPTIONAL_COMPONENTS，可选组件；REGISTRY_VIEW，在win中怎么查询注册表；GLOBAL，将找到的目标设为全局可见；NO_POLICY_SCOPE；BYPASS_PROVIDER，可以直接调用find_package内置的实现，防止自调用； CONFIG|NO_MODULE，指定搜索模式；NAMES使用该名为lib_name名；PATHS/HINTS，Config模式下，搜索的路径；NO_XXX_PATH，Config模式下，忽略的路径。默认优先用MODULE模式，CMAKE_FIND_PACKAGE_PREFER_CONFIG可以更换。]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git小结]]></title>
    <url>%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%2Fgit%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Git小结集中式版本控制SVN所有东西都存在服务器，不连网不能同步和切换，需要定期备份。 分布式版本控制Git，每个人保存的都是所有版本 git组成部分工作区 –add-&gt; 暂存区 –commit-&gt; 本地仓库 –push-&gt; 远程工作区 &lt;-checkout– 暂存区 &lt;-reset– 本地仓库 &lt;-fetch/clone– 远程工作区 &lt;-checkout HEAD– 本地仓库工作区 &lt;-pull– 远程 git配置12345678910111213git config --local --global --system 配置影响的范围，本仓库、本用户、本系统不加后面具体值表示查看--list 查看config信息user.name &quot;&quot; 用户名user.email &quot;&quot; 用户邮箱core.autocrlf true\input\false 提交为lf取出改为crlf、提交改为lf、什么也不改core.safecrlf true\false\warn 拒绝包含混合的文件、允许、给予警告credential.helper store --file .m_credentials 保存密码存证，Push到https连接时，可不输入密码，--file后面是目录地址alias 别名 alias.ci &apos;commit&apos; 以后可以用ci表示commit 后面不是git命令 可以用!表示，如&apos;!gitk&apos;https.proxy http://127.0.0.1:1080 和 --unset https.proxy 设置和取消代理 git常用12345678HEAD 最后的提交HEAD^ 倒数第二提交HEAD^^或者HEAD~2 倒数第三init 在工作目录创建主分支clone 克隆 -b 分支名 --depth 次数（不想把记录也搞下来可以为1） 地址stash 暂存 save &quot;信息&quot; 暂存且指定名字 list 查看暂存 pop 弹出暂存 apply 类似pop，但是pop会删除暂存 drop 名称 移除 show -p 查看差异，p是详细 git查看123456log 查看日志 --stat 显示简短内容 --name-only 仅显示文件清单 --name-status 仅显示增删改的文件清单 --author=&quot;author&quot; 列出该用户 --grep=&quot;&quot; 过滤，可加--all--match表示同时满足 file 可以指定文件，查看某文件status 当前状态blame -L &lt;start&gt;,&lt;end&gt; 文件名 查看文件历史，从第start行到end行diff 查看工作与暂存的差异 --cached &lt;reference&gt; 查看暂存和某次提交的差异，默认是HEADshow &lt;reference&gt;/标签名 查看某提交信息tag 给提交或者仓库打标签 名/名 &lt;reference&gt; 给当前仓库/提交打标签 -d 名 删除标签 -m &quot;&quot; 注释信息 git删除123clean 清除没有被跟踪的文件 -n 查看要清除什么 -f 执行清除 -x 连ingore的都删除 -X 只删除ignore -d 删除目录 path 指定目录，不加则为整仓库rm 文件名 将文件移除 --cached 从暂存区移除reset [--soft | --mixed | --hard] [HEAD] --soft 工作区不变，暂存区不变，本地仓库回滚 --mixed 默认参数，工作区不变，暂存区回滚，本地仓库回滚，需重新add --hard 三个区都回滚 git拉取提交1234567add 文件名 添加文件，用.表示所有commit --amend 结合上次提交一起 -m &quot;&quot; 注释 -a 跳过暂存区，直接到本地仓库pull &lt;远程主机名&gt;(origin) &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程主机，分支与本地分支合并 --rebase 执行rebase不执行merge 实际该指令大概可以理解为fetch + mergepush &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; -u 名 指定默认主机 --force 强制推送，冲掉差异 --tags 推送标签fetch &lt;远程主机名&gt; &lt;分支名&gt; 从远程获取最新版本，不指定分支名即全部merge 分支名 合并该分支到当前分支rebase 分支名 将另一分支合并到当前，不留痕迹，不像merge那样，将提交合并成patch，然后转到当前分支apply，当有冲突时，解决完用add后，执行--continue则继续执行apply，或者用--abort结束 git分支1234branch 列出本地所有分支；分支名 创建分支；-b 分支名 创建并切换分支；-a 列出所有分支；-m 名1 名2 将名1改为名2；-d 名 删除分支checkout 文件名；分支名 切换分支；-b 名 [commit id] 创建并切换；commit id 切换到某提交； chrry-pick &lt;commit id&gt;【..&lt;commit id&gt;】 将提交应用到其它分支remote git补丁1234format-patch &lt;commit id&gt; -n 打包id和之前n-1个到patch，patch是一个提交一个；&lt;id&gt;..&lt;id&gt; 打包之间的；--stdout &gt; fiilename.patch 指定名字diff &lt;id&gt; &lt;id&gt; &gt; filename.diff 打包到diff，只有一个apply --check filename 应用 但是不创建提交am filename 应用且创建提交 git文件12345678910111213.gitignore filename 忽略指定文件 filepath 忽略指定文件夹 * 统配符 !xxx 这xxx文件不忽略 /xxx 表示忽略最上层的xxxgit check-ignore检查..gitmodulesgit submodule add &lt;url&gt; &lt;path&gt; 添加子模块，path为保存路径git submodule update --init --recursive 拉取子模块移除子模块-&gt;移除目录、移除.gitmodules信息、移除.git/config信息、移除.git/module/ 对应信息]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL视图]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[视图含义：理解成一张虚拟的表，通过表动态生成的数据 视图和表的区别： 使用方式 占用物理空间 视图 完全相同 不占用，仅仅保存的是sql逻辑 表 完全相同 占用 视图的好处： 1、sql语句提高重用性，效率高 2、和表实现了分离，提高了安全性 视图的创建语法： CREATE VIEW 视图名 AS 查询语句; 视图的增删改查对视图增删改，也会修改原表 1、查看视图的数据 ★ SELECT * FROM my_v4; SELECT * FROM my_v1 WHERE last_name=&apos;Partners&apos;; 2、插入视图的数据 INSERT INTO my_v4(last_name,department_id) VALUES(&apos;虚竹&apos;,90); 3、修改视图的数据 UPDATE my_v4 SET last_name =&apos;梦姑&apos; WHERE last_name=&apos;虚竹&apos;; 4、删除视图的数据 DELETE FROM my_v4; 某些视图不能更新包含以下关键字的 sql语句：分组函数、distinct、group by、having、union或者union all 常量视图 Select中包含子查询 join from一个不能更新的视图 where子句的子查询引用了from子句中的表 视图逻辑的更新#方式一： CREATE OR REPLACE VIEW test_v7 AS SELECT last_name FROM employees WHERE employee_id&gt;100; #方式二: ALTER VIEW test_v7 AS SELECT employee_id FROM employees; SELECT * FROM test_v7; 视图的删除DROP VIEW test_v1,test_v2,test_v3; 视图结构的查看DESC test_v7; SHOW CREATE VIEW test_v7;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL流量控制]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[流程控制结构分支一、if函数 语法： if(表达式1，表达式2，表达式3) 1成立则返回2，否则返回3 特点： 可以用在任何位置 二、case语句 语法： 情况一：类似于switch-case case 变量|表达式|字段 when 值1 then 值1|表达式1; when 值2 then 值2|表达式2; ... else 值n|表达式n; end [case]（如果是放在begin end中需要加上case，如果放在select后面不需要） 情况二：类似于多重if case when 条件1 then 值1|表达式1; when 条件2 then 值2|表达式2; ... else 值n|表达式n; end [case]（如果是放在begin end中需要加上case，如果放在select后面不需要） 特点： 可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，可以放在任何地方；可以作为独立语句去使用，只能放begin end中 所有条件不满足有ELSE则执行，无ELSE则返回NULL 三、if elseif语句 语法： if 条件1 then 语句1; elseif 条件2 then 语句2; ... else 语句n; end if; 特点： 只能用在begin end中！！！！！！！！！！！！！！！ 三者比较 应用场合 if函数 简单双分支 case结构 等值判断 的多分支 if结构 区间判断 的多分支 循环语法： [标签：]WHILE 循环条件DO 循环体 END WHILE [标签]; leave 标签; //像break iterate 标签; //像continue 特点： 只能放在BEGIN END里面 如果要搭配leave跳转语句，需要使用标签，否则可以不用标签 [标签：]loop 循环体 END loop [标签]; [标签：]repeat 循环体 untile 结束循环的条件 END repeat [标签]; //像do while]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库概念]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[数据库的好处1.持久化数据到本地 2.可以实现结构化查询，方便管理 数据库相关概念1、DB：Database数据库，保存一组有组织的数据的容器 2、DBMS：Database Management System数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 3、SQL：Structure Query Language结构化查询语言，用于和DBMS通信的语言 数据库存储数据的特点1、将数据放到表中，表再放到库中 2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。 3、表具有一些特性，这些特性定义了数据在表中如何存储。 4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的。 5、表中的数据是按行存储的。 MySQL产品的介绍和安装MySQL服务的启动和停止1、计算机——右击管理——服务 2、通过管理员身份运行 net start 服务名（启动服务） net stop 服务名（停止服务） MySQL服务的登录和退出1、通过mysql自带的客户端 只限于root用户 2、通过windows自带的客户端 登录： mysql 【-h主机名 -P端口号 】-u用户名 -p密码 退出： exit或ctrl+C MySQL的常见命令1.查看当前所有的数据库 show databases; 2.打开指定的库 use 库名 3.查看当前库的所有表 show tables; 4.查看其它库的所有表 show tables from 库名; 5.创建表 create table 表名( 列名 列类型, 列名 列类型， ... ); 6.查看表结构 desc 表名; 7.显示表中的所有数据 select * from 表名; 7.查看服务器的版本 登录到mysql服务端 select version(); 没有登录到mysql服务端 mysql --version 或 mysql --V MySQL的语法规范1.不区分大小写,但建议关键字大写，表名、列名小写 2.每条命令最好用分号结尾 3.每条命令根据需要，可以进行缩进 或换行 4.注释 单行注释：#注释文字 单行注释：-- 注释文字 多行注释：/* 注释文字 */ SQL的语言分类DQL（Data Query Language）：数据查询语言 select DML(Data Manipulate Language):数据操作语言 insert 、update、delete DDL（Data Define Languge）：数据定义语言 create、drop、alter TCL（Transaction Control Language）：事务控制语言 commit、rollback]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用函数]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[常见函数一、单行函数 1、字符函数 concat拼接 substr截取子串 索引从1开始 upper转换成大写 lower转换成小写 trim去前后指定的空格和字符 trim(&apos;a&apos; from &apos;aaababbaaa&apos;) 输出babb ltrim去左边空格 rtrim去右边空格 replace替换 lpad左填充 rpad右填充 instr返回子串第一次出现的索引 length 获取字节个数 2、数学函数 round 四舍五入 rand 随机数 floor向下取整 ceil向上取整 mod取余 truncate截断 3、日期函数 now()当前系统日期+时间 year(now()) 截取年 month() curdate()当前系统日期 curtime()当前系统时间 str_to_date(&apos;时间&apos;,&apos;如何解析&apos;) 返回合规的时间 date_format(&apos;时间&apos;,&apos;如何输出&apos;) 返回想要的时间 4、流程控制函数 1. if(条件,true_ret,false_ret) 2. case key when val then 处理 when val then 处理 ... else 处理 end * key可以不写，有时val与key要合规，无时则val为条件 5、其他函数 version版本 database当前库 user当前连接用户 二、分组函数 sum 求和 max 最大值 min 最小值 avg 平均值 count 计数 特点： 1、以上五个分组函数都忽略null值，除了count(*) 2、sum和avg一般用于处理数值型 max、min、count可以处理任何数据类型 3、都可以搭配distinct使用，用于统计去重后的结果 4、count的参数可以支持： 字段、*、常量值，一般放1，都是求表中有多少行 建议使用 count(*)，在MYISAM中，count(*)有缓存，效率高，INNODB中，count(*)和count(1)类似 5、分组函数一般要求是group by后的字段，否则没有意义]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用类型与约束]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[常见类型整型：Tinyint 1Byte Smallint 2B Mediumint 3B Int、integer 4B Bigint 8B * 加上unsigned会表示无符号 * 超过会报out of range value，但是会插入边界值 不设置长度，那会有默认的长度，表示显示宽度，加上ZEROFILL约束后，自动变成unsigned，显示时不够长用0补充 小数：浮点型 float(M,D) 4B double(M,D) 8B 定点型，下面两者是一样的 DEC(M,D) M+2 DECIMAL(M,D) M+2 * D表示小数点位数，M表示小数+整数一共多少位，但是都可以省略不写，DECIMAL(10,0)默认，float和double会根据精度决定 * 精度要求高的用DEC 字符型：较短 char(M) 0~255 比varchara效率高 varchar(M) 0~65535 会根据实际给内存 binary 类似上面的，保存二进制 varbinary 较长 text blob(较长的二进制数据) ENUM v的值只能是a或者b，不然为空 CREATE TABLE T ( v ENUM(&apos;a&apos;,&apos;b&apos;) ); SET v的值由set内容组成，不分大小写，多个用逗号分开a,B CREATE TABLE T ( v SET(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) ); * M表示字符数，中文也只算个，char可以省略，为1，varchar不可以 日期型：data 4 只有日期 datatime 8 有日期和时间 timestamp 4 时刻 受时区影响 time 3 只有时间 year 1 只有年 Blob类型：常见约束一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性 CREATE TABLE 表名( 字段名 字段类型 约束 ) NOT NULL 非空，用于保证该字段的值不能为空 DEFAULT 默认，用于保证该字段有默认值 UNIQUE 唯一，值具有唯一性，可以为空 CHECK 检查约束【mysql中不支持，但是不报错】 PRIMARY KEY 主键，值具有唯一性且非空 FOREIGN KEY 外键，用于限制两个表的关系，保证该字段的值必须来自于主表的关联列的值。就是该值能在别的表中找到。在从表添加外键约束，用于引用主表中某列的值。（数据在主表中，从表只有个编号） 如 员工表的部门编号，学生表的专业编号 主键和唯一： 都有唯一性 唯一只可以有一个null，主键不可以有；一个表只能有一个主键 **可使用多个值共同作为主键**，唯一也可以由多个值组成 外键 在从表中设置外键关系 从表的外键列的类型和主表的关联列类型一致或兼容 主表的关联列必须唯一性（主键或者唯一） 插入数据时，先插入主表，再插入从表，删除则相反 约束的类型： CREATE TABLE 表名( 名 类型 列级约束, 表级约束 ) 列级约束 六大约束语法上都支持，但外键约束没有效果 CREATE TABLE 表名( id int primary key, stuname varchar(20) not null, gender char(1) check(gender=&apos;b&apos; or gender=&apos;g&apos;), seat int unique, age int default 18, majorid int references major(id) //无效 ) CREATE TABLE major( id int primary key, majorname varchar(20) ) 表级约束 除了非空、默认，其它都支持 [CONSTRAINT name] 这是可选的 CREATE TABLE 表名( id int, stuname varchar(20), gender char(1) , seat int, age int, majorid int， CONSTRAINT pk primary key(id), CONSTRAINT uq unique(seat), CONSTRAINT ck CHECK(gender=&apos;b&apos; or gender=&apos;g&apos;), CONSTRAINT fk_表名_major foreign key(majorid) references major(id) ) 添加约束的时机： 创建表时 修改表时 ALTER TABLE T MODIFY COLUMN 字段名 字段类型 新约束 只要支持列级约束 ALTER TABLE T ADD COLUMN [constraint 约束名] 约束 只要支持表级约束 ALTER TABLE T DROP PRIMARY KEY ALTER TABLE T DROP INDEX 唯一键名 ALTER TABLE T DROP FOREIGN KEY 外键名 标识列又称自增长列，可以不用手动的插入值，系统提供默认的序列值 创建表时 CREATE TABLE T( id int primary key auto_increment, name varchar(20) ) 插入时，id这一位传入null就行，或者直接省略 必须配合唯一性的键使用 一个表只能有一个标识列，一个auto_increment关键字 标识列只能是数字型 auto_increment_increment 步行 这是系统的值 用SET ...=n 修改 auto_increment_offset 起始 也可以插入一行，修改offset当前值 修改表时 ALTER TABLE T MODIFY COLUMN 字段名 字段类型 约束 auto_increment;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储过程和函数]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[存储过程含义：一组经过预先编译的sql语句的集合好处： 1、提高了sql语句的重用性，减少了开发程序员的压力 2、提高了效率，简化操作 3、减少编译次数和连接次数 分类： 1、无返回无参 2、仅仅带in类型，无返回有参 3、仅仅带out类型，有返回无参 4、既带in又带out，有返回有参 5、带inout，有返回有参 注意：in、out、inout都可以在一个存储过程中带多个 创建存储过程语法： create procedure 存储过程名(in|out|inout 参数名 参数类型,...) begin 存储过程体 end 注意 1、需要设置新的结束标记 delimiter 新的结束标记 示例： delimiter $ CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) BEGIN sql语句1; sql语句2; END $ 2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end 3、参数前面的符号的意思 in：该参数只能作为输入（该参数不能做返回值） out：该参数只能作为输出（该参数只能做返回值） inout：既能做输入又能做输出 调用存储过程call 存储过程名(实参列表) 删除存储过程drop procedure 存储过程名 查看存储过程show create procedure 存储过程名 函数创建函数学过的函数：LENGTH、SUBSTR、CONCAT等语法： CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型 BEGIN 函数体 END 调用函数SELECT 函数名（实参列表） 删除函数drop function 存储过程名 查看函数show create function 存储过程名 函数和存储过程的区别 关键字 调用语法 返回值 应用场景 函数 FUNCTION SELECT 函数() 有且仅有一个 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个 存储过程 PROCEDURE CALL 存储过程() 可以有0个或多个 一般用于增删改、批量操作]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL变量概念]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E5%8F%98%E9%87%8F%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[系统变量一、全局变量 作用域：针对于所有会话（连接）有效，但不能跨重启 查看所有全局变量 SHOW GLOBAL VARIABLES; 查看满足条件的部分系统变量 SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;; 查看指定的系统变量的值 SELECT @@global.autocommit; 为某个系统变量赋值 SET @@global.autocommit=0; SET GLOBAL autocommit=0; 二、会话变量 作用域：针对于当前会话（连接）有效 查看所有会话变量 SHOW SESSION VARIABLES; 查看满足条件的部分会话变量 SHOW SESSION VARIABLES LIKE &apos;%char%&apos;; 查看指定的会话变量的值 SELECT @@autocommit; SELECT @@session.tx_isolation; 为某个会话变量赋值 SET @@session.tx_isolation=&apos;read-uncommitted&apos;; SET SESSION tx_isolation=&apos;read-committed&apos;; show 模糊或者多个 selece 指定 不写global默认是session 自定义变量一、用户变量 声明并初始化： SET @变量名=值; SET @变量名:=值; SELECT @变量名:=值; 赋值： 方式一：一般用于赋简单的值 SET 变量名=值; SET 变量名:=值; SELECT 变量名:=值; 方式二：一般用于赋表 中的字段值 SELECT 字段名或表达式 INTO 变量 FROM 表; 使用： select @变量名; 二、局部变量 仅仅在定义它的begin和end中有效 声明： declare 变量名 类型 【default 值】; 赋值和使用，与用户变量一样 二者的区别： 作用域 定义位置 语法 用户变量 当前会话 会话的任何地方 加@符号，不用指定类型 局部变量 定义它的BEGIN END中 BEGIN END的第一句话 一般不用加@,需要指定类型]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL DQL数据查询语言]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql-dql%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[DQL语言的学习基础查询语法： SELECT 要查询的东西【FROM 表名】; 特点： * 通过select查询完的结果 ，是一个虚拟的表格，不是真实存在 * 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 起别名* SELECT last_name AS 姓 FROM info; * SELECT last_name 姓 FROM info; 便于理解 查询字段第一名情况，使用别名可以区分开来 字符串连接SELECT CONCAT(last_name,first_name) AS 姓名 FROM info; +会把字符串转数字，不成功则为0，然后相加 若其中一方为NULL，则结果为NULL，可以使用IFNULL(name,default)，若name为NULL，则返回default 去重SELECT DISTINCT last_name 姓 FROM info; 条件查询条件查询：根据条件过滤原始表的数据，查询到想要的数据 语法： select 要查询的字段|表达式（计算+-*/%等）|常量值|函数（输出函数返回值） from 表 where 条件 ; 关键字名作字段使用``包装 分类： 一、条件表达式 示例：salary&gt;10000 条件运算符： &gt; &lt; &gt;= &lt;= = != &lt;&gt; **&lt;=&gt; 安全等于，可以用在NULL，上面的不行** 二、逻辑表达式 示例：salary&gt;10000 &amp;&amp; salary&lt;20000 逻辑运算符： and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false or(||)：两个条件只要有一个成立，结果为true，否则为false not(!)：如果条件成立，则not后为false，否则为true 三、模糊查询 like： where last_name like &apos;a%&apos; ESCAPE &apos;#&apos;; 字符形要加引号，%表示任意多个字符，_表示一个，默认是\转义，可以使用ESCAPE指定 between and： where a BETWEEN 20 AND 30; 包含两端，不可交换位置 in： where last_name IN(&apos;&apos;,&apos;&apos;,...); 不支持通配符 is null： where lastt_name IS [NOT] NULL; 排序查询语法： select 要查询的东西 from 表 where 条件 order by 排序的字段|表达式|函数|别名 【asc|desc】，... * 可以用,进行多个条件复合 分组查询语法： select 分组函数,查询的字段 from 表 【where】 group by 查询的字段 【order by】 【having】 特点： 1、可以按单个字段分组 2、和分组函数一同查询的字段最好是分组后的字段 3、分组筛选针对的表位置关键字 分组前筛选： 原始表 group by的前面 where 分组后筛选： 分组后的结果集 group by的后面 having 4、可以按多个字段分组，字段之间用逗号隔开 5、可以支持排序 6、having后可以支持别名 多表连接查询笛卡尔乘积：如果连接条件省略或无效则会出现 解决办法：添加上连接条件 一、传统模式下的连接 ：等值连接、非等值连接 1.等值连接的结果 = 多个表的交集 2.n表连接，至少需要n-1个连接条件 3.多个表不分主次，没有顺序要求 4.一般为表起别名，提高阅读性和性能，用了原表名就不能用了 二、sql99语法：通过join关键字实现连接 含义：1999年推出的sql语法 支持： 等值连接、非等值连接 （内连接） 外连接 左外 右外 全外 交叉连接 语法： select 字段，... from 表1 【inner|left outer|right outer|full outer|cross】 join 表2 别名 on 连接条件 【inner|left outer|right outer|full outer|cross】 join 表3 别名 on 连接条件 【where 筛选条件】 【group by 分组字段】 【having 分组后的筛选条件】 【order by 排序的字段或表达式】 outer和inner可以省略 1. 内连接，找不到对应的，就不显示 2. 外连接，查询结果为主表中的所有记录。用于一个表有，另外一个表找不到对应的情况。主表中每行都显示出来，若找不到匹配的值用null。等于内连接结果+没匹配到的行和null 3. 左右连接，左连接表示左边是主表，右连接表示右边是主表 4. 全外连接，等于内连结果+主表没匹配到的行和null+从表没匹配到的行和null 5. 交叉连接，等于笛卡尔乘积 三、自连接 同一个表有多个意义，如员工表也可以表示为领导表，但是又不能用一个表就完成，需要自连接自己 案例：查询员工名和直接上级的名称sql99 SELECT e.last_name,m.last_name FROM employees e JOIN employees m ON e.`manager_id`=m.`employee_id`; sql92 SELECT e.last_name,m.last_name FROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`; 子查询含义： 一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询 在外面的查询语句，称为主查询或外查询 特点： 1、子查询都放在小括号内，一般放在条件的右侧 2、子查询优先于主查询执行，主查询使用了子查询的执行结果 非法使用子查询的情况： a、子查询的结果与对应的操作符不符 b、子查询的结果为空 3、子查询可以放在 select后面 仅标量子查询 from后面 支持表子查询，需要给查询一个表名 where、having后面 标量、列、行子查询 exists后面 表子查询，结果是1或0，表示子查询是否有结果集 4、子查询根据结果集不同分为以下几类： * 标量子查询 结果集只有一行一列 一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= * 列子查询 结果集只有一列多行 一般搭配多行操作符使用：any、all、in、not in in： 属于子查询结果中的任意一个就行 any和all往往可以用其他查询代替 * 行子查询 结果集有一行多列，或多行多列（较少） 例 where (name,age) = ( selece name,age from info; ) * 表子查询 结果集一般为多行多列 分页查询应用场景： 实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句 语法： select 字段|表达式,... from 表 【where 条件】 【group by 分组字段】 【having 条件】 【order by 排序的字段】 limit 【offset】size; 特点： 1.offset从0开始 2.limit子句放在查询语句的最后 3.公式：select * from 表 limit （page-1）*sizePerPage,sizePerPage 假如: 每页显示条目数sizePerPage 要显示的页数 page 联合查询引入： union 联合、合并。将多条查询语句的结果合并成一个结果。要查询的结果来自多个表，且多个表没有直接的关联，且查询的信息类似。 语法： select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】 select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】 select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】 ..... select 字段|常量|表达式|函数 【from 表】 【where 条件】 特点： 1、多条查询语句的查询的列数必须是一致的 2、多条查询语句的查询的列的类型和顺序几乎相同 3、union代表去重，union all代表不去重]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL TCL事务控制语言]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql-tcl%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[数据库事务含义通过一组逻辑操作单元（一组sql语句），将数据从一种状态切换到另外一种状态。事务中操作的数据，需要根据隔离级别进行体现 特点（ACID） 原子性：要么都执行，要么都回滚。事务不可分割的工作单元。 一致性：保证数据的状态操作前和操作后保持一致 隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰 持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改 相关步骤： 1、开启事务 2、编写事务的一组逻辑操作单元（多条sql语句） 3、提交事务或回滚事务 事务的分类：隐式事务，没有明显的开启和结束事务的标志 比如insert、update、delete语句本身就是一个事务 显式事务，具有明显的开启和结束事务的标志 1、开启事务 取消自动提交事务的功能 set autocommit=0; 2、编写事务的一组逻辑操作单元（多条sql语句） select insert update delete //DDL语言不具有事务性 3、提交事务或回滚事务 使用到的关键字set autocommit=0; start transaction; commit; rollback; savepoint 断点 commit to 断点 rollback to 断点 事务的隔离级别:事务并发问题如何发生？ 当多个事务同时操作同一个数据库的相同数据时 事务的并发问题有哪些？ 脏读：一个事务读取到了另外一个事务未提交的数据 不可重复读：同一个事务中，多次读取到的数据不一致 幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据，一般是别的事务插入数据提交后 如何避免事务的并发问题？ 通过设置事务的隔离级别 1、READ UNCOMMITTED 允许事务读取未被其它事物提交的变更 2、READ COMMITTED 可以避免脏读 3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读 4、SERIALIZABLE 可以避免脏读、不可重复读和幻读 Oracle只支持2和4，默认是2，而Myql都支持，默认是3 设置隔离级别： set session|global transaction isolation level 隔离级别名; 查看隔离级别： select @@tx_isolation;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL DML数据操作语言]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql-dml%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[DML语言插入语法一：支持多列、子查询 insert into 表名(字段名，…) values(值1，…);语法二： inset into 表名 set 列名=值,列名=值…特点： 1、字段类型和值类型一致或兼容，而且一一对应 2、可以为空的字段，可以不用插入值，或用null填充 3、不可以为空的字段，必须插入值 4、字段个数和值的个数必须一致 5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改修改单表语法： update 表名 set 字段=新值,字段=新值 【where 条件】 修改多表语法： update 表1 别名1,表2 别名2 set 字段=新值，字段=新值 where 连接条件 and 筛选条件 删除方式1：delete语句 单表的删除： ★ delete from 表名 【where 筛选条件】 多表的删除： delete 别名1，别名2 from 表1 别名1，表2 别名2 where 连接条件 and 筛选条件; 方式2：truncate语句 清空数据 truncate table 表名 两种方式的区别【面试题】 #1.truncate不能加where条件，而delete可以加where条件 #2.truncate的效率高一丢丢 #3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始 #delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始 #4.truncate删除不能回滚，delete删除可以回滚]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL DDL数据定义语言]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql-ddl%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[DDL语句库和表的管理库的管理： 一、创建库 create database 库名 二、删除库 drop database 库名 表的管理： #1.创建表 CREATE TABLE IF NOT EXISTS stuinfo( stuId INT, stuName VARCHAR(20), gender CHAR, bornDate DATETIME ); DESC studentinfo;查看表结构 SHOW INDEX FORM info;查看表索引、主键、外键、唯一 #2.修改表 alter 语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型 约束】; #①修改字段名 ALTER TABLE studentinfo CHANGE [COLUMN] 原名 新名 类型; #②修改表名 ALTER TABLE stuinfo RENAME [TO] studentinfo; #③修改字段类型和列级约束 ALTER TABLE studentinfo MODIFY COLUMN borndate DATE; #④添加字段 ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first; #⑤删除字段 ALTER TABLE studentinfo DROP COLUMN email; #3.删除表 DROP TABLE [IF EXISTS] studentinfo; #4.表复制 仅复制表结构 CREATE TABLE newTable LIKE oldTable; 复制结构+数据 CREATE TABLE newTAble SELECT * FORM oldTable WHERE ..;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QtGlobal]]></title>
    <url>%2FQT%2Fqtglobal%2F</url>
    <content type="text"><![CDATA[QtGlobal Header: #include 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274#ifndef QGLOBAL_H#define QGLOBAL_H#ifdef __cplusplus# include &lt;type_traits&gt;# include &lt;cstddef&gt;# include &lt;utility&gt;#endif#ifndef __ASSEMBLER__# include &lt;assert.h&gt;# include &lt;stddef.h&gt;#endif/* QT_VERSION is (major &lt;&lt; 16) + (minor &lt;&lt; 8) + patch.*/#define QT_VERSION QT_VERSION_CHECK(QT_VERSION_MAJOR, QT_VERSION_MINOR, QT_VERSION_PATCH)/* can be used like #if (QT_VERSION &gt;= QT_VERSION_CHECK(4, 4, 0))*/#define QT_VERSION_CHECK(major, minor, patch) ((major&lt;&lt;16)|(minor&lt;&lt;8)|(patch))#ifdef QT_BOOTSTRAPPED#include &lt;QtCore/qconfig-bootstrapped.h&gt;#else#include &lt;QtCore/qconfig.h&gt;#include &lt;QtCore/qtcore-config.h&gt;#endif// The QT_SUPPORTS macro is deprecated. Don't use it in new code.// Instead, use QT_CONFIG(feature)// ### Qt6: remove macro#ifdef _MSC_VER# define QT_SUPPORTS(FEATURE) (!defined QT_NO_##FEATURE)#else# define QT_SUPPORTS(FEATURE) (!defined(QT_NO_##FEATURE))#endif/* The QT_CONFIG macro implements a safe compile time check for features of Qt. Features can be in three states: 0 or undefined: This will lead to a compile error when testing for it -1: The feature is not available 1: The feature is available*/#define QT_CONFIG(feature) (1/QT_FEATURE_##feature == 1)#define QT_REQUIRE_CONFIG(feature) Q_STATIC_ASSERT_X(QT_FEATURE_##feature == 1, "Required feature " #feature " for file " __FILE__ " not available.")#if QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0)# define QT_NO_UNSHARABLE_CONTAINERS# define QT6_VIRTUAL virtual# define QT6_NOT_VIRTUAL#else# define QT6_VIRTUAL# define QT6_NOT_VIRTUAL virtual#endif/* These two macros makes it possible to turn the builtin line expander into a * string literal. */#define QT_STRINGIFY2(x) #x#define QT_STRINGIFY(x) QT_STRINGIFY2(x)#include &lt;QtCore/qsystemdetection.h&gt;#include &lt;QtCore/qprocessordetection.h&gt;#include &lt;QtCore/qcompilerdetection.h&gt;#if defined (__ELF__)# define Q_OF_ELF#endif#if defined (__MACH__) &amp;&amp; defined (__APPLE__)# define Q_OF_MACH_O#endif/* Avoid "unused parameter" warnings*/#define Q_UNUSED(x) (void)x;#if defined(__cplusplus) &amp;&amp; defined(Q_COMPILER_STATIC_ASSERT)# define Q_STATIC_ASSERT(Condition) static_assert(bool(Condition), #Condition)# define Q_STATIC_ASSERT_X(Condition, Message) static_assert(bool(Condition), Message)#elif defined(Q_COMPILER_STATIC_ASSERT)// C11 mode - using the _S version in case &lt;assert.h&gt; doesn't do the right thing# define Q_STATIC_ASSERT(Condition) _Static_assert(!!(Condition), #Condition)# define Q_STATIC_ASSERT_X(Condition, Message) _Static_assert(!!(Condition), Message)#else// C89 &amp; C99 version# define Q_STATIC_ASSERT_PRIVATE_JOIN(A, B) Q_STATIC_ASSERT_PRIVATE_JOIN_IMPL(A, B)# define Q_STATIC_ASSERT_PRIVATE_JOIN_IMPL(A, B) A ## B# ifdef __COUNTER__# define Q_STATIC_ASSERT(Condition) \ typedef char Q_STATIC_ASSERT_PRIVATE_JOIN(q_static_assert_result, __COUNTER__) [(Condition) ? 1 : -1];# else# define Q_STATIC_ASSERT(Condition) \ typedef char Q_STATIC_ASSERT_PRIVATE_JOIN(q_static_assert_result, __LINE__) [(Condition) ? 1 : -1];# endif /* __COUNTER__ */# define Q_STATIC_ASSERT_X(Condition, Message) Q_STATIC_ASSERT(Condition)#endif#ifdef __cplusplus#include &lt;algorithm&gt;#if !defined(QT_NAMESPACE) || defined(Q_MOC_RUN) /* user namespace */# define QT_PREPEND_NAMESPACE(name) ::name# define QT_USE_NAMESPACE# define QT_BEGIN_NAMESPACE# define QT_END_NAMESPACE# define QT_BEGIN_INCLUDE_NAMESPACE# define QT_END_INCLUDE_NAMESPACE#ifndef QT_BEGIN_MOC_NAMESPACE# define QT_BEGIN_MOC_NAMESPACE#endif#ifndef QT_END_MOC_NAMESPACE# define QT_END_MOC_NAMESPACE#endif# define QT_FORWARD_DECLARE_CLASS(name) class name;# define QT_FORWARD_DECLARE_STRUCT(name) struct name;# define QT_MANGLE_NAMESPACE(name) name#else /* user namespace */# define QT_PREPEND_NAMESPACE(name) ::QT_NAMESPACE::name# define QT_USE_NAMESPACE using namespace ::QT_NAMESPACE;# define QT_BEGIN_NAMESPACE namespace QT_NAMESPACE &#123;# define QT_END_NAMESPACE &#125;# define QT_BEGIN_INCLUDE_NAMESPACE &#125;# define QT_END_INCLUDE_NAMESPACE namespace QT_NAMESPACE &#123;#ifndef QT_BEGIN_MOC_NAMESPACE# define QT_BEGIN_MOC_NAMESPACE QT_USE_NAMESPACE#endif#ifndef QT_END_MOC_NAMESPACE# define QT_END_MOC_NAMESPACE#endif# define QT_FORWARD_DECLARE_CLASS(name) \ QT_BEGIN_NAMESPACE class name; QT_END_NAMESPACE \ using QT_PREPEND_NAMESPACE(name);# define QT_FORWARD_DECLARE_STRUCT(name) \ QT_BEGIN_NAMESPACE struct name; QT_END_NAMESPACE \ using QT_PREPEND_NAMESPACE(name);# define QT_MANGLE_NAMESPACE0(x) x# define QT_MANGLE_NAMESPACE1(a, b) a##_##b# define QT_MANGLE_NAMESPACE2(a, b) QT_MANGLE_NAMESPACE1(a,b)# define QT_MANGLE_NAMESPACE(name) QT_MANGLE_NAMESPACE2( \ QT_MANGLE_NAMESPACE0(name), QT_MANGLE_NAMESPACE0(QT_NAMESPACE))namespace QT_NAMESPACE &#123;&#125;# ifndef QT_BOOTSTRAPPED# ifndef QT_NO_USING_NAMESPACE /* This expands to a "using QT_NAMESPACE" also in _header files_. It is the only way the feature can be used without too much pain, but if people _really_ do not want it they can add DEFINES += QT_NO_USING_NAMESPACE to their .pro files. */ QT_USE_NAMESPACE# endif# endif#endif /* user namespace */#else /* __cplusplus */# define QT_BEGIN_NAMESPACE# define QT_END_NAMESPACE# define QT_USE_NAMESPACE# define QT_BEGIN_INCLUDE_NAMESPACE# define QT_END_INCLUDE_NAMESPACE#endif /* __cplusplus */// ### Qt6: remove me.#define QT_BEGIN_HEADER#define QT_END_HEADER#if defined(Q_OS_DARWIN) &amp;&amp; !defined(QT_LARGEFILE_SUPPORT)# define QT_LARGEFILE_SUPPORT 64#endif#ifndef __ASSEMBLER__QT_BEGIN_NAMESPACE/* Size-dependent types (architechture-dependent byte order) Make sure to update QMetaType when changing these typedefs*/typedef signed char qint8; /* 8 bit signed */typedef unsigned char quint8; /* 8 bit unsigned */typedef short qint16; /* 16 bit signed */typedef unsigned short quint16; /* 16 bit unsigned */typedef int qint32; /* 32 bit signed */typedef unsigned int quint32; /* 32 bit unsigned */#if defined(Q_OS_WIN) &amp;&amp; !defined(Q_CC_GNU)# define Q_INT64_C(c) c ## i64 /* signed 64 bit constant */# define Q_UINT64_C(c) c ## ui64 /* unsigned 64 bit constant */typedef __int64 qint64; /* 64 bit signed */typedef unsigned __int64 quint64; /* 64 bit unsigned */#else#ifdef __cplusplus# define Q_INT64_C(c) static_cast&lt;long long&gt;(c ## LL) /* signed 64 bit constant */# define Q_UINT64_C(c) static_cast&lt;unsigned long long&gt;(c ## ULL) /* unsigned 64 bit constant */#else# define Q_INT64_C(c) ((long long)(c ## LL)) /* signed 64 bit constant */# define Q_UINT64_C(c) ((unsigned long long)(c ## ULL)) /* unsigned 64 bit constant */#endiftypedef long long qint64; /* 64 bit signed */typedef unsigned long long quint64; /* 64 bit unsigned */#endiftypedef qint64 qlonglong;typedef quint64 qulonglong;#ifndef __cplusplus// In C++ mode, we define below using QIntegerForSize templateQ_STATIC_ASSERT_X(sizeof(ptrdiff_t) == sizeof(size_t), "Weird ptrdiff_t and size_t definitions");typedef ptrdiff_t qptrdiff;typedef ptrdiff_t qsizetype;typedef ptrdiff_t qintptr;typedef size_t quintptr;#endif/* Useful type definitions for Qt*/QT_BEGIN_INCLUDE_NAMESPACEtypedef unsigned char uchar;typedef unsigned short ushort;typedef unsigned int uint;typedef unsigned long ulong;QT_END_INCLUDE_NAMESPACE#if defined(QT_COORD_TYPE)typedef QT_COORD_TYPE qreal;#elsetypedef double qreal;#endif#if defined(QT_NO_DEPRECATED)# undef QT_DEPRECATED# undef QT_DEPRECATED_X# undef QT_DEPRECATED_VARIABLE# undef QT_DEPRECATED_CONSTRUCTOR#elif !defined(QT_NO_DEPRECATED_WARNINGS)# undef QT_DEPRECATED# define QT_DEPRECATED Q_DECL_DEPRECATED# undef QT_DEPRECATED_X# define QT_DEPRECATED_X(text) Q_DECL_DEPRECATED_X(text)# undef QT_DEPRECATED_VARIABLE# define QT_DEPRECATED_VARIABLE Q_DECL_VARIABLE_DEPRECATED# undef QT_DEPRECATED_CONSTRUCTOR# define QT_DEPRECATED_CONSTRUCTOR explicit Q_DECL_CONSTRUCTOR_DEPRECATED#else# undef QT_DEPRECATED# define QT_DEPRECATED# undef QT_DEPRECATED_X# define QT_DEPRECATED_X(text)# undef QT_DEPRECATED_VARIABLE# define QT_DEPRECATED_VARIABLE# undef QT_DEPRECATED_CONSTRUCTOR# define QT_DEPRECATED_CONSTRUCTOR# undef Q_DECL_ENUMERATOR_DEPRECATED# define Q_DECL_ENUMERATOR_DEPRECATED#endif#ifndef QT_DEPRECATED_WARNINGS_SINCE# ifdef QT_DISABLE_DEPRECATED_BEFORE# define QT_DEPRECATED_WARNINGS_SINCE QT_DISABLE_DEPRECATED_BEFORE# else# define QT_DEPRECATED_WARNINGS_SINCE QT_VERSION# endif#endif#ifndef QT_DISABLE_DEPRECATED_BEFORE#define QT_DISABLE_DEPRECATED_BEFORE QT_VERSION_CHECK(5, 0, 0)#endif/* QT_DEPRECATED_SINCE(major, minor) evaluates as true if the Qt version is greater than the deprecation point specified. Use it to specify from which version of Qt a function or class has been deprecated Example: #if QT_DEPRECATED_SINCE(5,1) QT_DEPRECATED void deprecatedFunction(); //function deprecated since Qt 5.1 #endif*/#ifdef QT_DEPRECATED#define QT_DEPRECATED_SINCE(major, minor) (QT_VERSION_CHECK(major, minor, 0) &gt; QT_DISABLE_DEPRECATED_BEFORE)#else#define QT_DEPRECATED_SINCE(major, minor) 0#endif/* QT_DEPRECATED_VERSION(major, minor) and QT_DEPRECATED_VERSION_X(major, minor, text) outputs a deprecation warning if QT_DEPRECATED_WARNINGS_SINCE is equal or greater than the version specified as major, minor. This makes it possible to deprecate a function without annoying a user who needs to stick at a specified minimum version and therefore can't use the new function.*/#if QT_DEPRECATED_WARNINGS_SINCE &gt;= QT_VERSION_CHECK(5, 12, 0)# define QT_DEPRECATED_VERSION_X_5_12(text) QT_DEPRECATED_X(text)# define QT_DEPRECATED_VERSION_5_12 QT_DEPRECATED#else# define QT_DEPRECATED_VERSION_X_5_12(text)# define QT_DEPRECATED_VERSION_5_12#endif#if QT_DEPRECATED_WARNINGS_SINCE &gt;= QT_VERSION_CHECK(5, 13, 0)# define QT_DEPRECATED_VERSION_X_5_13(text) QT_DEPRECATED_X(text)# define QT_DEPRECATED_VERSION_5_13 QT_DEPRECATED#else# define QT_DEPRECATED_VERSION_X_5_13(text)# define QT_DEPRECATED_VERSION_5_13#endif#if QT_DEPRECATED_WARNINGS_SINCE &gt;= QT_VERSION_CHECK(5, 14, 0)# define QT_DEPRECATED_VERSION_X_5_14(text) QT_DEPRECATED_X(text)# define QT_DEPRECATED_VERSION_5_14 QT_DEPRECATED#else# define QT_DEPRECATED_VERSION_X_5_14(text)# define QT_DEPRECATED_VERSION_5_14#endif#if QT_DEPRECATED_WARNINGS_SINCE &gt;= QT_VERSION_CHECK(5, 15, 0)# define QT_DEPRECATED_VERSION_X_5_15(text) QT_DEPRECATED_X(text)# define QT_DEPRECATED_VERSION_5_15 QT_DEPRECATED#else# define QT_DEPRECATED_VERSION_X_5_15(text)# define QT_DEPRECATED_VERSION_5_15#endif#define QT_DEPRECATED_VERSION_X_5(minor, text) QT_DEPRECATED_VERSION_X_5_##minor(text)#define QT_DEPRECATED_VERSION_X(major, minor, text) QT_DEPRECATED_VERSION_X_##major(minor, text)#define QT_DEPRECATED_VERSION_5(minor) QT_DEPRECATED_VERSION_5_##minor#define QT_DEPRECATED_VERSION(major, minor) QT_DEPRECATED_VERSION_##major(minor)#ifdef __cplusplus// A tag to help mark stuff deprecated (cf. QStringViewLiteral)namespace QtPrivate &#123;enum class Deprecated_t &#123;&#125;;constexpr Q_DECL_UNUSED Deprecated_t Deprecated = &#123;&#125;;&#125;#endif/* The Qt modules' export macros. The options are: - defined(QT_STATIC): Qt was built or is being built in static mode - defined(QT_SHARED): Qt was built or is being built in shared/dynamic mode If neither was defined, then QT_SHARED is implied. If Qt was compiled in static mode, QT_STATIC is defined in qconfig.h. In shared mode, QT_STATIC is implied for the bootstrapped tools.*/#ifdef QT_BOOTSTRAPPED# ifdef QT_SHARED# error "QT_SHARED and QT_BOOTSTRAPPED together don't make sense. Please fix the build"# elif !defined(QT_STATIC)# define QT_STATIC# endif#endif#if defined(QT_SHARED) || !defined(QT_STATIC)# ifdef QT_STATIC# error "Both QT_SHARED and QT_STATIC defined, please make up your mind"# endif# ifndef QT_SHARED# define QT_SHARED# endif# if defined(QT_BUILD_CORE_LIB)# define Q_CORE_EXPORT Q_DECL_EXPORT# else# define Q_CORE_EXPORT Q_DECL_IMPORT# endif#else# define Q_CORE_EXPORT#endif/* Some classes do not permit copies to be made of an object. These classes contains a private copy constructor and assignment operator to disable copying (the compiler gives an error message).*/#define Q_DISABLE_COPY(Class) \ Class(const Class &amp;) = delete;\ Class &amp;operator=(const Class &amp;) = delete;#define Q_DISABLE_MOVE(Class) \ Class(Class &amp;&amp;) = delete; \ Class &amp;operator=(Class &amp;&amp;) = delete;#define Q_DISABLE_COPY_MOVE(Class) \ Q_DISABLE_COPY(Class) \ Q_DISABLE_MOVE(Class)/* No, this is not an evil backdoor. QT_BUILD_INTERNAL just exports more symbols for Qt's internal unit tests. If you want slower loading times and more symbols that can vanish from version to version, feel free to define QT_BUILD_INTERNAL.*/#if defined(QT_BUILD_INTERNAL) &amp;&amp; defined(QT_BUILDING_QT) &amp;&amp; defined(QT_SHARED)# define Q_AUTOTEST_EXPORT Q_DECL_EXPORT#elif defined(QT_BUILD_INTERNAL) &amp;&amp; defined(QT_SHARED)# define Q_AUTOTEST_EXPORT Q_DECL_IMPORT#else# define Q_AUTOTEST_EXPORT#endif#define Q_INIT_RESOURCE(name) \ do &#123; extern int QT_MANGLE_NAMESPACE(qInitResources_ ## name) (); \ QT_MANGLE_NAMESPACE(qInitResources_ ## name) (); &#125; while (false)#define Q_CLEANUP_RESOURCE(name) \ do &#123; extern int QT_MANGLE_NAMESPACE(qCleanupResources_ ## name) (); \ QT_MANGLE_NAMESPACE(qCleanupResources_ ## name) (); &#125; while (false)/* * If we're compiling C++ code: * - and this is a non-namespace build, declare qVersion as extern "C" * - and this is a namespace build, declare it as a regular function * (we're already inside QT_BEGIN_NAMESPACE / QT_END_NAMESPACE) * If we're compiling C code, simply declare the function. If Qt was compiled * in a namespace, qVersion isn't callable anyway. */#if !defined(QT_NAMESPACE) &amp;&amp; defined(__cplusplus) &amp;&amp; !defined(Q_QDOC)extern "C"#endifQ_CORE_EXPORT Q_DECL_CONST_FUNCTION const char *qVersion(void) Q_DECL_NOEXCEPT;#if defined(__cplusplus)#ifndef Q_CONSTRUCTOR_FUNCTION# define Q_CONSTRUCTOR_FUNCTION0(AFUNC) \ namespace &#123; \ static const struct AFUNC ## _ctor_class_ &#123; \ inline AFUNC ## _ctor_class_() &#123; AFUNC(); &#125; \ &#125; AFUNC ## _ctor_instance_; \ &#125;# define Q_CONSTRUCTOR_FUNCTION(AFUNC) Q_CONSTRUCTOR_FUNCTION0(AFUNC)#endif#ifndef Q_DESTRUCTOR_FUNCTION# define Q_DESTRUCTOR_FUNCTION0(AFUNC) \ namespace &#123; \ static const struct AFUNC ## _dtor_class_ &#123; \ inline AFUNC ## _dtor_class_() &#123; &#125; \ inline ~ AFUNC ## _dtor_class_() &#123; AFUNC(); &#125; \ &#125; AFUNC ## _dtor_instance_; \ &#125;# define Q_DESTRUCTOR_FUNCTION(AFUNC) Q_DESTRUCTOR_FUNCTION0(AFUNC)#endifnamespace QtPrivate &#123; template &lt;class T&gt; struct AlignOfHelper &#123; char c; T type; AlignOfHelper(); ~AlignOfHelper(); &#125;; template &lt;class T&gt; struct AlignOf_Default &#123; enum &#123; Value = sizeof(AlignOfHelper&lt;T&gt;) - sizeof(T) &#125;; &#125;; template &lt;class T&gt; struct AlignOf : AlignOf_Default&lt;T&gt; &#123; &#125;; template &lt;class T&gt; struct AlignOf&lt;T &amp;&gt; : AlignOf&lt;T&gt; &#123;&#125;; template &lt;class T&gt; struct AlignOf&lt;T &amp;&amp;&gt; : AlignOf&lt;T&gt; &#123;&#125;; template &lt;size_t N, class T&gt; struct AlignOf&lt;T[N]&gt; : AlignOf&lt;T&gt; &#123;&#125;;#if defined(Q_PROCESSOR_X86_32) &amp;&amp; !defined(Q_OS_WIN) template &lt;class T&gt; struct AlignOf_WorkaroundForI386Abi &#123; enum &#123; Value = sizeof(T) &#125;; &#125;; // x86 ABI weirdness // Alignment of naked type is 8, but inside struct has alignment 4. template &lt;&gt; struct AlignOf&lt;double&gt; : AlignOf_WorkaroundForI386Abi&lt;double&gt; &#123;&#125;; template &lt;&gt; struct AlignOf&lt;qint64&gt; : AlignOf_WorkaroundForI386Abi&lt;qint64&gt; &#123;&#125;; template &lt;&gt; struct AlignOf&lt;quint64&gt; : AlignOf_WorkaroundForI386Abi&lt;quint64&gt; &#123;&#125;;#ifdef Q_CC_CLANG // GCC and Clang seem to disagree wrt to alignment of arrays template &lt;size_t N&gt; struct AlignOf&lt;double[N]&gt; : AlignOf_Default&lt;double&gt; &#123;&#125;; template &lt;size_t N&gt; struct AlignOf&lt;qint64[N]&gt; : AlignOf_Default&lt;qint64&gt; &#123;&#125;; template &lt;size_t N&gt; struct AlignOf&lt;quint64[N]&gt; : AlignOf_Default&lt;quint64&gt; &#123;&#125;;#endif#endif&#125; // namespace QtPrivate#define QT_EMULATED_ALIGNOF(T) \ (size_t(QT_PREPEND_NAMESPACE(QtPrivate)::AlignOf&lt;T&gt;::Value))#ifndef Q_ALIGNOF#define Q_ALIGNOF(T) QT_EMULATED_ALIGNOF(T)#endif/* quintptr and qptrdiff is guaranteed to be the same size as a pointer, i.e. sizeof(void *) == sizeof(quintptr) &amp;&amp; sizeof(void *) == sizeof(qptrdiff) size_t and qsizetype are not guaranteed to be the same size as a pointer, but they usually are.*/template &lt;int&gt; struct QIntegerForSize;template &lt;&gt; struct QIntegerForSize&lt;1&gt; &#123; typedef quint8 Unsigned; typedef qint8 Signed; &#125;;template &lt;&gt; struct QIntegerForSize&lt;2&gt; &#123; typedef quint16 Unsigned; typedef qint16 Signed; &#125;;template &lt;&gt; struct QIntegerForSize&lt;4&gt; &#123; typedef quint32 Unsigned; typedef qint32 Signed; &#125;;template &lt;&gt; struct QIntegerForSize&lt;8&gt; &#123; typedef quint64 Unsigned; typedef qint64 Signed; &#125;;#if defined(Q_CC_GNU) &amp;&amp; defined(__SIZEOF_INT128__)template &lt;&gt; struct QIntegerForSize&lt;16&gt; &#123; __extension__ typedef unsigned __int128 Unsigned; __extension__ typedef __int128 Signed; &#125;;#endiftemplate &lt;class T&gt; struct QIntegerForSizeof: QIntegerForSize&lt;sizeof(T)&gt; &#123; &#125;;typedef QIntegerForSize&lt;Q_PROCESSOR_WORDSIZE&gt;::Signed qregisterint;typedef QIntegerForSize&lt;Q_PROCESSOR_WORDSIZE&gt;::Unsigned qregisteruint;typedef QIntegerForSizeof&lt;void*&gt;::Unsigned quintptr;typedef QIntegerForSizeof&lt;void*&gt;::Signed qptrdiff;typedef qptrdiff qintptr;using qsizetype = QIntegerForSizeof&lt;std::size_t&gt;::Signed;/* moc compats (signals/slots) */#ifndef QT_MOC_COMPAT# define QT_MOC_COMPAT#else# undef QT_MOC_COMPAT# define QT_MOC_COMPAT#endif#ifdef QT_ASCII_CAST_WARNINGS# define QT_ASCII_CAST_WARN Q_DECL_DEPRECATED_X("Use fromUtf8, QStringLiteral, or QLatin1String")#else# define QT_ASCII_CAST_WARN#endif#ifdef Q_PROCESSOR_X86_32# if defined(Q_CC_GNU)# define QT_FASTCALL __attribute__((regparm(3)))# elif defined(Q_CC_MSVC)# define QT_FASTCALL __fastcall# else# define QT_FASTCALL# endif#else# define QT_FASTCALL#endif// enable gcc warnings for printf-style functions#if defined(Q_CC_GNU) &amp;&amp; !defined(__INSURE__)# if defined(Q_CC_MINGW) &amp;&amp; !defined(Q_CC_CLANG)# define Q_ATTRIBUTE_FORMAT_PRINTF(A, B) \ __attribute__((format(gnu_printf, (A), (B))))# else# define Q_ATTRIBUTE_FORMAT_PRINTF(A, B) \ __attribute__((format(printf, (A), (B))))# endif#else# define Q_ATTRIBUTE_FORMAT_PRINTF(A, B)#endif#ifdef Q_CC_MSVC# define Q_NEVER_INLINE __declspec(noinline)# define Q_ALWAYS_INLINE __forceinline#elif defined(Q_CC_GNU)# define Q_NEVER_INLINE __attribute__((noinline))# define Q_ALWAYS_INLINE inline __attribute__((always_inline))#else# define Q_NEVER_INLINE# define Q_ALWAYS_INLINE inline#endif#if defined(Q_CC_GNU) &amp;&amp; defined(Q_OS_WIN) &amp;&amp; !defined(QT_NO_DATA_RELOCATION)// ### Qt6: you can remove me# define QT_INIT_METAOBJECT __attribute__((init_priority(101)))#else# define QT_INIT_METAOBJECT#endif//defines the type for the WNDPROC on windows//the alignment needs to be forced for sse2 to not crash with mingw#if defined(Q_OS_WIN)# if defined(Q_CC_MINGW) &amp;&amp; !defined(Q_OS_WIN64)# define QT_ENSURE_STACK_ALIGNED_FOR_SSE __attribute__ ((force_align_arg_pointer))# else# define QT_ENSURE_STACK_ALIGNED_FOR_SSE# endif# define QT_WIN_CALLBACK CALLBACK QT_ENSURE_STACK_ALIGNED_FOR_SSE#endiftypedef int QNoImplicitBoolCast;/* Utility macros and inline functions*/template &lt;typename T&gt;Q_DECL_CONSTEXPR inline T qAbs(const T &amp;t) &#123; return t &gt;= 0 ? t : -t; &#125;Q_DECL_CONSTEXPR inline int qRound(double d)&#123; return d &gt;= 0.0 ? int(d + 0.5) : int(d - double(int(d-1)) + 0.5) + int(d-1); &#125;Q_DECL_CONSTEXPR inline int qRound(float d)&#123; return d &gt;= 0.0f ? int(d + 0.5f) : int(d - float(int(d-1)) + 0.5f) + int(d-1); &#125;Q_DECL_CONSTEXPR inline qint64 qRound64(double d)&#123; return d &gt;= 0.0 ? qint64(d + 0.5) : qint64(d - double(qint64(d-1)) + 0.5) + qint64(d-1); &#125;Q_DECL_CONSTEXPR inline qint64 qRound64(float d)&#123; return d &gt;= 0.0f ? qint64(d + 0.5f) : qint64(d - float(qint64(d-1)) + 0.5f) + qint64(d-1); &#125;template &lt;typename T&gt;constexpr inline const T &amp;qMin(const T &amp;a, const T &amp;b) &#123; return (a &lt; b) ? a : b; &#125;template &lt;typename T&gt;constexpr inline const T &amp;qMax(const T &amp;a, const T &amp;b) &#123; return (a &lt; b) ? b : a; &#125;template &lt;typename T&gt;constexpr inline const T &amp;qBound(const T &amp;min, const T &amp;val, const T &amp;max)&#123; return qMax(min, qMin(max, val)); &#125;#ifndef Q_FORWARD_DECLARE_OBJC_CLASS# ifdef __OBJC__# define Q_FORWARD_DECLARE_OBJC_CLASS(classname) @class classname# else# define Q_FORWARD_DECLARE_OBJC_CLASS(classname) typedef struct objc_object classname# endif#endif#ifndef Q_FORWARD_DECLARE_CF_TYPE# define Q_FORWARD_DECLARE_CF_TYPE(type) typedef const struct __ ## type * type ## Ref#endif#ifndef Q_FORWARD_DECLARE_MUTABLE_CF_TYPE# define Q_FORWARD_DECLARE_MUTABLE_CF_TYPE(type) typedef struct __ ## type * type ## Ref#endif#ifndef Q_FORWARD_DECLARE_CG_TYPE#define Q_FORWARD_DECLARE_CG_TYPE(type) typedef const struct type *type ## Ref;#endif#ifndef Q_FORWARD_DECLARE_MUTABLE_CG_TYPE#define Q_FORWARD_DECLARE_MUTABLE_CG_TYPE(type) typedef struct type *type ## Ref;#endif#ifdef Q_OS_DARWIN# define QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, ios, tvos, watchos) \ ((defined(__MAC_OS_X_VERSION_MAX_ALLOWED) &amp;&amp; macos != __MAC_NA &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= macos) || \ (defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; ios != __IPHONE_NA &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= ios) || \ (defined(__TV_OS_VERSION_MAX_ALLOWED) &amp;&amp; tvos != __TVOS_NA &amp;&amp; __TV_OS_VERSION_MAX_ALLOWED &gt;= tvos) || \ (defined(__WATCH_OS_VERSION_MAX_ALLOWED) &amp;&amp; watchos != __WATCHOS_NA &amp;&amp; __WATCH_OS_VERSION_MAX_ALLOWED &gt;= watchos))# define QT_DARWIN_DEPLOYMENT_TARGET_BELOW(macos, ios, tvos, watchos) \ ((defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; macos != __MAC_NA &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &lt; macos) || \ (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; ios != __IPHONE_NA &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &lt; ios) || \ (defined(__TV_OS_VERSION_MIN_REQUIRED) &amp;&amp; tvos != __TVOS_NA &amp;&amp; __TV_OS_VERSION_MIN_REQUIRED &lt; tvos) || \ (defined(__WATCH_OS_VERSION_MIN_REQUIRED) &amp;&amp; watchos != __WATCHOS_NA &amp;&amp; __WATCH_OS_VERSION_MIN_REQUIRED &lt; watchos))# define QT_MACOS_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, ios) \ QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, ios, __TVOS_NA, __WATCHOS_NA)# define QT_MACOS_PLATFORM_SDK_EQUAL_OR_ABOVE(macos) \ QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, __IPHONE_NA, __TVOS_NA, __WATCHOS_NA)# define QT_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(ios) \ QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(__MAC_NA, ios, __TVOS_NA, __WATCHOS_NA)# define QT_TVOS_PLATFORM_SDK_EQUAL_OR_ABOVE(tvos) \ QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(__MAC_NA, __IPHONE_NA, tvos, __WATCHOS_NA)# define QT_WATCHOS_PLATFORM_SDK_EQUAL_OR_ABOVE(watchos) \ QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(__MAC_NA, __IPHONE_NA, __TVOS_NA, watchos)# define QT_MACOS_IOS_DEPLOYMENT_TARGET_BELOW(macos, ios) \ QT_DARWIN_DEPLOYMENT_TARGET_BELOW(macos, ios, __TVOS_NA, __WATCHOS_NA)# define QT_MACOS_DEPLOYMENT_TARGET_BELOW(macos) \ QT_DARWIN_DEPLOYMENT_TARGET_BELOW(macos, __IPHONE_NA, __TVOS_NA, __WATCHOS_NA)# define QT_IOS_DEPLOYMENT_TARGET_BELOW(ios) \ QT_DARWIN_DEPLOYMENT_TARGET_BELOW(__MAC_NA, ios, __TVOS_NA, __WATCHOS_NA)# define QT_TVOS_DEPLOYMENT_TARGET_BELOW(tvos) \ QT_DARWIN_DEPLOYMENT_TARGET_BELOW(__MAC_NA, __IPHONE_NA, tvos, __WATCHOS_NA)# define QT_WATCHOS_DEPLOYMENT_TARGET_BELOW(watchos) \ QT_DARWIN_DEPLOYMENT_TARGET_BELOW(__MAC_NA, __IPHONE_NA, __TVOS_NA, watchos)// Compatibility synonyms, do not use# define QT_MAC_PLATFORM_SDK_EQUAL_OR_ABOVE(osx, ios) QT_MACOS_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(osx, ios)# define QT_MAC_DEPLOYMENT_TARGET_BELOW(osx, ios) QT_MACOS_IOS_DEPLOYMENT_TARGET_BELOW(osx, ios)# define QT_OSX_PLATFORM_SDK_EQUAL_OR_ABOVE(osx) QT_MACOS_PLATFORM_SDK_EQUAL_OR_ABOVE(osx)# define QT_OSX_DEPLOYMENT_TARGET_BELOW(osx) QT_MACOS_DEPLOYMENT_TARGET_BELOW(osx)// Implemented in qcore_mac_objc.mmclass Q_CORE_EXPORT QMacAutoReleasePool&#123;public: QMacAutoReleasePool(); ~QMacAutoReleasePool();private: Q_DISABLE_COPY(QMacAutoReleasePool) void *pool;&#125;;#else#define QT_DARWIN_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, ios, tvos, watchos) (0)#define QT_MACOS_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(macos, ios) (0)#define QT_MACOS_PLATFORM_SDK_EQUAL_OR_ABOVE(macos) (0)#define QT_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(ios) (0)#define QT_TVOS_PLATFORM_SDK_EQUAL_OR_ABOVE(tvos) (0)#define QT_WATCHOS_PLATFORM_SDK_EQUAL_OR_ABOVE(watchos) (0)#define QT_MAC_PLATFORM_SDK_EQUAL_OR_ABOVE(osx, ios) (0)#define QT_OSX_PLATFORM_SDK_EQUAL_OR_ABOVE(osx) (0)#endif // Q_OS_DARWIN/* Data stream functions are provided by many classes (defined in qdatastream.h)*/class QDataStream;inline void qt_noop(void) &#123;&#125;/* These wrap try/catch so we can switch off exceptions later. Beware - do not use more than one QT_CATCH per QT_TRY, and do not use the exception instance in the catch block. If you can't live with those constraints, don't use these macros. Use the QT_NO_EXCEPTIONS macro to protect your code instead.*/#if !defined(QT_NO_EXCEPTIONS)# if !defined(Q_MOC_RUN)# if (defined(Q_CC_CLANG) &amp;&amp; !defined(Q_CC_INTEL) &amp;&amp; !__has_feature(cxx_exceptions)) || \ (defined(Q_CC_GNU) &amp;&amp; !defined(__EXCEPTIONS))# define QT_NO_EXCEPTIONS# endif# elif defined(QT_BOOTSTRAPPED)# define QT_NO_EXCEPTIONS# endif#endif#ifdef QT_NO_EXCEPTIONS# define QT_TRY if (true)# define QT_CATCH(A) else# define QT_THROW(A) qt_noop()# define QT_RETHROW qt_noop()# define QT_TERMINATE_ON_EXCEPTION(expr) do &#123; expr; &#125; while (false)#else# define QT_TRY try# define QT_CATCH(A) catch (A)# define QT_THROW(A) throw A# define QT_RETHROW throwQ_NORETURN Q_DECL_COLD_FUNCTION Q_CORE_EXPORT void qTerminate() noexcept;# ifdef Q_COMPILER_NOEXCEPT# define QT_TERMINATE_ON_EXCEPTION(expr) do &#123; expr; &#125; while (false)# else# define QT_TERMINATE_ON_EXCEPTION(expr) do &#123; try &#123; expr; &#125; catch (...) &#123; qTerminate(); &#125; &#125; while (false)# endif#endifQ_CORE_EXPORT Q_DECL_CONST_FUNCTION bool qSharedBuild() noexcept;#ifndef Q_OUTOFLINE_TEMPLATE# define Q_OUTOFLINE_TEMPLATE#endif#ifndef Q_INLINE_TEMPLATE# define Q_INLINE_TEMPLATE inline#endif/* Debugging and error handling*/#if !defined(QT_NO_DEBUG) &amp;&amp; !defined(QT_DEBUG)# define QT_DEBUG#endif// QtPrivate::asString defined in qstring.h#ifndef qPrintable# define qPrintable(string) QtPrivate::asString(string).toLocal8Bit().constData()#endif#ifndef qUtf8Printable# define qUtf8Printable(string) QtPrivate::asString(string).toUtf8().constData()#endif/* Wrap QString::utf16() with enough casts to allow passing it to QString::asprintf("%ls") without warnings.*/#ifndef qUtf16Printable# define qUtf16Printable(string) \ static_cast&lt;const wchar_t*&gt;(static_cast&lt;const void*&gt;(QString(string).utf16()))#endifclass QString;Q_DECL_COLD_FUNCTIONQ_CORE_EXPORT QString qt_error_string(int errorCode = -1);#ifndef Q_CC_MSVCQ_NORETURN#endifQ_DECL_COLD_FUNCTIONQ_CORE_EXPORT void qt_assert(const char *assertion, const char *file, int line) noexcept;#if !defined(Q_ASSERT)# if defined(QT_NO_DEBUG) &amp;&amp; !defined(QT_FORCE_ASSERTS)# define Q_ASSERT(cond) static_cast&lt;void&gt;(false &amp;&amp; (cond))# else# define Q_ASSERT(cond) ((cond) ? static_cast&lt;void&gt;(0) : qt_assert(#cond, __FILE__, __LINE__))# endif#endif#ifndef Q_CC_MSVCQ_NORETURN#endifQ_DECL_COLD_FUNCTIONQ_CORE_EXPORT void qt_assert_x(const char *where, const char *what, const char *file, int line) noexcept;#if !defined(Q_ASSERT_X)# if defined(QT_NO_DEBUG) &amp;&amp; !defined(QT_FORCE_ASSERTS)# define Q_ASSERT_X(cond, where, what) static_cast&lt;void&gt;(false &amp;&amp; (cond))# else# define Q_ASSERT_X(cond, where, what) ((cond) ? static_cast&lt;void&gt;(0) : qt_assert_x(where, what, __FILE__, __LINE__))# endif#endifQ_NORETURN Q_CORE_EXPORT void qt_check_pointer(const char *, int) noexcept;Q_DECL_COLD_FUNCTIONQ_CORE_EXPORT void qBadAlloc();#ifdef QT_NO_EXCEPTIONS# if defined(QT_NO_DEBUG) &amp;&amp; !defined(QT_FORCE_ASSERTS)# define Q_CHECK_PTR(p) qt_noop()# else# define Q_CHECK_PTR(p) do &#123;if (!(p)) qt_check_pointer(__FILE__,__LINE__);&#125; while (false)# endif#else# define Q_CHECK_PTR(p) do &#123; if (!(p)) qBadAlloc(); &#125; while (false)#endiftemplate &lt;typename T&gt;inline T *q_check_ptr(T *p) &#123; Q_CHECK_PTR(p); return p; &#125;typedef void (*QFunctionPointer)();#if !defined(Q_UNIMPLEMENTED)# define Q_UNIMPLEMENTED() qWarning("Unimplemented code.")#endifQ_REQUIRED_RESULT Q_DECL_CONSTEXPR static inline Q_DECL_UNUSED bool qFuzzyCompare(double p1, double p2)&#123; return (qAbs(p1 - p2) * 1000000000000. &lt;= qMin(qAbs(p1), qAbs(p2)));&#125;Q_REQUIRED_RESULT Q_DECL_CONSTEXPR static inline Q_DECL_UNUSED bool qFuzzyCompare(float p1, float p2)&#123; return (qAbs(p1 - p2) * 100000.f &lt;= qMin(qAbs(p1), qAbs(p2)));&#125;Q_REQUIRED_RESULT Q_DECL_CONSTEXPR static inline Q_DECL_UNUSED bool qFuzzyIsNull(double d)&#123; return qAbs(d) &lt;= 0.000000000001;&#125;Q_REQUIRED_RESULT Q_DECL_CONSTEXPR static inline Q_DECL_UNUSED bool qFuzzyIsNull(float f)&#123; return qAbs(f) &lt;= 0.00001f;&#125;QT_WARNING_PUSHQT_WARNING_DISABLE_CLANG("-Wfloat-equal")QT_WARNING_DISABLE_GCC("-Wfloat-equal")QT_WARNING_DISABLE_INTEL(1572)Q_REQUIRED_RESULT Q_DECL_CONSTEXPR static inline Q_DECL_UNUSED bool qIsNull(double d) noexcept&#123; return d == 0.0;&#125;Q_REQUIRED_RESULT Q_DECL_CONSTEXPR static inline Q_DECL_UNUSED bool qIsNull(float f) noexcept&#123; return f == 0.0f;&#125;QT_WARNING_POP/* Compilers which follow outdated template instantiation rules require a class to have a comparison operator to exist when a QList of this type is instantiated. It's not actually used in the list, though. Hence the dummy implementation. Just in case other code relies on it we better trigger a warning mandating a real implementation.*/#ifdef Q_FULL_TEMPLATE_INSTANTIATION# define Q_DUMMY_COMPARISON_OPERATOR(C) \ bool operator==(const C&amp;) const &#123; \ qWarning(#C"::operator==(const "#C"&amp;) was called"); \ return false; \ &#125;#else# define Q_DUMMY_COMPARISON_OPERATOR(C)#endifQT_WARNING_PUSH// warning: noexcept-expression evaluates to 'false' because of a call to 'void swap(..., ...)'QT_WARNING_DISABLE_GCC("-Wnoexcept")namespace QtPrivate&#123;namespace SwapExceptionTester &#123; // insulate users from the "using std::swap" below using std::swap; // import std::swap template &lt;typename T&gt; void checkSwap(T &amp;t) noexcept(noexcept(swap(t, t))); // declared, but not implemented (only to be used in unevaluated contexts (noexcept operator))&#125;&#125; // namespace QtPrivatetemplate &lt;typename T&gt;inline void qSwap(T &amp;value1, T &amp;value2) noexcept(noexcept(QtPrivate::SwapExceptionTester::checkSwap(value1)))&#123; using std::swap; swap(value1, value2);&#125;QT_WARNING_POP#if QT_DEPRECATED_SINCE(5, 0)Q_CORE_EXPORT QT_DEPRECATED void *qMalloc(size_t size) Q_ALLOC_SIZE(1);Q_CORE_EXPORT QT_DEPRECATED void qFree(void *ptr);Q_CORE_EXPORT QT_DEPRECATED void *qRealloc(void *ptr, size_t size) Q_ALLOC_SIZE(2);Q_CORE_EXPORT QT_DEPRECATED void *qMemCopy(void *dest, const void *src, size_t n);Q_CORE_EXPORT QT_DEPRECATED void *qMemSet(void *dest, int c, size_t n);#endifQ_CORE_EXPORT void *qMallocAligned(size_t size, size_t alignment) Q_ALLOC_SIZE(1);Q_CORE_EXPORT void *qReallocAligned(void *ptr, size_t size, size_t oldsize, size_t alignment) Q_ALLOC_SIZE(2);Q_CORE_EXPORT void qFreeAligned(void *ptr);/* Avoid some particularly useless warnings from some stupid compilers. To get ALL C++ compiler warnings, define QT_CC_WARNINGS or comment out the line "#define QT_NO_WARNINGS".*/#if !defined(QT_CC_WARNINGS)# define QT_NO_WARNINGS#endif#if defined(QT_NO_WARNINGS)# if defined(Q_CC_MSVC)QT_WARNING_DISABLE_MSVC(4251) /* class 'type' needs to have dll-interface to be used by clients of class 'type2' */QT_WARNING_DISABLE_MSVC(4244) /* conversion from 'type1' to 'type2', possible loss of data */QT_WARNING_DISABLE_MSVC(4275) /* non - DLL-interface classkey 'identifier' used as base for DLL-interface classkey 'identifier' */QT_WARNING_DISABLE_MSVC(4514) /* unreferenced inline function has been removed */QT_WARNING_DISABLE_MSVC(4800) /* 'type' : forcing value to bool 'true' or 'false' (performance warning) */QT_WARNING_DISABLE_MSVC(4097) /* typedef-name 'identifier1' used as synonym for class-name 'identifier2' */QT_WARNING_DISABLE_MSVC(4706) /* assignment within conditional expression */QT_WARNING_DISABLE_MSVC(4355) /* 'this' : used in base member initializer list */QT_WARNING_DISABLE_MSVC(4710) /* function not inlined */QT_WARNING_DISABLE_MSVC(4530) /* C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc */# elif defined(Q_CC_BOR)# pragma option -w-inl# pragma option -w-aus# pragma warn -inl# pragma warn -pia# pragma warn -ccc# pragma warn -rch# pragma warn -sig# endif#endif// Work around MSVC warning about use of 3-arg algorithms// until we can depend on the C++14 4-arg ones.//// These algortithms do NOT check for equal length.// They need to be treated as if they called the 3-arg version (which they do)!#ifdef Q_CC_MSVC# define QT_3ARG_ALG(alg, f1, l1, f2, l2) \ std::alg(f1, l1, f2, l2)#else# define QT_3ARG_ALG(alg, f1, l1, f2, l2) \ [&amp;f1, &amp;l1, &amp;f2, &amp;l2]() &#123; \ Q_UNUSED(l2); \ return std::alg(f1, l1, f2); \ &#125;()#endiftemplate &lt;typename ForwardIterator1, typename ForwardIterator2&gt;inline bool qt_is_permutation(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)&#123; return QT_3ARG_ALG(is_permutation, first1, last1, first2, last2);&#125;#undef QT_3ARG_ALG// this adds const to non-const objects (like std::as_const)template &lt;typename T&gt;Q_DECL_CONSTEXPR typename std::add_const&lt;T&gt;::type &amp;qAsConst(T &amp;t) noexcept &#123; return t; &#125;// prevent rvalue arguments:template &lt;typename T&gt;void qAsConst(const T &amp;&amp;) = delete;// like std::exchangetemplate &lt;typename T, typename U = T&gt;Q_DECL_RELAXED_CONSTEXPR T qExchange(T &amp;t, U &amp;&amp;newValue)&#123; T old = std::move(t); t = std::forward&lt;U&gt;(newValue); return old;&#125;#ifndef QT_NO_FOREACHnamespace QtPrivate &#123;template &lt;typename T&gt;class QForeachContainer &#123; Q_DISABLE_COPY(QForeachContainer)public: QForeachContainer(const T &amp;t) : c(t), i(qAsConst(c).begin()), e(qAsConst(c).end()) &#123;&#125; QForeachContainer(T &amp;&amp;t) : c(std::move(t)), i(qAsConst(c).begin()), e(qAsConst(c).end()) &#123;&#125; QForeachContainer(QForeachContainer &amp;&amp;other) : c(std::move(other.c)), i(qAsConst(c).begin()), e(qAsConst(c).end()), control(std::move(other.control)) &#123; &#125; QForeachContainer &amp;operator=(QForeachContainer &amp;&amp;other) &#123; c = std::move(other.c); i = qAsConst(c).begin(); e = qAsConst(c).end(); control = std::move(other.control); return *this; &#125; T c; typename T::const_iterator i, e; int control = 1;&#125;;template&lt;typename T&gt;QForeachContainer&lt;typename std::decay&lt;T&gt;::type&gt; qMakeForeachContainer(T &amp;&amp;t)&#123; return QForeachContainer&lt;typename std::decay&lt;T&gt;::type&gt;(std::forward&lt;T&gt;(t));&#125;&#125;#if __cplusplus &gt;= 201703L// Use C++17 if statement with initializer. User's code ends up in a else so// scoping of different ifs is not broken#define Q_FOREACH(variable, container) \for (auto _container_ = QtPrivate::qMakeForeachContainer(container); \ _container_.i != _container_.e; ++_container_.i) \ if (variable = *_container_.i; false) &#123;&#125; else#else// Explanation of the control word:// - it's initialized to 1// - that means both the inner and outer loops start// - if there were no breaks, at the end of the inner loop, it's set to 0, which// causes it to exit (the inner loop is run exactly once)// - at the end of the outer loop, it's inverted, so it becomes 1 again, allowing// the outer loop to continue executing// - if there was a break inside the inner loop, it will exit with control still// set to 1; in that case, the outer loop will invert it to 0 and will exit too#define Q_FOREACH(variable, container) \for (auto _container_ = QtPrivate::qMakeForeachContainer(container); \ _container_.control &amp;&amp; _container_.i != _container_.e; \ ++_container_.i, _container_.control ^= 1) \ for (variable = *_container_.i; _container_.control; _container_.control = 0)#endif#endif // QT_NO_FOREACH#define Q_FOREVER for(;;)#ifndef QT_NO_KEYWORDS# ifndef QT_NO_FOREACH# ifndef foreach# define foreach Q_FOREACH# endif# endif // QT_NO_FOREACH# ifndef forever# define forever Q_FOREVER# endif#endiftemplate &lt;typename T&gt; inline T *qGetPtrHelper(T *ptr) &#123; return ptr; &#125;template &lt;typename Ptr&gt; inline auto qGetPtrHelper(Ptr &amp;ptr) -&gt; decltype(ptr.operator-&gt;()) &#123; return ptr.operator-&gt;(); &#125;// The body must be a statement:#define Q_CAST_IGNORE_ALIGN(body) QT_WARNING_PUSH QT_WARNING_DISABLE_GCC("-Wcast-align") body QT_WARNING_POP#define Q_DECLARE_PRIVATE(Class) \ inline Class##Private* d_func() \ &#123; Q_CAST_IGNORE_ALIGN(return reinterpret_cast&lt;Class##Private *&gt;(qGetPtrHelper(d_ptr));) &#125; \ inline const Class##Private* d_func() const \ &#123; Q_CAST_IGNORE_ALIGN(return reinterpret_cast&lt;const Class##Private *&gt;(qGetPtrHelper(d_ptr));) &#125; \ friend class Class##Private;#define Q_DECLARE_PRIVATE_D(Dptr, Class) \ inline Class##Private* d_func() \ &#123; Q_CAST_IGNORE_ALIGN(return reinterpret_cast&lt;Class##Private *&gt;(qGetPtrHelper(Dptr));) &#125; \ inline const Class##Private* d_func() const \ &#123; Q_CAST_IGNORE_ALIGN(return reinterpret_cast&lt;const Class##Private *&gt;(qGetPtrHelper(Dptr));) &#125; \ friend class Class##Private;#define Q_DECLARE_PUBLIC(Class) \ inline Class* q_func() &#123; return static_cast&lt;Class *&gt;(q_ptr); &#125; \ inline const Class* q_func() const &#123; return static_cast&lt;const Class *&gt;(q_ptr); &#125; \ friend class Class;#define Q_D(Class) Class##Private * const d = d_func()#define Q_Q(Class) Class * const q = q_func()#define QT_TR_NOOP(x) x#define QT_TR_NOOP_UTF8(x) x#define QT_TRANSLATE_NOOP(scope, x) x#define QT_TRANSLATE_NOOP_UTF8(scope, x) x#define QT_TRANSLATE_NOOP3(scope, x, comment) &#123;x, comment&#125;#define QT_TRANSLATE_NOOP3_UTF8(scope, x, comment) &#123;x, comment&#125;#ifndef QT_NO_TRANSLATION // ### Qt6: This should enclose the NOOPs above#define QT_TR_N_NOOP(x) x#define QT_TRANSLATE_N_NOOP(scope, x) x#define QT_TRANSLATE_N_NOOP3(scope, x, comment) &#123;x, comment&#125;// Defined in qcoreapplication.cpp// The better name qTrId() is reserved for an upcoming function which would// return a much more powerful QStringFormatter instead of a QString.Q_CORE_EXPORT QString qtTrId(const char *id, int n = -1);#define QT_TRID_NOOP(id) id#endif // QT_NO_TRANSLATION/* When RTTI is not available, define this macro to force any uses of dynamic_cast to cause a compile failure.*/#if defined(QT_NO_DYNAMIC_CAST) &amp;&amp; !defined(dynamic_cast)# define dynamic_cast QT_PREPEND_NAMESPACE(qt_dynamic_cast_check) template&lt;typename T, typename X&gt; T qt_dynamic_cast_check(X, T* = 0) &#123; return T::dynamic_cast_will_always_fail_because_rtti_is_disabled; &#125;#endif#ifdef Q_QDOC// Just for documentation generationtemplate&lt;typename T&gt;auto qOverload(T functionPointer);template&lt;typename T&gt;auto qConstOverload(T memberFunctionPointer);template&lt;typename T&gt;auto qNonConstOverload(T memberFunctionPointer);#elif defined(Q_COMPILER_VARIADIC_TEMPLATES)template &lt;typename... Args&gt;struct QNonConstOverload&#123; template &lt;typename R, typename T&gt; Q_DECL_CONSTEXPR auto operator()(R (T::*ptr)(Args...)) const noexcept -&gt; decltype(ptr) &#123; return ptr; &#125; template &lt;typename R, typename T&gt; static Q_DECL_CONSTEXPR auto of(R (T::*ptr)(Args...)) noexcept -&gt; decltype(ptr) &#123; return ptr; &#125;&#125;;template &lt;typename... Args&gt;struct QConstOverload&#123; template &lt;typename R, typename T&gt; Q_DECL_CONSTEXPR auto operator()(R (T::*ptr)(Args...) const) const noexcept -&gt; decltype(ptr) &#123; return ptr; &#125; template &lt;typename R, typename T&gt; static Q_DECL_CONSTEXPR auto of(R (T::*ptr)(Args...) const) noexcept -&gt; decltype(ptr) &#123; return ptr; &#125;&#125;;template &lt;typename... Args&gt;struct QOverload : QConstOverload&lt;Args...&gt;, QNonConstOverload&lt;Args...&gt;&#123; using QConstOverload&lt;Args...&gt;::of; using QConstOverload&lt;Args...&gt;::operator(); using QNonConstOverload&lt;Args...&gt;::of; using QNonConstOverload&lt;Args...&gt;::operator(); template &lt;typename R&gt; Q_DECL_CONSTEXPR auto operator()(R (*ptr)(Args...)) const noexcept -&gt; decltype(ptr) &#123; return ptr; &#125; template &lt;typename R&gt; static Q_DECL_CONSTEXPR auto of(R (*ptr)(Args...)) noexcept -&gt; decltype(ptr) &#123; return ptr; &#125;&#125;;#if defined(__cpp_variable_templates) &amp;&amp; __cpp_variable_templates &gt;= 201304 // C++14template &lt;typename... Args&gt; Q_CONSTEXPR Q_DECL_UNUSED QOverload&lt;Args...&gt; qOverload = &#123;&#125;;template &lt;typename... Args&gt; Q_CONSTEXPR Q_DECL_UNUSED QConstOverload&lt;Args...&gt; qConstOverload = &#123;&#125;;template &lt;typename... Args&gt; Q_CONSTEXPR Q_DECL_UNUSED QNonConstOverload&lt;Args...&gt; qNonConstOverload = &#123;&#125;;#endif#endifclass QByteArray;Q_CORE_EXPORT QByteArray qgetenv(const char *varName);// need it as two functions because QString is only forward-declared hereQ_CORE_EXPORT QString qEnvironmentVariable(const char *varName);Q_CORE_EXPORT QString qEnvironmentVariable(const char *varName, const QString &amp;defaultValue);Q_CORE_EXPORT bool qputenv(const char *varName, const QByteArray&amp; value);Q_CORE_EXPORT bool qunsetenv(const char *varName);Q_CORE_EXPORT bool qEnvironmentVariableIsEmpty(const char *varName) noexcept;Q_CORE_EXPORT bool qEnvironmentVariableIsSet(const char *varName) noexcept;Q_CORE_EXPORT int qEnvironmentVariableIntValue(const char *varName, bool *ok=nullptr) noexcept;inline int qIntCast(double f) &#123; return int(f); &#125;inline int qIntCast(float f) &#123; return int(f); &#125;/* Reentrant versions of basic rand() functions for random number generation*/#if QT_DEPRECATED_SINCE(5, 15)Q_CORE_EXPORT QT_DEPRECATED_VERSION_X_5_15("use QRandomGenerator instead") void qsrand(uint seed);Q_CORE_EXPORT QT_DEPRECATED_VERSION_X_5_15("use QRandomGenerator instead") int qrand();#endif#define QT_MODULE(x)#if !defined(QT_BOOTSTRAPPED) &amp;&amp; defined(QT_REDUCE_RELOCATIONS) &amp;&amp; defined(__ELF__) &amp;&amp; \ (!defined(__PIC__) || (defined(__PIE__) &amp;&amp; defined(Q_CC_GNU) &amp;&amp; Q_CC_GNU &gt;= 500))# error "You must build your code with position independent code if Qt was built with -reduce-relocations. "\ "Compile your code with -fPIC (and not with -fPIE)."#endifnamespace QtPrivate &#123;//like std::enable_iftemplate &lt;bool B, typename T = void&gt; struct QEnableIf;template &lt;typename T&gt; struct QEnableIf&lt;true, T&gt; &#123; typedef T Type; &#125;;&#125;QT_END_NAMESPACE// We need to keep QTypeInfo, QSysInfo, QFlags, qDebug &amp; family in qglobal.h for compatibility with Qt 4.// Be careful when changing the order of these files.#include &lt;QtCore/qtypeinfo.h&gt;#include &lt;QtCore/qsysinfo.h&gt;#include &lt;QtCore/qlogging.h&gt;#include &lt;QtCore/qflags.h&gt;#include &lt;QtCore/qatomic.h&gt;#include &lt;QtCore/qglobalstatic.h&gt;#include &lt;QtCore/qnumeric.h&gt;#include &lt;QtCore/qversiontagging.h&gt;#endif /* __cplusplus */#endif /* !__ASSEMBLER__ */#endif /* QGLOBAL_H */]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QObject]]></title>
    <url>%2FQT%2Fqobject%2F</url>
    <content type="text"><![CDATA[QObject Header: #include qmake: QT += core Inherited By: QAbstractAnimation, QAbstractEventDispatcher, QAbstractItemDelegate, QAbstractItemModel, QAbstractNetworkCache, QAbstractState, QAbstractTextDocumentLayout, QAbstractTransition, QAccessiblePlugin, QAction, QActionGroup, QAxFactory, QAxObject, QAxScript, QAxScriptManager, QButtonGroup, QClipboard, QCompleter, QCoreApplication, QDataWidgetMapper, QDBusAbstractAdaptor, QDBusAbstractInterface, QDBusPendingCallWatcher, QDBusServer, QDBusServiceWatcher, QDBusVirtualObject, QDesignerFormEditorInterface, QDesignerFormWindowManagerInterface, QDnsLookup, QDrag, QDtls, QDtlsClientVerifier, QEventLoop, QExtensionFactory, QExtensionManager, QFileSelector, QFileSystemWatcher, QFutureWatcher, QGenericPlugin, QGesture, QGraphicsAnchor, QGraphicsEffect, QGraphicsItemAnimation, QGraphicsObject, QGraphicsScene, QGraphicsTransform, QHttpMultiPart, QIconEnginePlugin, QImageIOPlugin, QInputMethod, QIODevice, QItemSelectionModel, QJSEngine, QLayout, QLibrary, QLocalServer, QMacToolBar, QMacToolBarItem, QMimeData, QMovie, QNetworkAccessManager, QNetworkConfigurationManager, QNetworkCookieJar, QNetworkSession, QObjectCleanupHandler, QOffscreenSurface, QOpenGLContext, QOpenGLContextGroup, QOpenGLDebugLogger, QOpenGLShader, QOpenGLShaderProgram, QOpenGLTimeMonitor, QOpenGLTimerQuery, QOpenGLVertexArrayObject, QPdfWriter, QPictureFormatPlugin, QPluginLoader, QQmlComponent, QQmlContext, QQmlEngineExtensionPlugin, QQmlExpression, QQmlFileSelector, QQmlPropertyMap, QQuickImageResponse, QQuickItem, QQuickItemGrabResult, QQuickRenderControl, QQuickTextDocument, QQuickTextureFactory, QScreen, QScroller, QSessionManager, QSettings, QSGAbstractRenderer, QSGEngine, QSGTexture, QSGTextureProvider, QSharedMemory, QShortcut, QSignalMapper, QSocketNotifier, QStyle, QStyleHints, QStylePlugin, QSyntaxHighlighter, QSystemTrayIcon, QTcpServer, QTextDocument, QTextObject, QThread, QThreadPool, QTimeLine, QTimer, QTranslator, QUndoGroup, QUndoStack, QValidator, QWidget, QWindow, QWinEventNotifier, QWinJumpList, QWinTaskbarButton, QWinTaskbarProgress, QWinThumbnailToolBar, and QWinThumbnailToolButton 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600#ifndef QOBJECT_H#define QOBJECT_H#ifndef QT_NO_QOBJECT#include &lt;QtCore/qobjectdefs.h&gt;#include &lt;QtCore/qstring.h&gt;#include &lt;QtCore/qbytearray.h&gt;#include &lt;QtCore/qlist.h&gt;#ifdef QT_INCLUDE_COMPAT#include &lt;QtCore/qcoreevent.h&gt;#endif#include &lt;QtCore/qscopedpointer.h&gt;#include &lt;QtCore/qmetatype.h&gt;#include &lt;QtCore/qobject_impl.h&gt;#if __has_include(&lt;chrono&gt;)# include &lt;chrono&gt;#endifQT_BEGIN_NAMESPACEclass QEvent;class QTimerEvent;class QChildEvent;struct QMetaObject;class QVariant;class QObjectPrivate;class QObject;class QThread;class QWidget;class QAccessibleWidget;#ifndef QT_NO_REGEXPclass QRegExp;#endif#if QT_CONFIG(regularexpression)class QRegularExpression;#endif#if !QT_DEPRECATED_SINCE(5, 14) || QT_VERSION &gt;= QT_VERSION_CHECK(6, 0, 0)# define QT_NO_USERDATA#endif#ifndef QT_NO_USERDATAclass QObjectUserData;#endifstruct QDynamicMetaObjectData;typedef QList&lt;QObject*&gt; QObjectList;Q_CORE_EXPORT void qt_qFindChildren_helper(const QObject *parent, const QString &amp;name, const QMetaObject &amp;mo, QList&lt;void *&gt; *list, Qt::FindChildOptions options);Q_CORE_EXPORT void qt_qFindChildren_helper(const QObject *parent, const QRegExp &amp;re, const QMetaObject &amp;mo, QList&lt;void *&gt; *list, Qt::FindChildOptions options);Q_CORE_EXPORT void qt_qFindChildren_helper(const QObject *parent, const QRegularExpression &amp;re, const QMetaObject &amp;mo, QList&lt;void *&gt; *list, Qt::FindChildOptions options);Q_CORE_EXPORT QObject *qt_qFindChild_helper(const QObject *parent, const QString &amp;name, const QMetaObject &amp;mo, Qt::FindChildOptions options);class Q_CORE_EXPORT QObjectData &#123; Q_DISABLE_COPY(QObjectData)public: QObjectData() = default; virtual ~QObjectData() = 0; QObject *q_ptr; QObject *parent; QObjectList children; uint isWidget : 1; uint blockSig : 1; uint wasDeleted : 1; uint isDeletingChildren : 1; uint sendChildEvents : 1; uint receiveChildEvents : 1; uint isWindow : 1; //for QWindow uint deleteLaterCalled : 1; uint unused : 24; int postedEvents; QDynamicMetaObjectData *metaObject; QMetaObject *dynamicMetaObject() const;#ifdef QT_DEBUG enum &#123; CheckForParentChildLoopsWarnDepth = 4096 &#125;;#endif&#125;;class Q_CORE_EXPORT QObject&#123; Q_OBJECT Q_PROPERTY(QString objectName READ objectName WRITE setObjectName NOTIFY objectNameChanged) Q_DECLARE_PRIVATE(QObject)public: Q_INVOKABLE explicit QObject(QObject *parent=nullptr); virtual ~QObject(); virtual bool event(QEvent *event); virtual bool eventFilter(QObject *watched, QEvent *event);#if defined(QT_NO_TRANSLATION) || defined(Q_CLANG_QDOC) static QString tr(const char *sourceText, const char * = nullptr, int = -1) &#123; return QString::fromUtf8(sourceText); &#125;#if QT_DEPRECATED_SINCE(5, 0) QT_DEPRECATED static QString trUtf8(const char *sourceText, const char * = nullptr, int = -1) &#123; return QString::fromUtf8(sourceText); &#125;#endif#endif //QT_NO_TRANSLATION QString objectName() const; void setObjectName(const QString &amp;name); inline bool isWidgetType() const &#123; return d_ptr-&gt;isWidget; &#125; inline bool isWindowType() const &#123; return d_ptr-&gt;isWindow; &#125; inline bool signalsBlocked() const noexcept &#123; return d_ptr-&gt;blockSig; &#125; bool blockSignals(bool b) noexcept; QThread *thread() const; void moveToThread(QThread *thread); int startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer);#if __has_include(&lt;chrono&gt;) Q_ALWAYS_INLINE int startTimer(std::chrono::milliseconds time, Qt::TimerType timerType = Qt::CoarseTimer) &#123; return startTimer(int(time.count()), timerType); &#125;#endif void killTimer(int id); template&lt;typename T&gt; inline T findChild(const QString &amp;aName = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const &#123; typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type ObjType; return static_cast&lt;T&gt;(qt_qFindChild_helper(this, aName, ObjType::staticMetaObject, options)); &#125; template&lt;typename T&gt; inline QList&lt;T&gt; findChildren(const QString &amp;aName = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const &#123; typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type ObjType; QList&lt;T&gt; list; qt_qFindChildren_helper(this, aName, ObjType::staticMetaObject, reinterpret_cast&lt;QList&lt;void *&gt; *&gt;(&amp;list), options); return list; &#125;#ifndef QT_NO_REGEXP#if QT_DEPRECATED_SINCE(5, 13) template&lt;typename T&gt; QT_DEPRECATED_X("Use findChildren(const QRegularExpression &amp;, ...) instead.") inline QList&lt;T&gt; findChildren(const QRegExp &amp;re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const &#123; typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type ObjType; QList&lt;T&gt; list; qt_qFindChildren_helper(this, re, ObjType::staticMetaObject, reinterpret_cast&lt;QList&lt;void *&gt; *&gt;(&amp;list), options); return list; &#125;#endif#endif#if QT_CONFIG(regularexpression) template&lt;typename T&gt; inline QList&lt;T&gt; findChildren(const QRegularExpression &amp;re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const &#123; typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type ObjType; QList&lt;T&gt; list; qt_qFindChildren_helper(this, re, ObjType::staticMetaObject, reinterpret_cast&lt;QList&lt;void *&gt; *&gt;(&amp;list), options); return list; &#125;#endif // QT_CONFIG(regularexpression) inline const QObjectList &amp;children() const &#123; return d_ptr-&gt;children; &#125; void setParent(QObject *parent); void installEventFilter(QObject *filterObj); void removeEventFilter(QObject *obj); static QMetaObject::Connection connect(const QObject *sender, const char *signal, const QObject *receiver, const char *member, Qt::ConnectionType = Qt::AutoConnection); static QMetaObject::Connection connect(const QObject *sender, const QMetaMethod &amp;signal, const QObject *receiver, const QMetaMethod &amp;method, Qt::ConnectionType type = Qt::AutoConnection); inline QMetaObject::Connection connect(const QObject *sender, const char *signal, const char *member, Qt::ConnectionType type = Qt::AutoConnection) const;#ifdef Q_CLANG_QDOC template&lt;typename PointerToMemberFunction&gt; static QMetaObject::Connection connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type = Qt::AutoConnection); template&lt;typename PointerToMemberFunction, typename Functor&gt; static QMetaObject::Connection connect(const QObject *sender, PointerToMemberFunction signal, Functor functor); template&lt;typename PointerToMemberFunction, typename Functor&gt; static QMetaObject::Connection connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type = Qt::AutoConnection);#else //Connect a signal to a pointer to qobject member function template &lt;typename Func1, typename Func2&gt; static inline QMetaObject::Connection connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, const typename QtPrivate::FunctionPointer&lt;Func2&gt;::Object *receiver, Func2 slot, Qt::ConnectionType type = Qt::AutoConnection) &#123; typedef QtPrivate::FunctionPointer&lt;Func1&gt; SignalType; typedef QtPrivate::FunctionPointer&lt;Func2&gt; SlotType; Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro&lt;typename SignalType::Object&gt;::Value, "No Q_OBJECT in the class with the signal"); //compilation error if the arguments does not match. Q_STATIC_ASSERT_X(int(SignalType::ArgumentCount) &gt;= int(SlotType::ArgumentCount), "The slot requires more arguments than the signal provides."); Q_STATIC_ASSERT_X((QtPrivate::CheckCompatibleArguments&lt;typename SignalType::Arguments, typename SlotType::Arguments&gt;::value), "Signal and slot arguments are not compatible."); Q_STATIC_ASSERT_X((QtPrivate::AreArgumentsCompatible&lt;typename SlotType::ReturnType, typename SignalType::ReturnType&gt;::value), "Return type of the slot is not compatible with the return type of the signal."); const int *types = nullptr; if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection) types = QtPrivate::ConnectionTypes&lt;typename SignalType::Arguments&gt;::types(); return connectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal), receiver, reinterpret_cast&lt;void **&gt;(&amp;slot), new QtPrivate::QSlotObject&lt;Func2, typename QtPrivate::List_Left&lt;typename SignalType::Arguments, SlotType::ArgumentCount&gt;::Value, typename SignalType::ReturnType&gt;(slot), type, types, &amp;SignalType::Object::staticMetaObject); &#125; //connect to a function pointer (not a member) template &lt;typename Func1, typename Func2&gt; static inline typename std::enable_if&lt;int(QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount) &gt;= 0, QMetaObject::Connection&gt;::type connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, Func2 slot) &#123; return connect(sender, signal, sender, slot, Qt::DirectConnection); &#125; //connect to a function pointer (not a member) template &lt;typename Func1, typename Func2&gt; static inline typename std::enable_if&lt;int(QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount) &gt;= 0 &amp;&amp; !QtPrivate::FunctionPointer&lt;Func2&gt;::IsPointerToMemberFunction, QMetaObject::Connection&gt;::type connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, const QObject *context, Func2 slot, Qt::ConnectionType type = Qt::AutoConnection) &#123; typedef QtPrivate::FunctionPointer&lt;Func1&gt; SignalType; typedef QtPrivate::FunctionPointer&lt;Func2&gt; SlotType; Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro&lt;typename SignalType::Object&gt;::Value, "No Q_OBJECT in the class with the signal"); //compilation error if the arguments does not match. Q_STATIC_ASSERT_X(int(SignalType::ArgumentCount) &gt;= int(SlotType::ArgumentCount), "The slot requires more arguments than the signal provides."); Q_STATIC_ASSERT_X((QtPrivate::CheckCompatibleArguments&lt;typename SignalType::Arguments, typename SlotType::Arguments&gt;::value), "Signal and slot arguments are not compatible."); Q_STATIC_ASSERT_X((QtPrivate::AreArgumentsCompatible&lt;typename SlotType::ReturnType, typename SignalType::ReturnType&gt;::value), "Return type of the slot is not compatible with the return type of the signal."); const int *types = nullptr; if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection) types = QtPrivate::ConnectionTypes&lt;typename SignalType::Arguments&gt;::types(); return connectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal), context, nullptr, new QtPrivate::QStaticSlotObject&lt;Func2, typename QtPrivate::List_Left&lt;typename SignalType::Arguments, SlotType::ArgumentCount&gt;::Value, typename SignalType::ReturnType&gt;(slot), type, types, &amp;SignalType::Object::staticMetaObject); &#125; //connect to a functor template &lt;typename Func1, typename Func2&gt; static inline typename std::enable_if&lt;QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount == -1, QMetaObject::Connection&gt;::type connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, Func2 slot) &#123; return connect(sender, signal, sender, std::move(slot), Qt::DirectConnection); &#125; //connect to a functor, with a "context" object defining in which event loop is going to be executed template &lt;typename Func1, typename Func2&gt; static inline typename std::enable_if&lt;QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount == -1, QMetaObject::Connection&gt;::type connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, const QObject *context, Func2 slot, Qt::ConnectionType type = Qt::AutoConnection) &#123; typedef QtPrivate::FunctionPointer&lt;Func1&gt; SignalType; const int FunctorArgumentCount = QtPrivate::ComputeFunctorArgumentCount&lt;Func2 , typename SignalType::Arguments&gt;::Value; Q_STATIC_ASSERT_X((FunctorArgumentCount &gt;= 0), "Signal and slot arguments are not compatible."); const int SlotArgumentCount = (FunctorArgumentCount &gt;= 0) ? FunctorArgumentCount : 0; typedef typename QtPrivate::FunctorReturnType&lt;Func2, typename QtPrivate::List_Left&lt;typename SignalType::Arguments, SlotArgumentCount&gt;::Value&gt;::Value SlotReturnType; Q_STATIC_ASSERT_X((QtPrivate::AreArgumentsCompatible&lt;SlotReturnType, typename SignalType::ReturnType&gt;::value), "Return type of the slot is not compatible with the return type of the signal."); Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro&lt;typename SignalType::Object&gt;::Value, "No Q_OBJECT in the class with the signal"); const int *types = nullptr; if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection) types = QtPrivate::ConnectionTypes&lt;typename SignalType::Arguments&gt;::types(); return connectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal), context, nullptr, new QtPrivate::QFunctorSlotObject&lt;Func2, SlotArgumentCount, typename QtPrivate::List_Left&lt;typename SignalType::Arguments, SlotArgumentCount&gt;::Value, typename SignalType::ReturnType&gt;(std::move(slot)), type, types, &amp;SignalType::Object::staticMetaObject); &#125;#endif //Q_CLANG_QDOC static bool disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *member); static bool disconnect(const QObject *sender, const QMetaMethod &amp;signal, const QObject *receiver, const QMetaMethod &amp;member); inline bool disconnect(const char *signal = nullptr, const QObject *receiver = nullptr, const char *member = nullptr) const &#123; return disconnect(this, signal, receiver, member); &#125; inline bool disconnect(const QObject *receiver, const char *member = nullptr) const &#123; return disconnect(this, nullptr, receiver, member); &#125; static bool disconnect(const QMetaObject::Connection &amp;);#ifdef Q_CLANG_QDOC template&lt;typename PointerToMemberFunction&gt; static bool disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method);#else template &lt;typename Func1, typename Func2&gt; static inline bool disconnect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, const typename QtPrivate::FunctionPointer&lt;Func2&gt;::Object *receiver, Func2 slot) &#123; typedef QtPrivate::FunctionPointer&lt;Func1&gt; SignalType; typedef QtPrivate::FunctionPointer&lt;Func2&gt; SlotType; Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro&lt;typename SignalType::Object&gt;::Value, "No Q_OBJECT in the class with the signal"); //compilation error if the arguments does not match. Q_STATIC_ASSERT_X((QtPrivate::CheckCompatibleArguments&lt;typename SignalType::Arguments, typename SlotType::Arguments&gt;::value), "Signal and slot arguments are not compatible."); return disconnectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal), receiver, reinterpret_cast&lt;void **&gt;(&amp;slot), &amp;SignalType::Object::staticMetaObject); &#125; template &lt;typename Func1&gt; static inline bool disconnect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, const QObject *receiver, void **zero) &#123; // This is the overload for when one wish to disconnect a signal from any slot. (slot=nullptr) // Since the function template parameter cannot be deduced from '0', we use a // dummy void ** parameter that must be equal to 0 Q_ASSERT(!zero); typedef QtPrivate::FunctionPointer&lt;Func1&gt; SignalType; return disconnectImpl(sender, reinterpret_cast&lt;void **&gt;(&amp;signal), receiver, zero, &amp;SignalType::Object::staticMetaObject); &#125;#endif //Q_CLANG_QDOC#if QT_VERSION &lt; QT_VERSION_CHECK(6, 0, 0) void dumpObjectTree(); // ### Qt 6: remove void dumpObjectInfo(); // ### Qt 6: remove#endif void dumpObjectTree() const; void dumpObjectInfo() const;#ifndef QT_NO_PROPERTIES bool setProperty(const char *name, const QVariant &amp;value); QVariant property(const char *name) const; QList&lt;QByteArray&gt; dynamicPropertyNames() const;#endif // QT_NO_PROPERTIES#ifndef QT_NO_USERDATA QT_DEPRECATED_VERSION_5_14 static uint registerUserData(); QT_DEPRECATED_VERSION_X_5_14("Use setProperty()") void setUserData(uint id, QObjectUserData* data); QT_DEPRECATED_VERSION_X_5_14("Use property()") QObjectUserData* userData(uint id) const;#endif // QT_NO_USERDATAQ_SIGNALS: void destroyed(QObject * = nullptr); void objectNameChanged(const QString &amp;objectName, QPrivateSignal);public: inline QObject *parent() const &#123; return d_ptr-&gt;parent; &#125; inline bool inherits(const char *classname) const &#123; return const_cast&lt;QObject *&gt;(this)-&gt;qt_metacast(classname) != nullptr; &#125;public Q_SLOTS: void deleteLater();protected: QObject *sender() const; int senderSignalIndex() const; int receivers(const char* signal) const; bool isSignalConnected(const QMetaMethod &amp;signal) const; virtual void timerEvent(QTimerEvent *event); virtual void childEvent(QChildEvent *event); virtual void customEvent(QEvent *event); virtual void connectNotify(const QMetaMethod &amp;signal); virtual void disconnectNotify(const QMetaMethod &amp;signal);protected: QObject(QObjectPrivate &amp;dd, QObject *parent = nullptr);protected: QScopedPointer&lt;QObjectData&gt; d_ptr; static const QMetaObject staticQtMetaObject; friend inline const QMetaObject *qt_getQtMetaObject() noexcept; friend struct QMetaObject; friend struct QMetaObjectPrivate; friend class QMetaCallEvent; friend class QApplication; friend class QApplicationPrivate; friend class QCoreApplication; friend class QCoreApplicationPrivate; friend class QWidget; friend class QAccessibleWidget; friend class QThreadData;private: Q_DISABLE_COPY(QObject) Q_PRIVATE_SLOT(d_func(), void _q_reregisterTimers(void *))private: static QMetaObject::Connection connectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slotPtr, QtPrivate::QSlotObjectBase *slot, Qt::ConnectionType type, const int *types, const QMetaObject *senderMetaObject); static bool disconnectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slot, const QMetaObject *senderMetaObject);&#125;;inline QMetaObject::Connection QObject::connect(const QObject *asender, const char *asignal, const char *amember, Qt::ConnectionType atype) const&#123; return connect(asender, asignal, this, amember, atype); &#125;inline const QMetaObject *qt_getQtMetaObject() noexcept&#123; return &amp;QObject::staticQtMetaObject; &#125;#ifndef QT_NO_USERDATAclass Q_CORE_EXPORT QObjectUserData &#123; Q_DISABLE_COPY(QObjectUserData)public: QObjectUserData() = default; virtual ~QObjectUserData();&#125;;#endif#if QT_DEPRECATED_SINCE(5, 0)template&lt;typename T&gt;inline QT_DEPRECATED T qFindChild(const QObject *o, const QString &amp;name = QString())&#123; return o-&gt;findChild&lt;T&gt;(name); &#125;template&lt;typename T&gt;inline QT_DEPRECATED QList&lt;T&gt; qFindChildren(const QObject *o, const QString &amp;name = QString())&#123; return o-&gt;findChildren&lt;T&gt;(name);&#125;#if !defined(QT_NO_REGEXP) || defined(Q_CLANG_QDOC)template&lt;typename T&gt;inline QT_DEPRECATED QList&lt;T&gt; qFindChildren(const QObject *o, const QRegExp &amp;re)&#123; return o-&gt;findChildren&lt;T&gt;(re);&#125;#endif#endif //QT_DEPRECATEDtemplate &lt;class T&gt;inline T qobject_cast(QObject *object)&#123; typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type ObjType; Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro&lt;ObjType&gt;::Value, "qobject_cast requires the type to have a Q_OBJECT macro"); return static_cast&lt;T&gt;(ObjType::staticMetaObject.cast(object));&#125;template &lt;class T&gt;inline T qobject_cast(const QObject *object)&#123; typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type ObjType; Q_STATIC_ASSERT_X(QtPrivate::HasQ_OBJECT_Macro&lt;ObjType&gt;::Value, "qobject_cast requires the type to have a Q_OBJECT macro"); return static_cast&lt;T&gt;(ObjType::staticMetaObject.cast(object));&#125;template &lt;class T&gt; inline const char * qobject_interface_iid()&#123; return nullptr; &#125;#if defined(Q_CLANG_QDOC)# define Q_DECLARE_INTERFACE(IFace, IId)#elif !defined(Q_MOC_RUN)# define Q_DECLARE_INTERFACE(IFace, IId) \ template &lt;&gt; inline const char *qobject_interface_iid&lt;IFace *&gt;() \ &#123; return IId; &#125; \ template &lt;&gt; inline IFace *qobject_cast&lt;IFace *&gt;(QObject *object) \ &#123; return reinterpret_cast&lt;IFace *&gt;((object ? object-&gt;qt_metacast(IId) : nullptr)); &#125; \ template &lt;&gt; inline IFace *qobject_cast&lt;IFace *&gt;(const QObject *object) \ &#123; return reinterpret_cast&lt;IFace *&gt;((object ? const_cast&lt;QObject *&gt;(object)-&gt;qt_metacast(IId) : nullptr)); &#125;#endif // Q_MOC_RUN#ifndef QT_NO_DEBUG_STREAMQ_CORE_EXPORT QDebug operator&lt;&lt;(QDebug, const QObject *);#endifclass QSignalBlocker&#123;public: inline explicit QSignalBlocker(QObject *o) noexcept; inline explicit QSignalBlocker(QObject &amp;o) noexcept; inline ~QSignalBlocker(); inline QSignalBlocker(QSignalBlocker &amp;&amp;other) noexcept; inline QSignalBlocker &amp;operator=(QSignalBlocker &amp;&amp;other) noexcept; inline void reblock() noexcept; inline void unblock() noexcept;private: Q_DISABLE_COPY(QSignalBlocker) QObject * m_o; bool m_blocked; bool m_inhibited;&#125;;QSignalBlocker::QSignalBlocker(QObject *o) noexcept : m_o(o), m_blocked(o &amp;&amp; o-&gt;blockSignals(true)), m_inhibited(false)&#123;&#125;QSignalBlocker::QSignalBlocker(QObject &amp;o) noexcept : m_o(&amp;o), m_blocked(o.blockSignals(true)), m_inhibited(false)&#123;&#125;QSignalBlocker::QSignalBlocker(QSignalBlocker &amp;&amp;other) noexcept : m_o(other.m_o), m_blocked(other.m_blocked), m_inhibited(other.m_inhibited)&#123; other.m_o = nullptr;&#125;QSignalBlocker &amp;QSignalBlocker::operator=(QSignalBlocker &amp;&amp;other) noexcept&#123; if (this != &amp;other) &#123; // if both *this and other block the same object's signals: // unblock *this iff our dtor would unblock, but other's wouldn't if (m_o != other.m_o || (!m_inhibited &amp;&amp; other.m_inhibited)) unblock(); m_o = other.m_o; m_blocked = other.m_blocked; m_inhibited = other.m_inhibited; // disable other: other.m_o = nullptr; &#125; return *this;&#125;QSignalBlocker::~QSignalBlocker()&#123; if (m_o &amp;&amp; !m_inhibited) m_o-&gt;blockSignals(m_blocked);&#125;void QSignalBlocker::reblock() noexcept&#123; if (m_o) m_o-&gt;blockSignals(true); m_inhibited = false;&#125;void QSignalBlocker::unblock() noexcept&#123; if (m_o) m_o-&gt;blockSignals(m_blocked); m_inhibited = true;&#125;namespace QtPrivate &#123; inline QObject &amp; deref_for_methodcall(QObject &amp;o) &#123; return o; &#125; inline QObject &amp; deref_for_methodcall(QObject *o) &#123; return *o; &#125;&#125;#define Q_SET_OBJECT_NAME(obj) QT_PREPEND_NAMESPACE(QtPrivate)::deref_for_methodcall(obj).setObjectName(QLatin1String(#obj))QT_END_NAMESPACE#endif#endif // QOBJECT_H]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QGraphicsView]]></title>
    <url>%2FQT%2Fqgraphicsview%2F</url>
    <content type="text"><![CDATA[QGraphicsView Header: #include qmake: QT += widgets Since: Qt 4.2 Inherits: QAbstractScrollArea 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282#ifndef QGRAPHICSVIEW_H#define QGRAPHICSVIEW_H#include &lt;QtWidgets/qtwidgetsglobal.h&gt;#include &lt;QtCore/qmetatype.h&gt;#include &lt;QtGui/qpainter.h&gt;#include &lt;QtWidgets/qscrollarea.h&gt;#include &lt;QtWidgets/qgraphicsscene.h&gt;QT_REQUIRE_CONFIG(graphicsview);QT_BEGIN_NAMESPACEclass QGraphicsItem;class QPainterPath;class QPolygonF;class QStyleOptionGraphicsItem;class QGraphicsViewPrivate;class Q_WIDGETS_EXPORT QGraphicsView : public QAbstractScrollArea&#123; Q_OBJECT Q_FLAGS(QPainter::RenderHints CacheMode OptimizationFlags) Q_PROPERTY(QBrush backgroundBrush READ backgroundBrush WRITE setBackgroundBrush) Q_PROPERTY(QBrush foregroundBrush READ foregroundBrush WRITE setForegroundBrush) Q_PROPERTY(bool interactive READ isInteractive WRITE setInteractive) Q_PROPERTY(QRectF sceneRect READ sceneRect WRITE setSceneRect) Q_PROPERTY(Qt::Alignment alignment READ alignment WRITE setAlignment) Q_PROPERTY(QPainter::RenderHints renderHints READ renderHints WRITE setRenderHints) Q_PROPERTY(DragMode dragMode READ dragMode WRITE setDragMode) Q_PROPERTY(CacheMode cacheMode READ cacheMode WRITE setCacheMode) Q_PROPERTY(ViewportAnchor transformationAnchor READ transformationAnchor WRITE setTransformationAnchor) Q_PROPERTY(ViewportAnchor resizeAnchor READ resizeAnchor WRITE setResizeAnchor) Q_PROPERTY(ViewportUpdateMode viewportUpdateMode READ viewportUpdateMode WRITE setViewportUpdateMode)#if QT_CONFIG(rubberband) Q_PROPERTY(Qt::ItemSelectionMode rubberBandSelectionMode READ rubberBandSelectionMode WRITE setRubberBandSelectionMode)#endif Q_PROPERTY(OptimizationFlags optimizationFlags READ optimizationFlags WRITE setOptimizationFlags)public: enum ViewportAnchor &#123; NoAnchor, AnchorViewCenter, AnchorUnderMouse &#125;; Q_ENUM(ViewportAnchor) enum CacheModeFlag &#123; CacheNone = 0x0, CacheBackground = 0x1 &#125;; Q_DECLARE_FLAGS(CacheMode, CacheModeFlag) enum DragMode &#123; NoDrag, ScrollHandDrag, RubberBandDrag &#125;; Q_ENUM(DragMode) enum ViewportUpdateMode &#123; FullViewportUpdate, MinimalViewportUpdate, SmartViewportUpdate, NoViewportUpdate, BoundingRectViewportUpdate &#125;; Q_ENUM(ViewportUpdateMode) enum OptimizationFlag &#123;#if QT_DEPRECATED_SINCE(5, 14) DontClipPainter Q_DECL_ENUMERATOR_DEPRECATED_X("This flag is unused") = 0x1, // obsolete#endif DontSavePainterState = 0x2, DontAdjustForAntialiasing = 0x4, IndirectPainting = 0x8 &#125;; Q_DECLARE_FLAGS(OptimizationFlags, OptimizationFlag) QGraphicsView(QWidget *parent = nullptr); QGraphicsView(QGraphicsScene *scene, QWidget *parent = nullptr); ~QGraphicsView(); QSize sizeHint() const override; QPainter::RenderHints renderHints() const; void setRenderHint(QPainter::RenderHint hint, bool enabled = true); void setRenderHints(QPainter::RenderHints hints); Qt::Alignment alignment() const; void setAlignment(Qt::Alignment alignment); ViewportAnchor transformationAnchor() const; void setTransformationAnchor(ViewportAnchor anchor); ViewportAnchor resizeAnchor() const; void setResizeAnchor(ViewportAnchor anchor); ViewportUpdateMode viewportUpdateMode() const; void setViewportUpdateMode(ViewportUpdateMode mode); OptimizationFlags optimizationFlags() const; void setOptimizationFlag(OptimizationFlag flag, bool enabled = true); void setOptimizationFlags(OptimizationFlags flags); DragMode dragMode() const; void setDragMode(DragMode mode);#if QT_CONFIG(rubberband) Qt::ItemSelectionMode rubberBandSelectionMode() const; void setRubberBandSelectionMode(Qt::ItemSelectionMode mode); QRect rubberBandRect() const;#endif CacheMode cacheMode() const; void setCacheMode(CacheMode mode); void resetCachedContent(); bool isInteractive() const; void setInteractive(bool allowed); QGraphicsScene *scene() const; void setScene(QGraphicsScene *scene); QRectF sceneRect() const; void setSceneRect(const QRectF &amp;rect); inline void setSceneRect(qreal x, qreal y, qreal w, qreal h);#if QT_DEPRECATED_SINCE(5, 15) QT_DEPRECATED_X("Use transform()") QMatrix matrix() const; QT_DEPRECATED_X("Use setTransform()") void setMatrix(const QMatrix &amp;matrix, bool combine = false); QT_DEPRECATED_X("Use resetTransform()") void resetMatrix();#endif // QT_DEPRECATED_SINCE(5, 15) QTransform transform() const; QTransform viewportTransform() const; bool isTransformed() const; void setTransform(const QTransform &amp;matrix, bool combine = false); void resetTransform(); void rotate(qreal angle); void scale(qreal sx, qreal sy); void shear(qreal sh, qreal sv); void translate(qreal dx, qreal dy); void centerOn(const QPointF &amp;pos); inline void centerOn(qreal x, qreal y); void centerOn(const QGraphicsItem *item); void ensureVisible(const QRectF &amp;rect, int xmargin = 50, int ymargin = 50); inline void ensureVisible(qreal x, qreal y, qreal w, qreal h, int xmargin = 50, int ymargin = 50); void ensureVisible(const QGraphicsItem *item, int xmargin = 50, int ymargin = 50); void fitInView(const QRectF &amp;rect, Qt::AspectRatioMode aspectRadioMode = Qt::IgnoreAspectRatio); inline void fitInView(qreal x, qreal y, qreal w, qreal h, Qt::AspectRatioMode aspectRadioMode = Qt::IgnoreAspectRatio); void fitInView(const QGraphicsItem *item, Qt::AspectRatioMode aspectRadioMode = Qt::IgnoreAspectRatio); void render(QPainter *painter, const QRectF &amp;target = QRectF(), const QRect &amp;source = QRect(), Qt::AspectRatioMode aspectRatioMode = Qt::KeepAspectRatio); QList&lt;QGraphicsItem *&gt; items() const; QList&lt;QGraphicsItem *&gt; items(const QPoint &amp;pos) const; inline QList&lt;QGraphicsItem *&gt; items(int x, int y) const; QList&lt;QGraphicsItem *&gt; items(const QRect &amp;rect, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const; inline QList&lt;QGraphicsItem *&gt; items(int x, int y, int w, int h, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const; QList&lt;QGraphicsItem *&gt; items(const QPolygon &amp;polygon, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const; QList&lt;QGraphicsItem *&gt; items(const QPainterPath &amp;path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const; QGraphicsItem *itemAt(const QPoint &amp;pos) const; inline QGraphicsItem *itemAt(int x, int y) const; QPointF mapToScene(const QPoint &amp;point) const; QPolygonF mapToScene(const QRect &amp;rect) const; QPolygonF mapToScene(const QPolygon &amp;polygon) const; QPainterPath mapToScene(const QPainterPath &amp;path) const; QPoint mapFromScene(const QPointF &amp;point) const; QPolygon mapFromScene(const QRectF &amp;rect) const; QPolygon mapFromScene(const QPolygonF &amp;polygon) const; QPainterPath mapFromScene(const QPainterPath &amp;path) const; inline QPointF mapToScene(int x, int y) const; inline QPolygonF mapToScene(int x, int y, int w, int h) const; inline QPoint mapFromScene(qreal x, qreal y) const; inline QPolygon mapFromScene(qreal x, qreal y, qreal w, qreal h) const; QVariant inputMethodQuery(Qt::InputMethodQuery query) const override; QBrush backgroundBrush() const; void setBackgroundBrush(const QBrush &amp;brush); QBrush foregroundBrush() const; void setForegroundBrush(const QBrush &amp;brush);public Q_SLOTS: void updateScene(const QList&lt;QRectF&gt; &amp;rects); void invalidateScene(const QRectF &amp;rect = QRectF(), QGraphicsScene::SceneLayers layers = QGraphicsScene::AllLayers); void updateSceneRect(const QRectF &amp;rect);#if QT_CONFIG(rubberband)Q_SIGNALS: void rubberBandChanged(QRect viewportRect, QPointF fromScenePoint, QPointF toScenePoint);#endifprotected Q_SLOTS: void setupViewport(QWidget *widget) override;protected: QGraphicsView(QGraphicsViewPrivate &amp;, QWidget *parent = nullptr); bool event(QEvent *event) override; bool viewportEvent(QEvent *event) override;#ifndef QT_NO_CONTEXTMENU void contextMenuEvent(QContextMenuEvent *event) override;#endif#if QT_CONFIG(draganddrop) void dragEnterEvent(QDragEnterEvent *event) override; void dragLeaveEvent(QDragLeaveEvent *event) override; void dragMoveEvent(QDragMoveEvent *event) override; void dropEvent(QDropEvent *event) override;#endif void focusInEvent(QFocusEvent *event) override; bool focusNextPrevChild(bool next) override; void focusOutEvent(QFocusEvent *event) override; void keyPressEvent(QKeyEvent *event) override; void keyReleaseEvent(QKeyEvent *event) override; void mouseDoubleClickEvent(QMouseEvent *event) override; void mousePressEvent(QMouseEvent *event) override; void mouseMoveEvent(QMouseEvent *event) override; void mouseReleaseEvent(QMouseEvent *event) override;#if QT_CONFIG(wheelevent) void wheelEvent(QWheelEvent *event) override;#endif void paintEvent(QPaintEvent *event) override; void resizeEvent(QResizeEvent *event) override; void scrollContentsBy(int dx, int dy) override; void showEvent(QShowEvent *event) override; void inputMethodEvent(QInputMethodEvent *event) override; virtual void drawBackground(QPainter *painter, const QRectF &amp;rect); virtual void drawForeground(QPainter *painter, const QRectF &amp;rect); virtual void drawItems(QPainter *painter, int numItems, QGraphicsItem *items[], const QStyleOptionGraphicsItem options[]);private: Q_DECLARE_PRIVATE(QGraphicsView) Q_DISABLE_COPY(QGraphicsView)#ifndef QT_NO_CURSOR Q_PRIVATE_SLOT(d_func(), void _q_setViewportCursor(const QCursor &amp;)) Q_PRIVATE_SLOT(d_func(), void _q_unsetViewportCursor())#endif friend class QGraphicsSceneWidget; friend class QGraphicsScene; friend class QGraphicsScenePrivate; friend class QGraphicsItemPrivate;&#125;;Q_DECLARE_OPERATORS_FOR_FLAGS(QGraphicsView::CacheMode)Q_DECLARE_OPERATORS_FOR_FLAGS(QGraphicsView::OptimizationFlags)inline void QGraphicsView::setSceneRect(qreal ax, qreal ay, qreal aw, qreal ah)&#123; setSceneRect(QRectF(ax, ay, aw, ah)); &#125;inline void QGraphicsView::centerOn(qreal ax, qreal ay)&#123; centerOn(QPointF(ax, ay)); &#125;inline void QGraphicsView::ensureVisible(qreal ax, qreal ay, qreal aw, qreal ah, int xmargin, int ymargin)&#123; ensureVisible(QRectF(ax, ay, aw, ah), xmargin, ymargin); &#125;inline void QGraphicsView::fitInView(qreal ax, qreal ay, qreal w, qreal h, Qt::AspectRatioMode mode)&#123; fitInView(QRectF(ax, ay, w, h), mode); &#125;inline QList&lt;QGraphicsItem *&gt; QGraphicsView::items(int ax, int ay) const&#123; return items(QPoint(ax, ay)); &#125;inline QList&lt;QGraphicsItem *&gt; QGraphicsView::items(int ax, int ay, int w, int h, Qt::ItemSelectionMode mode) const&#123; return items(QRect(ax, ay, w, h), mode); &#125;inline QGraphicsItem *QGraphicsView::itemAt(int ax, int ay) const&#123; return itemAt(QPoint(ax, ay)); &#125;inline QPointF QGraphicsView::mapToScene(int ax, int ay) const&#123; return mapToScene(QPoint(ax, ay)); &#125;inline QPolygonF QGraphicsView::mapToScene(int ax, int ay, int w, int h) const&#123; return mapToScene(QRect(ax, ay, w, h)); &#125;inline QPoint QGraphicsView::mapFromScene(qreal ax, qreal ay) const&#123; return mapFromScene(QPointF(ax, ay)); &#125;inline QPolygon QGraphicsView::mapFromScene(qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapFromScene(QRectF(ax, ay, w, h)); &#125;QT_END_NAMESPACE#endif // QGRAPHICSVIEW_H]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
        <tag>QtGraphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QGraphicsScene]]></title>
    <url>%2FQT%2Fqgraphicsscene%2F</url>
    <content type="text"><![CDATA[QGraphicsScene Header: #include qmake: QT += widgets Since: Qt 4.2 Inherits: QObject 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#ifndef QGRAPHICSSCENE_H#define QGRAPHICSSCENE_H#include &lt;QtWidgets/qtwidgetsglobal.h&gt;#include &lt;QtCore/qobject.h&gt;#include &lt;QtCore/qpoint.h&gt;#include &lt;QtCore/qrect.h&gt;#include &lt;QtGui/qbrush.h&gt;#include &lt;QtGui/qfont.h&gt;#include &lt;QtGui/qtransform.h&gt;#include &lt;QtGui/qpen.h&gt;QT_REQUIRE_CONFIG(graphicsview);QT_BEGIN_NAMESPACEtemplate&lt;typename T&gt; class QList;class QFocusEvent;class QFont;class QFontMetrics;class QGraphicsEllipseItem;class QGraphicsItem;class QGraphicsItemGroup;class QGraphicsLineItem;class QGraphicsPathItem;class QGraphicsPixmapItem;class QGraphicsPolygonItem;class QGraphicsProxyWidget;class QGraphicsRectItem;class QGraphicsSceneContextMenuEvent;class QGraphicsSceneDragDropEvent;class QGraphicsSceneEvent;class QGraphicsSceneHelpEvent;class QGraphicsSceneHoverEvent;class QGraphicsSceneMouseEvent;class QGraphicsSceneWheelEvent;class QGraphicsSimpleTextItem;class QGraphicsTextItem;class QGraphicsView;class QGraphicsWidget;class QGraphicsSceneIndex;class QHelpEvent;class QInputMethodEvent;class QKeyEvent;class QLineF;class QPainterPath;class QPixmap;class QPointF;class QPolygonF;class QRectF;class QSizeF;class QStyle;class QStyleOptionGraphicsItem;class QGraphicsScenePrivate;class Q_WIDGETS_EXPORT QGraphicsScene : public QObject&#123; Q_OBJECT Q_PROPERTY(QBrush backgroundBrush READ backgroundBrush WRITE setBackgroundBrush) Q_PROPERTY(QBrush foregroundBrush READ foregroundBrush WRITE setForegroundBrush) Q_PROPERTY(ItemIndexMethod itemIndexMethod READ itemIndexMethod WRITE setItemIndexMethod) Q_PROPERTY(QRectF sceneRect READ sceneRect WRITE setSceneRect) Q_PROPERTY(int bspTreeDepth READ bspTreeDepth WRITE setBspTreeDepth) Q_PROPERTY(QPalette palette READ palette WRITE setPalette) Q_PROPERTY(QFont font READ font WRITE setFont)#if QT_DEPRECATED_SINCE(5, 13) Q_PROPERTY(bool sortCacheEnabled READ isSortCacheEnabled WRITE setSortCacheEnabled)#endif Q_PROPERTY(bool stickyFocus READ stickyFocus WRITE setStickyFocus) Q_PROPERTY(qreal minimumRenderSize READ minimumRenderSize WRITE setMinimumRenderSize) Q_PROPERTY(bool focusOnTouch READ focusOnTouch WRITE setFocusOnTouch)public: enum ItemIndexMethod &#123; BspTreeIndex, NoIndex = -1 &#125;; Q_ENUM(ItemIndexMethod) enum SceneLayer &#123; ItemLayer = 0x1, BackgroundLayer = 0x2, ForegroundLayer = 0x4, AllLayers = 0xffff &#125;; Q_DECLARE_FLAGS(SceneLayers, SceneLayer) QGraphicsScene(QObject *parent = nullptr); QGraphicsScene(const QRectF &amp;sceneRect, QObject *parent = nullptr); QGraphicsScene(qreal x, qreal y, qreal width, qreal height, QObject *parent = nullptr); virtual ~QGraphicsScene(); QRectF sceneRect() const; inline qreal width() const &#123; return sceneRect().width(); &#125; inline qreal height() const &#123; return sceneRect().height(); &#125; void setSceneRect(const QRectF &amp;rect); inline void setSceneRect(qreal x, qreal y, qreal w, qreal h) &#123; setSceneRect(QRectF(x, y, w, h)); &#125; void render(QPainter *painter, const QRectF &amp;target = QRectF(), const QRectF &amp;source = QRectF(), Qt::AspectRatioMode aspectRatioMode = Qt::KeepAspectRatio); ItemIndexMethod itemIndexMethod() const; void setItemIndexMethod(ItemIndexMethod method);#if QT_DEPRECATED_SINCE(5, 13) QT_DEPRECATED bool isSortCacheEnabled() const; QT_DEPRECATED void setSortCacheEnabled(bool enabled);#endif int bspTreeDepth() const; void setBspTreeDepth(int depth); QRectF itemsBoundingRect() const; QList&lt;QGraphicsItem *&gt; items(Qt::SortOrder order = Qt::DescendingOrder) const; QList&lt;QGraphicsItem *&gt; items(const QPointF &amp;pos, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &amp;deviceTransform = QTransform()) const; QList&lt;QGraphicsItem *&gt; items(const QRectF &amp;rect, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &amp;deviceTransform = QTransform()) const; QList&lt;QGraphicsItem *&gt; items(const QPolygonF &amp;polygon, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &amp;deviceTransform = QTransform()) const; QList&lt;QGraphicsItem *&gt; items(const QPainterPath &amp;path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &amp;deviceTransform = QTransform()) const; QList&lt;QGraphicsItem *&gt; collidingItems(const QGraphicsItem *item, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;#if QT_DEPRECATED_SINCE(5, 0) QT_DEPRECATED inline QGraphicsItem *itemAt(const QPointF &amp;position) const &#123; QList&lt;QGraphicsItem *&gt; itemsAtPoint = items(position); return itemsAtPoint.isEmpty() ? nullptr : itemsAtPoint.first(); &#125;#endif QGraphicsItem *itemAt(const QPointF &amp;pos, const QTransform &amp;deviceTransform) const;#if QT_DEPRECATED_SINCE(5, 0) QT_DEPRECATED inline QList&lt;QGraphicsItem *&gt; items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const &#123; return items(QRectF(x, y, w, h), mode); &#125;#endif inline QList&lt;QGraphicsItem *&gt; items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &amp;deviceTransform = QTransform()) const &#123; return items(QRectF(x, y, w, h), mode, order, deviceTransform); &#125;#if QT_DEPRECATED_SINCE(5, 0) QT_DEPRECATED inline QGraphicsItem *itemAt(qreal x, qreal y) const &#123; QList&lt;QGraphicsItem *&gt; itemsAtPoint = items(QPointF(x, y)); return itemsAtPoint.isEmpty() ? nullptr : itemsAtPoint.first(); &#125;#endif inline QGraphicsItem *itemAt(qreal x, qreal y, const QTransform &amp;deviceTransform) const &#123; return itemAt(QPointF(x, y), deviceTransform); &#125; QList&lt;QGraphicsItem *&gt; selectedItems() const; QPainterPath selectionArea() const; void setSelectionArea(const QPainterPath &amp;path, const QTransform &amp;deviceTransform); void setSelectionArea(const QPainterPath &amp;path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, const QTransform &amp;deviceTransform = QTransform()); void setSelectionArea(const QPainterPath &amp;path, Qt::ItemSelectionOperation selectionOperation, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, const QTransform &amp;deviceTransform = QTransform()); // ### Qt6 merge the last 2 functions and add a default: Qt::ItemSelectionOperation selectionOperation = Qt::ReplaceSelection QGraphicsItemGroup *createItemGroup(const QList&lt;QGraphicsItem *&gt; &amp;items); void destroyItemGroup(QGraphicsItemGroup *group); void addItem(QGraphicsItem *item); QGraphicsEllipseItem *addEllipse(const QRectF &amp;rect, const QPen &amp;pen = QPen(), const QBrush &amp;brush = QBrush()); QGraphicsLineItem *addLine(const QLineF &amp;line, const QPen &amp;pen = QPen()); QGraphicsPathItem *addPath(const QPainterPath &amp;path, const QPen &amp;pen = QPen(), const QBrush &amp;brush = QBrush()); QGraphicsPixmapItem *addPixmap(const QPixmap &amp;pixmap); QGraphicsPolygonItem *addPolygon(const QPolygonF &amp;polygon, const QPen &amp;pen = QPen(), const QBrush &amp;brush = QBrush()); QGraphicsRectItem *addRect(const QRectF &amp;rect, const QPen &amp;pen = QPen(), const QBrush &amp;brush = QBrush()); QGraphicsTextItem *addText(const QString &amp;text, const QFont &amp;font = QFont()); QGraphicsSimpleTextItem *addSimpleText(const QString &amp;text, const QFont &amp;font = QFont()); QGraphicsProxyWidget *addWidget(QWidget *widget, Qt::WindowFlags wFlags = Qt::WindowFlags()); inline QGraphicsEllipseItem *addEllipse(qreal x, qreal y, qreal w, qreal h, const QPen &amp;pen = QPen(), const QBrush &amp;brush = QBrush()) &#123; return addEllipse(QRectF(x, y, w, h), pen, brush); &#125; inline QGraphicsLineItem *addLine(qreal x1, qreal y1, qreal x2, qreal y2, const QPen &amp;pen = QPen()) &#123; return addLine(QLineF(x1, y1, x2, y2), pen); &#125; inline QGraphicsRectItem *addRect(qreal x, qreal y, qreal w, qreal h, const QPen &amp;pen = QPen(), const QBrush &amp;brush = QBrush()) &#123; return addRect(QRectF(x, y, w, h), pen, brush); &#125; void removeItem(QGraphicsItem *item); QGraphicsItem *focusItem() const; void setFocusItem(QGraphicsItem *item, Qt::FocusReason focusReason = Qt::OtherFocusReason); bool hasFocus() const; void setFocus(Qt::FocusReason focusReason = Qt::OtherFocusReason); void clearFocus(); void setStickyFocus(bool enabled); bool stickyFocus() const; QGraphicsItem *mouseGrabberItem() const; QBrush backgroundBrush() const; void setBackgroundBrush(const QBrush &amp;brush); QBrush foregroundBrush() const; void setForegroundBrush(const QBrush &amp;brush); virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const; QList &lt;QGraphicsView *&gt; views() const; inline void update(qreal x, qreal y, qreal w, qreal h) &#123; update(QRectF(x, y, w, h)); &#125; inline void invalidate(qreal x, qreal y, qreal w, qreal h, SceneLayers layers = AllLayers) &#123; invalidate(QRectF(x, y, w, h), layers); &#125; QStyle *style() const; void setStyle(QStyle *style); QFont font() const; void setFont(const QFont &amp;font); QPalette palette() const; void setPalette(const QPalette &amp;palette); bool isActive() const; QGraphicsItem *activePanel() const; void setActivePanel(QGraphicsItem *item); QGraphicsWidget *activeWindow() const; void setActiveWindow(QGraphicsWidget *widget); bool sendEvent(QGraphicsItem *item, QEvent *event); qreal minimumRenderSize() const; void setMinimumRenderSize(qreal minSize); bool focusOnTouch() const; void setFocusOnTouch(bool enabled);public Q_SLOTS: void update(const QRectF &amp;rect = QRectF()); void invalidate(const QRectF &amp;rect = QRectF(), SceneLayers layers = AllLayers); void advance(); void clearSelection(); void clear();protected: bool event(QEvent *event) override; bool eventFilter(QObject *watched, QEvent *event) override; virtual void contextMenuEvent(QGraphicsSceneContextMenuEvent *event); virtual void dragEnterEvent(QGraphicsSceneDragDropEvent *event); virtual void dragMoveEvent(QGraphicsSceneDragDropEvent *event); virtual void dragLeaveEvent(QGraphicsSceneDragDropEvent *event); virtual void dropEvent(QGraphicsSceneDragDropEvent *event); virtual void focusInEvent(QFocusEvent *event); virtual void focusOutEvent(QFocusEvent *event); virtual void helpEvent(QGraphicsSceneHelpEvent *event); virtual void keyPressEvent(QKeyEvent *event); virtual void keyReleaseEvent(QKeyEvent *event); virtual void mousePressEvent(QGraphicsSceneMouseEvent *event); virtual void mouseMoveEvent(QGraphicsSceneMouseEvent *event); virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *event); virtual void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event); virtual void wheelEvent(QGraphicsSceneWheelEvent *event); virtual void inputMethodEvent(QInputMethodEvent *event); virtual void drawBackground(QPainter *painter, const QRectF &amp;rect); virtual void drawForeground(QPainter *painter, const QRectF &amp;rect); virtual void drawItems(QPainter *painter, int numItems, QGraphicsItem *items[], const QStyleOptionGraphicsItem options[], QWidget *widget = nullptr);protected Q_SLOTS: QT6_VIRTUAL bool focusNextPrevChild(bool next);Q_SIGNALS: void changed(const QList&lt;QRectF&gt; &amp;region); void sceneRectChanged(const QRectF &amp;rect); void selectionChanged(); void focusItemChanged(QGraphicsItem *newFocus, QGraphicsItem *oldFocus, Qt::FocusReason reason);private: Q_DECLARE_PRIVATE(QGraphicsScene) Q_DISABLE_COPY(QGraphicsScene) Q_PRIVATE_SLOT(d_func(), void _q_emitUpdated()) Q_PRIVATE_SLOT(d_func(), void _q_polishItems()) Q_PRIVATE_SLOT(d_func(), void _q_processDirtyItems()) Q_PRIVATE_SLOT(d_func(), void _q_updateScenePosDescendants()) friend class QGraphicsItem; friend class QGraphicsItemPrivate; friend class QGraphicsObject; friend class QGraphicsView; friend class QGraphicsViewPrivate; friend class QGraphicsWidget; friend class QGraphicsWidgetPrivate; friend class QGraphicsEffect; friend class QGraphicsSceneIndex; friend class QGraphicsSceneIndexPrivate; friend class QGraphicsSceneBspTreeIndex; friend class QGraphicsSceneBspTreeIndexPrivate; friend class QGraphicsItemEffectSourcePrivate;#ifndef QT_NO_GESTURES friend class QGesture;#endif&#125;;Q_DECLARE_OPERATORS_FOR_FLAGS(QGraphicsScene::SceneLayers)QT_END_NAMESPACE#endif]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
        <tag>QtGraphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QGraphicsItem]]></title>
    <url>%2FQT%2Fqgraphicsitem%2F</url>
    <content type="text"><![CDATA[QGraphicsItem Header: #include qmake: QT += widgets Since: Qt 4.2 Inherited By: QAbstractGraphicsShapeItem, QGraphicsItemGroup, QGraphicsLineItem, QGraphicsObject, and QGraphicsPixmapItem 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025#ifndef QGRAPHICSITEM_H#define QGRAPHICSITEM_H#include &lt;QtWidgets/qtwidgetsglobal.h&gt;#include &lt;QtCore/qobject.h&gt;#include &lt;QtCore/qvariant.h&gt;#include &lt;QtCore/qrect.h&gt;#include &lt;QtCore/qscopedpointer.h&gt;#include &lt;QtGui/qpainterpath.h&gt;#include &lt;QtGui/qpixmap.h&gt;class tst_QGraphicsItem;QT_REQUIRE_CONFIG(graphicsview);QT_BEGIN_NAMESPACEclass QBrush;class QCursor;class QFocusEvent;class QGraphicsEffect;class QGraphicsItemGroup;class QGraphicsObject;class QGraphicsSceneContextMenuEvent;class QGraphicsSceneDragDropEvent;class QGraphicsSceneEvent;class QGraphicsSceneHoverEvent;class QGraphicsSceneMouseEvent;class QGraphicsSceneWheelEvent;class QGraphicsScene;class QGraphicsTransform;class QGraphicsWidget;class QInputMethodEvent;class QKeyEvent;class QMatrix;class QMenu;class QPainter;class QPen;class QPointF;class QRectF;class QStyleOptionGraphicsItem;class QGraphicsItemPrivate;class Q_WIDGETS_EXPORT QGraphicsItem&#123;public: enum GraphicsItemFlag &#123; ItemIsMovable = 0x1, ItemIsSelectable = 0x2, ItemIsFocusable = 0x4, ItemClipsToShape = 0x8, ItemClipsChildrenToShape = 0x10, ItemIgnoresTransformations = 0x20, ItemIgnoresParentOpacity = 0x40, ItemDoesntPropagateOpacityToChildren = 0x80, ItemStacksBehindParent = 0x100, ItemUsesExtendedStyleOption = 0x200, ItemHasNoContents = 0x400, ItemSendsGeometryChanges = 0x800, ItemAcceptsInputMethod = 0x1000, ItemNegativeZStacksBehindParent = 0x2000, ItemIsPanel = 0x4000, ItemIsFocusScope = 0x8000, // internal ItemSendsScenePositionChanges = 0x10000, ItemStopsClickFocusPropagation = 0x20000, ItemStopsFocusHandling = 0x40000, ItemContainsChildrenInShape = 0x80000 // NB! Don't forget to increase the d_ptr-&gt;flags bit field by 1 when adding a new flag. &#125;; Q_DECLARE_FLAGS(GraphicsItemFlags, GraphicsItemFlag) enum GraphicsItemChange &#123; ItemPositionChange,#if QT_DEPRECATED_SINCE(5, 14) ItemMatrixChange Q_DECL_ENUMERATOR_DEPRECATED_X("Use ItemTransformChange instead"),#endif ItemVisibleChange = 2, ItemEnabledChange, ItemSelectedChange, ItemParentChange, ItemChildAddedChange, ItemChildRemovedChange, ItemTransformChange, ItemPositionHasChanged, ItemTransformHasChanged, ItemSceneChange, ItemVisibleHasChanged, ItemEnabledHasChanged, ItemSelectedHasChanged, ItemParentHasChanged, ItemSceneHasChanged, ItemCursorChange, ItemCursorHasChanged, ItemToolTipChange, ItemToolTipHasChanged, ItemFlagsChange, ItemFlagsHaveChanged, ItemZValueChange, ItemZValueHasChanged, ItemOpacityChange, ItemOpacityHasChanged, ItemScenePositionHasChanged, ItemRotationChange, ItemRotationHasChanged, ItemScaleChange, ItemScaleHasChanged, ItemTransformOriginPointChange, ItemTransformOriginPointHasChanged &#125;; enum CacheMode &#123; NoCache, ItemCoordinateCache, DeviceCoordinateCache &#125;; enum PanelModality &#123; NonModal, PanelModal, SceneModal &#125;; explicit QGraphicsItem(QGraphicsItem *parent = nullptr); virtual ~QGraphicsItem(); QGraphicsScene *scene() const; QGraphicsItem *parentItem() const; QGraphicsItem *topLevelItem() const; QGraphicsObject *parentObject() const; QGraphicsWidget *parentWidget() const; QGraphicsWidget *topLevelWidget() const; QGraphicsWidget *window() const; QGraphicsItem *panel() const; void setParentItem(QGraphicsItem *parent);#if QT_DEPRECATED_SINCE(5, 0) QT_DEPRECATED inline QList&lt;QGraphicsItem *&gt; children() const &#123; return childItems(); &#125;#endif QList&lt;QGraphicsItem *&gt; childItems() const; bool isWidget() const; bool isWindow() const; bool isPanel() const; QGraphicsObject *toGraphicsObject(); const QGraphicsObject *toGraphicsObject() const; QGraphicsItemGroup *group() const; void setGroup(QGraphicsItemGroup *group); GraphicsItemFlags flags() const; void setFlag(GraphicsItemFlag flag, bool enabled = true); void setFlags(GraphicsItemFlags flags); CacheMode cacheMode() const; void setCacheMode(CacheMode mode, const QSize &amp;cacheSize = QSize()); PanelModality panelModality() const; void setPanelModality(PanelModality panelModality); bool isBlockedByModalPanel(QGraphicsItem **blockingPanel = nullptr) const;#ifndef QT_NO_TOOLTIP QString toolTip() const; void setToolTip(const QString &amp;toolTip);#endif#ifndef QT_NO_CURSOR QCursor cursor() const; void setCursor(const QCursor &amp;cursor); bool hasCursor() const; void unsetCursor();#endif bool isVisible() const; bool isVisibleTo(const QGraphicsItem *parent) const; void setVisible(bool visible); inline void hide() &#123; setVisible(false); &#125; inline void show() &#123; setVisible(true); &#125; bool isEnabled() const; void setEnabled(bool enabled); bool isSelected() const; void setSelected(bool selected); bool acceptDrops() const; void setAcceptDrops(bool on); qreal opacity() const; qreal effectiveOpacity() const; void setOpacity(qreal opacity);#if QT_CONFIG(graphicseffect) // Effect QGraphicsEffect *graphicsEffect() const; void setGraphicsEffect(QGraphicsEffect *effect);#endif // QT_CONFIG(graphicseffect) Qt::MouseButtons acceptedMouseButtons() const; void setAcceptedMouseButtons(Qt::MouseButtons buttons);#if QT_DEPRECATED_SINCE(5, 0) QT_DEPRECATED inline bool acceptsHoverEvents() const &#123; return acceptHoverEvents(); &#125; QT_DEPRECATED inline void setAcceptsHoverEvents(bool enabled) &#123; setAcceptHoverEvents(enabled); &#125;#endif bool acceptHoverEvents() const; void setAcceptHoverEvents(bool enabled); bool acceptTouchEvents() const; void setAcceptTouchEvents(bool enabled); bool filtersChildEvents() const; void setFiltersChildEvents(bool enabled); bool handlesChildEvents() const; void setHandlesChildEvents(bool enabled); bool isActive() const; void setActive(bool active); bool hasFocus() const; void setFocus(Qt::FocusReason focusReason = Qt::OtherFocusReason); void clearFocus(); QGraphicsItem *focusProxy() const; void setFocusProxy(QGraphicsItem *item); QGraphicsItem *focusItem() const; QGraphicsItem *focusScopeItem() const; void grabMouse(); void ungrabMouse(); void grabKeyboard(); void ungrabKeyboard(); // Positioning in scene coordinates QPointF pos() const; inline qreal x() const &#123; return pos().x(); &#125; void setX(qreal x); inline qreal y() const &#123; return pos().y(); &#125; void setY(qreal y); QPointF scenePos() const; void setPos(const QPointF &amp;pos); inline void setPos(qreal x, qreal y); inline void moveBy(qreal dx, qreal dy) &#123; setPos(pos().x() + dx, pos().y() + dy); &#125; void ensureVisible(const QRectF &amp;rect = QRectF(), int xmargin = 50, int ymargin = 50); inline void ensureVisible(qreal x, qreal y, qreal w, qreal h, int xmargin = 50, int ymargin = 50); // Local transformation#if QT_DEPRECATED_SINCE(5, 13) QT_DEPRECATED_X("Use transform() instead") QMatrix matrix() const; QT_DEPRECATED_X("Use sceneTransform() instead") QMatrix sceneMatrix() const; QT_DEPRECATED_X("Use setTransform() instead") void setMatrix(const QMatrix &amp;matrix, bool combine = false); QT_DEPRECATED_X("Use resetTransform() instead") void resetMatrix();#endif QTransform transform() const; QTransform sceneTransform() const; QTransform deviceTransform(const QTransform &amp;viewportTransform) const; QTransform itemTransform(const QGraphicsItem *other, bool *ok = nullptr) const; void setTransform(const QTransform &amp;matrix, bool combine = false); void resetTransform();#if QT_DEPRECATED_SINCE(5, 0) QT_DEPRECATED inline void rotate(qreal angle) &#123; setTransform(QTransform().rotate(angle), true); &#125; QT_DEPRECATED inline void scale(qreal sx, qreal sy) &#123; setTransform(QTransform::fromScale(sx, sy), true); &#125; QT_DEPRECATED inline void shear(qreal sh, qreal sv) &#123; setTransform(QTransform().shear(sh, sv), true); &#125; QT_DEPRECATED inline void translate(qreal dx, qreal dy) &#123; setTransform(QTransform::fromTranslate(dx, dy), true); &#125;#endif void setRotation(qreal angle); qreal rotation() const; void setScale(qreal scale); qreal scale() const; QList&lt;QGraphicsTransform *&gt; transformations() const; void setTransformations(const QList&lt;QGraphicsTransform *&gt; &amp;transformations); QPointF transformOriginPoint() const; void setTransformOriginPoint(const QPointF &amp;origin); inline void setTransformOriginPoint(qreal ax, qreal ay) &#123; setTransformOriginPoint(QPointF(ax,ay)); &#125; virtual void advance(int phase); // Stacking order qreal zValue() const; void setZValue(qreal z); void stackBefore(const QGraphicsItem *sibling); // Hit test virtual QRectF boundingRect() const = 0; QRectF childrenBoundingRect() const; QRectF sceneBoundingRect() const; virtual QPainterPath shape() const; bool isClipped() const; QPainterPath clipPath() const; virtual bool contains(const QPointF &amp;point) const; virtual bool collidesWithItem(const QGraphicsItem *other, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const; virtual bool collidesWithPath(const QPainterPath &amp;path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const; QList&lt;QGraphicsItem *&gt; collidingItems(Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const; bool isObscured(const QRectF &amp;rect = QRectF()) const; inline bool isObscured(qreal x, qreal y, qreal w, qreal h) const; virtual bool isObscuredBy(const QGraphicsItem *item) const; virtual QPainterPath opaqueArea() const; QRegion boundingRegion(const QTransform &amp;itemToDeviceTransform) const; qreal boundingRegionGranularity() const; void setBoundingRegionGranularity(qreal granularity); // Drawing virtual void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) = 0; void update(const QRectF &amp;rect = QRectF()); inline void update(qreal x, qreal y, qreal width, qreal height); void scroll(qreal dx, qreal dy, const QRectF &amp;rect = QRectF()); // Coordinate mapping QPointF mapToItem(const QGraphicsItem *item, const QPointF &amp;point) const; QPointF mapToParent(const QPointF &amp;point) const; QPointF mapToScene(const QPointF &amp;point) const; QPolygonF mapToItem(const QGraphicsItem *item, const QRectF &amp;rect) const; QPolygonF mapToParent(const QRectF &amp;rect) const; QPolygonF mapToScene(const QRectF &amp;rect) const; QRectF mapRectToItem(const QGraphicsItem *item, const QRectF &amp;rect) const; QRectF mapRectToParent(const QRectF &amp;rect) const; QRectF mapRectToScene(const QRectF &amp;rect) const; QPolygonF mapToItem(const QGraphicsItem *item, const QPolygonF &amp;polygon) const; QPolygonF mapToParent(const QPolygonF &amp;polygon) const; QPolygonF mapToScene(const QPolygonF &amp;polygon) const; QPainterPath mapToItem(const QGraphicsItem *item, const QPainterPath &amp;path) const; QPainterPath mapToParent(const QPainterPath &amp;path) const; QPainterPath mapToScene(const QPainterPath &amp;path) const; QPointF mapFromItem(const QGraphicsItem *item, const QPointF &amp;point) const; QPointF mapFromParent(const QPointF &amp;point) const; QPointF mapFromScene(const QPointF &amp;point) const; QPolygonF mapFromItem(const QGraphicsItem *item, const QRectF &amp;rect) const; QPolygonF mapFromParent(const QRectF &amp;rect) const; QPolygonF mapFromScene(const QRectF &amp;rect) const; QRectF mapRectFromItem(const QGraphicsItem *item, const QRectF &amp;rect) const; QRectF mapRectFromParent(const QRectF &amp;rect) const; QRectF mapRectFromScene(const QRectF &amp;rect) const; QPolygonF mapFromItem(const QGraphicsItem *item, const QPolygonF &amp;polygon) const; QPolygonF mapFromParent(const QPolygonF &amp;polygon) const; QPolygonF mapFromScene(const QPolygonF &amp;polygon) const; QPainterPath mapFromItem(const QGraphicsItem *item, const QPainterPath &amp;path) const; QPainterPath mapFromParent(const QPainterPath &amp;path) const; QPainterPath mapFromScene(const QPainterPath &amp;path) const; inline QPointF mapToItem(const QGraphicsItem *item, qreal x, qreal y) const; inline QPointF mapToParent(qreal x, qreal y) const; inline QPointF mapToScene(qreal x, qreal y) const; inline QPolygonF mapToItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const; inline QPolygonF mapToParent(qreal x, qreal y, qreal w, qreal h) const; inline QPolygonF mapToScene(qreal x, qreal y, qreal w, qreal h) const; inline QRectF mapRectToItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const; inline QRectF mapRectToParent(qreal x, qreal y, qreal w, qreal h) const; inline QRectF mapRectToScene(qreal x, qreal y, qreal w, qreal h) const; inline QPointF mapFromItem(const QGraphicsItem *item, qreal x, qreal y) const; inline QPointF mapFromParent(qreal x, qreal y) const; inline QPointF mapFromScene(qreal x, qreal y) const; inline QPolygonF mapFromItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const; inline QPolygonF mapFromParent(qreal x, qreal y, qreal w, qreal h) const; inline QPolygonF mapFromScene(qreal x, qreal y, qreal w, qreal h) const; inline QRectF mapRectFromItem(const QGraphicsItem *item, qreal x, qreal y, qreal w, qreal h) const; inline QRectF mapRectFromParent(qreal x, qreal y, qreal w, qreal h) const; inline QRectF mapRectFromScene(qreal x, qreal y, qreal w, qreal h) const; bool isAncestorOf(const QGraphicsItem *child) const; QGraphicsItem *commonAncestorItem(const QGraphicsItem *other) const; bool isUnderMouse() const; // Custom data QVariant data(int key) const; void setData(int key, const QVariant &amp;value); Qt::InputMethodHints inputMethodHints() const; void setInputMethodHints(Qt::InputMethodHints hints); enum &#123; Type = 1, UserType = 65536 &#125;; virtual int type() const; void installSceneEventFilter(QGraphicsItem *filterItem); void removeSceneEventFilter(QGraphicsItem *filterItem);protected: void updateMicroFocus(); virtual bool sceneEventFilter(QGraphicsItem *watched, QEvent *event); virtual bool sceneEvent(QEvent *event); virtual void contextMenuEvent(QGraphicsSceneContextMenuEvent *event); virtual void dragEnterEvent(QGraphicsSceneDragDropEvent *event); virtual void dragLeaveEvent(QGraphicsSceneDragDropEvent *event); virtual void dragMoveEvent(QGraphicsSceneDragDropEvent *event); virtual void dropEvent(QGraphicsSceneDragDropEvent *event); virtual void focusInEvent(QFocusEvent *event); virtual void focusOutEvent(QFocusEvent *event); virtual void hoverEnterEvent(QGraphicsSceneHoverEvent *event); virtual void hoverMoveEvent(QGraphicsSceneHoverEvent *event); virtual void hoverLeaveEvent(QGraphicsSceneHoverEvent *event); virtual void keyPressEvent(QKeyEvent *event); virtual void keyReleaseEvent(QKeyEvent *event); virtual void mousePressEvent(QGraphicsSceneMouseEvent *event); virtual void mouseMoveEvent(QGraphicsSceneMouseEvent *event); virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *event); virtual void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event); virtual void wheelEvent(QGraphicsSceneWheelEvent *event); virtual void inputMethodEvent(QInputMethodEvent *event); virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const; virtual QVariant itemChange(GraphicsItemChange change, const QVariant &amp;value); enum Extension &#123; UserExtension = 0x80000000 &#125;; virtual bool supportsExtension(Extension extension) const; virtual void setExtension(Extension extension, const QVariant &amp;variant); virtual QVariant extension(const QVariant &amp;variant) const;protected: QGraphicsItem(QGraphicsItemPrivate &amp;dd, QGraphicsItem *parent); QScopedPointer&lt;QGraphicsItemPrivate&gt; d_ptr; void addToIndex(); void removeFromIndex(); void prepareGeometryChange();private: Q_DISABLE_COPY(QGraphicsItem) Q_DECLARE_PRIVATE(QGraphicsItem) friend class QGraphicsItemGroup; friend class QGraphicsScene; friend class QGraphicsScenePrivate; friend class QGraphicsSceneFindItemBspTreeVisitor; friend class QGraphicsSceneBspTree; friend class QGraphicsView; friend class QGraphicsViewPrivate; friend class QGraphicsObject; friend class QGraphicsWidget; friend class QGraphicsWidgetPrivate; friend class QGraphicsProxyWidgetPrivate; friend class QGraphicsSceneIndex; friend class QGraphicsSceneIndexPrivate; friend class QGraphicsSceneBspTreeIndex; friend class QGraphicsSceneBspTreeIndexPrivate; friend class QGraphicsItemEffectSourcePrivate; friend class QGraphicsTransformPrivate;#ifndef QT_NO_GESTURES friend class QGestureManager;#endif friend class ::tst_QGraphicsItem; friend bool qt_closestLeaf(const QGraphicsItem *, const QGraphicsItem *); friend bool qt_closestItemFirst(const QGraphicsItem *, const QGraphicsItem *);&#125;;Q_DECLARE_OPERATORS_FOR_FLAGS(QGraphicsItem::GraphicsItemFlags)#ifndef Q_CLANG_QDOCQ_DECLARE_INTERFACE(QGraphicsItem, "org.qt-project.Qt.QGraphicsItem")#endifinline void QGraphicsItem::setPos(qreal ax, qreal ay)&#123; setPos(QPointF(ax, ay)); &#125;inline void QGraphicsItem::ensureVisible(qreal ax, qreal ay, qreal w, qreal h, int xmargin, int ymargin)&#123; ensureVisible(QRectF(ax, ay, w, h), xmargin, ymargin); &#125;inline void QGraphicsItem::update(qreal ax, qreal ay, qreal width, qreal height)&#123; update(QRectF(ax, ay, width, height)); &#125;inline bool QGraphicsItem::isObscured(qreal ax, qreal ay, qreal w, qreal h) const&#123; return isObscured(QRectF(ax, ay, w, h)); &#125;inline QPointF QGraphicsItem::mapToItem(const QGraphicsItem *item, qreal ax, qreal ay) const&#123; return mapToItem(item, QPointF(ax, ay)); &#125;inline QPointF QGraphicsItem::mapToParent(qreal ax, qreal ay) const&#123; return mapToParent(QPointF(ax, ay)); &#125;inline QPointF QGraphicsItem::mapToScene(qreal ax, qreal ay) const&#123; return mapToScene(QPointF(ax, ay)); &#125;inline QPointF QGraphicsItem::mapFromItem(const QGraphicsItem *item, qreal ax, qreal ay) const&#123; return mapFromItem(item, QPointF(ax, ay)); &#125;inline QPointF QGraphicsItem::mapFromParent(qreal ax, qreal ay) const&#123; return mapFromParent(QPointF(ax, ay)); &#125;inline QPointF QGraphicsItem::mapFromScene(qreal ax, qreal ay) const&#123; return mapFromScene(QPointF(ax, ay)); &#125;inline QPolygonF QGraphicsItem::mapToItem(const QGraphicsItem *item, qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapToItem(item, QRectF(ax, ay, w, h)); &#125;inline QPolygonF QGraphicsItem::mapToParent(qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapToParent(QRectF(ax, ay, w, h)); &#125;inline QPolygonF QGraphicsItem::mapToScene(qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapToScene(QRectF(ax, ay, w, h)); &#125;inline QRectF QGraphicsItem::mapRectToItem(const QGraphicsItem *item, qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapRectToItem(item, QRectF(ax, ay, w, h)); &#125;inline QRectF QGraphicsItem::mapRectToParent(qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapRectToParent(QRectF(ax, ay, w, h)); &#125;inline QRectF QGraphicsItem::mapRectToScene(qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapRectToScene(QRectF(ax, ay, w, h)); &#125;inline QPolygonF QGraphicsItem::mapFromItem(const QGraphicsItem *item, qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapFromItem(item, QRectF(ax, ay, w, h)); &#125;inline QPolygonF QGraphicsItem::mapFromParent(qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapFromParent(QRectF(ax, ay, w, h)); &#125;inline QPolygonF QGraphicsItem::mapFromScene(qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapFromScene(QRectF(ax, ay, w, h)); &#125;inline QRectF QGraphicsItem::mapRectFromItem(const QGraphicsItem *item, qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapRectFromItem(item, QRectF(ax, ay, w, h)); &#125;inline QRectF QGraphicsItem::mapRectFromParent(qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapRectFromParent(QRectF(ax, ay, w, h)); &#125;inline QRectF QGraphicsItem::mapRectFromScene(qreal ax, qreal ay, qreal w, qreal h) const&#123; return mapRectFromScene(QRectF(ax, ay, w, h)); &#125;class Q_WIDGETS_EXPORT QGraphicsObject : public QObject, public QGraphicsItem&#123; Q_OBJECT Q_PROPERTY(QGraphicsObject* parent READ parentObject WRITE setParentItem NOTIFY parentChanged DESIGNABLE false) Q_PROPERTY(qreal opacity READ opacity WRITE setOpacity NOTIFY opacityChanged FINAL) Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled NOTIFY enabledChanged) Q_PROPERTY(bool visible READ isVisible WRITE setVisible NOTIFY visibleChanged FINAL) Q_PROPERTY(QPointF pos READ pos WRITE setPos FINAL) Q_PROPERTY(qreal x READ x WRITE setX NOTIFY xChanged FINAL) Q_PROPERTY(qreal y READ y WRITE setY NOTIFY yChanged FINAL) Q_PROPERTY(qreal z READ zValue WRITE setZValue NOTIFY zChanged FINAL) Q_PROPERTY(qreal rotation READ rotation WRITE setRotation NOTIFY rotationChanged) Q_PROPERTY(qreal scale READ scale WRITE setScale NOTIFY scaleChanged) Q_PROPERTY(QPointF transformOriginPoint READ transformOriginPoint WRITE setTransformOriginPoint)#if QT_CONFIG(graphicseffect) Q_PROPERTY(QGraphicsEffect *effect READ graphicsEffect WRITE setGraphicsEffect)#endif Q_PRIVATE_PROPERTY(QGraphicsItem::d_func(), QDeclarativeListProperty&lt;QGraphicsObject&gt; children READ childrenList DESIGNABLE false NOTIFY childrenChanged) Q_PRIVATE_PROPERTY(QGraphicsItem::d_func(), qreal width READ width WRITE setWidth NOTIFY widthChanged RESET resetWidth FINAL) Q_PRIVATE_PROPERTY(QGraphicsItem::d_func(), qreal height READ height WRITE setHeight NOTIFY heightChanged RESET resetHeight FINAL) Q_CLASSINFO("DefaultProperty", "children") Q_INTERFACES(QGraphicsItem)public: explicit QGraphicsObject(QGraphicsItem *parent = nullptr); ~QGraphicsObject(); using QObject::children;#ifndef QT_NO_GESTURES void grabGesture(Qt::GestureType type, Qt::GestureFlags flags = Qt::GestureFlags()); void ungrabGesture(Qt::GestureType type);#endifprotected Q_SLOTS: void updateMicroFocus();Q_SIGNALS: void parentChanged(); void opacityChanged(); void visibleChanged(); void enabledChanged(); void xChanged(); void yChanged(); void zChanged(); void rotationChanged(); void scaleChanged(); void childrenChanged(); void widthChanged(); void heightChanged();protected: QGraphicsObject(QGraphicsItemPrivate &amp;dd, QGraphicsItem *parent); bool event(QEvent *ev) override;private: friend class QGraphicsItem; friend class QGraphicsItemPrivate;&#125;;class QAbstractGraphicsShapeItemPrivate;class Q_WIDGETS_EXPORT QAbstractGraphicsShapeItem : public QGraphicsItem&#123;public: explicit QAbstractGraphicsShapeItem(QGraphicsItem *parent = nullptr); ~QAbstractGraphicsShapeItem(); QPen pen() const; void setPen(const QPen &amp;pen); QBrush brush() const; void setBrush(const QBrush &amp;brush); bool isObscuredBy(const QGraphicsItem *item) const override; QPainterPath opaqueArea() const override;protected: QAbstractGraphicsShapeItem(QAbstractGraphicsShapeItemPrivate &amp;dd, QGraphicsItem *parent);private: Q_DISABLE_COPY(QAbstractGraphicsShapeItem) Q_DECLARE_PRIVATE(QAbstractGraphicsShapeItem)&#125;;class QGraphicsPathItemPrivate;class Q_WIDGETS_EXPORT QGraphicsPathItem : public QAbstractGraphicsShapeItem&#123;public: explicit QGraphicsPathItem(QGraphicsItem *parent = nullptr); explicit QGraphicsPathItem(const QPainterPath &amp;path, QGraphicsItem *parent = nullptr); ~QGraphicsPathItem(); QPainterPath path() const; void setPath(const QPainterPath &amp;path); QRectF boundingRect() const override; QPainterPath shape() const override; bool contains(const QPointF &amp;point) const override; void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) override; bool isObscuredBy(const QGraphicsItem *item) const override; QPainterPath opaqueArea() const override; enum &#123; Type = 2 &#125;; int type() const override;protected: bool supportsExtension(Extension extension) const override; void setExtension(Extension extension, const QVariant &amp;variant) override; QVariant extension(const QVariant &amp;variant) const override;private: Q_DISABLE_COPY(QGraphicsPathItem) Q_DECLARE_PRIVATE(QGraphicsPathItem)&#125;;class QGraphicsRectItemPrivate;class Q_WIDGETS_EXPORT QGraphicsRectItem : public QAbstractGraphicsShapeItem&#123;public: explicit QGraphicsRectItem(QGraphicsItem *parent = nullptr); explicit QGraphicsRectItem(const QRectF &amp;rect, QGraphicsItem *parent = nullptr); explicit QGraphicsRectItem(qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent = nullptr); ~QGraphicsRectItem(); QRectF rect() const; void setRect(const QRectF &amp;rect); inline void setRect(qreal x, qreal y, qreal w, qreal h); QRectF boundingRect() const override; QPainterPath shape() const override; bool contains(const QPointF &amp;point) const override; void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) override; bool isObscuredBy(const QGraphicsItem *item) const override; QPainterPath opaqueArea() const override; enum &#123; Type = 3 &#125;; int type() const override;protected: bool supportsExtension(Extension extension) const override; void setExtension(Extension extension, const QVariant &amp;variant) override; QVariant extension(const QVariant &amp;variant) const override;private: Q_DISABLE_COPY(QGraphicsRectItem) Q_DECLARE_PRIVATE(QGraphicsRectItem)&#125;;inline void QGraphicsRectItem::setRect(qreal ax, qreal ay, qreal w, qreal h)&#123; setRect(QRectF(ax, ay, w, h)); &#125;class QGraphicsEllipseItemPrivate;class Q_WIDGETS_EXPORT QGraphicsEllipseItem : public QAbstractGraphicsShapeItem&#123;public: explicit QGraphicsEllipseItem(QGraphicsItem *parent = nullptr); explicit QGraphicsEllipseItem(const QRectF &amp;rect, QGraphicsItem *parent = nullptr); explicit QGraphicsEllipseItem(qreal x, qreal y, qreal w, qreal h, QGraphicsItem *parent = nullptr); ~QGraphicsEllipseItem(); QRectF rect() const; void setRect(const QRectF &amp;rect); inline void setRect(qreal x, qreal y, qreal w, qreal h); int startAngle() const; void setStartAngle(int angle); int spanAngle() const; void setSpanAngle(int angle); QRectF boundingRect() const override; QPainterPath shape() const override; bool contains(const QPointF &amp;point) const override; void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) override; bool isObscuredBy(const QGraphicsItem *item) const override; QPainterPath opaqueArea() const override; enum &#123; Type = 4 &#125;; int type() const override;protected: bool supportsExtension(Extension extension) const override; void setExtension(Extension extension, const QVariant &amp;variant) override; QVariant extension(const QVariant &amp;variant) const override;private: Q_DISABLE_COPY(QGraphicsEllipseItem) Q_DECLARE_PRIVATE(QGraphicsEllipseItem)&#125;;inline void QGraphicsEllipseItem::setRect(qreal ax, qreal ay, qreal w, qreal h)&#123; setRect(QRectF(ax, ay, w, h)); &#125;class QGraphicsPolygonItemPrivate;class Q_WIDGETS_EXPORT QGraphicsPolygonItem : public QAbstractGraphicsShapeItem&#123;public: explicit QGraphicsPolygonItem(QGraphicsItem *parent = nullptr); explicit QGraphicsPolygonItem(const QPolygonF &amp;polygon, QGraphicsItem *parent = nullptr); ~QGraphicsPolygonItem(); QPolygonF polygon() const; void setPolygon(const QPolygonF &amp;polygon); Qt::FillRule fillRule() const; void setFillRule(Qt::FillRule rule); QRectF boundingRect() const override; QPainterPath shape() const override; bool contains(const QPointF &amp;point) const override; void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) override; bool isObscuredBy(const QGraphicsItem *item) const override; QPainterPath opaqueArea() const override; enum &#123; Type = 5 &#125;; int type() const override;protected: bool supportsExtension(Extension extension) const override; void setExtension(Extension extension, const QVariant &amp;variant) override; QVariant extension(const QVariant &amp;variant) const override;private: Q_DISABLE_COPY(QGraphicsPolygonItem) Q_DECLARE_PRIVATE(QGraphicsPolygonItem)&#125;;class QGraphicsLineItemPrivate;class Q_WIDGETS_EXPORT QGraphicsLineItem : public QGraphicsItem&#123;public: explicit QGraphicsLineItem(QGraphicsItem *parent = nullptr); explicit QGraphicsLineItem(const QLineF &amp;line, QGraphicsItem *parent = nullptr); explicit QGraphicsLineItem(qreal x1, qreal y1, qreal x2, qreal y2, QGraphicsItem *parent = nullptr); ~QGraphicsLineItem(); QPen pen() const; void setPen(const QPen &amp;pen); QLineF line() const; void setLine(const QLineF &amp;line); inline void setLine(qreal x1, qreal y1, qreal x2, qreal y2) &#123; setLine(QLineF(x1, y1, x2, y2)); &#125; QRectF boundingRect() const override; QPainterPath shape() const override; bool contains(const QPointF &amp;point) const override; void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) override; bool isObscuredBy(const QGraphicsItem *item) const override; QPainterPath opaqueArea() const override; enum &#123; Type = 6 &#125;; int type() const override;protected: bool supportsExtension(Extension extension) const override; void setExtension(Extension extension, const QVariant &amp;variant) override; QVariant extension(const QVariant &amp;variant) const override;private: Q_DISABLE_COPY(QGraphicsLineItem) Q_DECLARE_PRIVATE(QGraphicsLineItem)&#125;;class QGraphicsPixmapItemPrivate;class Q_WIDGETS_EXPORT QGraphicsPixmapItem : public QGraphicsItem&#123;public: enum ShapeMode &#123; MaskShape, BoundingRectShape, HeuristicMaskShape &#125;; explicit QGraphicsPixmapItem(QGraphicsItem *parent = nullptr); explicit QGraphicsPixmapItem(const QPixmap &amp;pixmap, QGraphicsItem *parent = nullptr); ~QGraphicsPixmapItem(); QPixmap pixmap() const; void setPixmap(const QPixmap &amp;pixmap); Qt::TransformationMode transformationMode() const; void setTransformationMode(Qt::TransformationMode mode); QPointF offset() const; void setOffset(const QPointF &amp;offset); inline void setOffset(qreal x, qreal y); QRectF boundingRect() const override; QPainterPath shape() const override; bool contains(const QPointF &amp;point) const override; void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override; bool isObscuredBy(const QGraphicsItem *item) const override; QPainterPath opaqueArea() const override; enum &#123; Type = 7 &#125;; int type() const override; ShapeMode shapeMode() const; void setShapeMode(ShapeMode mode);protected: bool supportsExtension(Extension extension) const override; void setExtension(Extension extension, const QVariant &amp;variant) override; QVariant extension(const QVariant &amp;variant) const override;private: Q_DISABLE_COPY(QGraphicsPixmapItem) Q_DECLARE_PRIVATE(QGraphicsPixmapItem)&#125;;inline void QGraphicsPixmapItem::setOffset(qreal ax, qreal ay)&#123; setOffset(QPointF(ax, ay)); &#125;class QGraphicsTextItemPrivate;class QTextDocument;class QTextCursor;class Q_WIDGETS_EXPORT QGraphicsTextItem : public QGraphicsObject&#123; Q_OBJECT QDOC_PROPERTY(bool openExternalLinks READ openExternalLinks WRITE setOpenExternalLinks) QDOC_PROPERTY(QTextCursor textCursor READ textCursor WRITE setTextCursor)public: explicit QGraphicsTextItem(QGraphicsItem *parent = nullptr); explicit QGraphicsTextItem(const QString &amp;text, QGraphicsItem *parent = nullptr); ~QGraphicsTextItem(); QString toHtml() const; void setHtml(const QString &amp;html); QString toPlainText() const; void setPlainText(const QString &amp;text); QFont font() const; void setFont(const QFont &amp;font); void setDefaultTextColor(const QColor &amp;c); QColor defaultTextColor() const; QRectF boundingRect() const override; QPainterPath shape() const override; bool contains(const QPointF &amp;point) const override; void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override; bool isObscuredBy(const QGraphicsItem *item) const override; QPainterPath opaqueArea() const override; enum &#123; Type = 8 &#125;; int type() const override; void setTextWidth(qreal width); qreal textWidth() const; void adjustSize(); void setDocument(QTextDocument *document); QTextDocument *document() const; void setTextInteractionFlags(Qt::TextInteractionFlags flags); Qt::TextInteractionFlags textInteractionFlags() const; void setTabChangesFocus(bool b); bool tabChangesFocus() const; void setOpenExternalLinks(bool open); bool openExternalLinks() const; void setTextCursor(const QTextCursor &amp;cursor); QTextCursor textCursor() const;Q_SIGNALS: void linkActivated(const QString &amp;); void linkHovered(const QString &amp;);protected: bool sceneEvent(QEvent *event) override; void mousePressEvent(QGraphicsSceneMouseEvent *event) override; void mouseMoveEvent(QGraphicsSceneMouseEvent *event) override; void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override; void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event) override; void contextMenuEvent(QGraphicsSceneContextMenuEvent *event) override; void keyPressEvent(QKeyEvent *event) override; void keyReleaseEvent(QKeyEvent *event) override; void focusInEvent(QFocusEvent *event) override; void focusOutEvent(QFocusEvent *event) override; void dragEnterEvent(QGraphicsSceneDragDropEvent *event) override; void dragLeaveEvent(QGraphicsSceneDragDropEvent *event) override; void dragMoveEvent(QGraphicsSceneDragDropEvent *event) override; void dropEvent(QGraphicsSceneDragDropEvent *event) override; void inputMethodEvent(QInputMethodEvent *event) override; void hoverEnterEvent(QGraphicsSceneHoverEvent *event) override; void hoverMoveEvent(QGraphicsSceneHoverEvent *event) override; void hoverLeaveEvent(QGraphicsSceneHoverEvent *event) override; QVariant inputMethodQuery(Qt::InputMethodQuery query) const override; bool supportsExtension(Extension extension) const override; void setExtension(Extension extension, const QVariant &amp;variant) override; QVariant extension(const QVariant &amp;variant) const override;private: Q_DISABLE_COPY(QGraphicsTextItem) Q_PRIVATE_SLOT(dd, void _q_updateBoundingRect(const QSizeF &amp;)) Q_PRIVATE_SLOT(dd, void _q_update(QRectF)) Q_PRIVATE_SLOT(dd, void _q_ensureVisible(QRectF)) QGraphicsTextItemPrivate *dd; friend class QGraphicsTextItemPrivate;&#125;;class QGraphicsSimpleTextItemPrivate;class Q_WIDGETS_EXPORT QGraphicsSimpleTextItem : public QAbstractGraphicsShapeItem&#123;public: explicit QGraphicsSimpleTextItem(QGraphicsItem *parent = nullptr); explicit QGraphicsSimpleTextItem(const QString &amp;text, QGraphicsItem *parent = nullptr); ~QGraphicsSimpleTextItem(); void setText(const QString &amp;text); QString text() const; void setFont(const QFont &amp;font); QFont font() const; QRectF boundingRect() const override; QPainterPath shape() const override; bool contains(const QPointF &amp;point) const override; void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override; bool isObscuredBy(const QGraphicsItem *item) const override; QPainterPath opaqueArea() const override; enum &#123; Type = 9 &#125;; int type() const override;protected: bool supportsExtension(Extension extension) const override; void setExtension(Extension extension, const QVariant &amp;variant) override; QVariant extension(const QVariant &amp;variant) const override;private: Q_DISABLE_COPY(QGraphicsSimpleTextItem) Q_DECLARE_PRIVATE(QGraphicsSimpleTextItem)&#125;;class QGraphicsItemGroupPrivate;class Q_WIDGETS_EXPORT QGraphicsItemGroup : public QGraphicsItem&#123;public: explicit QGraphicsItemGroup(QGraphicsItem *parent = nullptr); ~QGraphicsItemGroup(); void addToGroup(QGraphicsItem *item); void removeFromGroup(QGraphicsItem *item); QRectF boundingRect() const override; void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget = nullptr) override; bool isObscuredBy(const QGraphicsItem *item) const override; QPainterPath opaqueArea() const override; enum &#123; Type = 10 &#125;; int type() const override;private: Q_DISABLE_COPY(QGraphicsItemGroup) Q_DECLARE_PRIVATE(QGraphicsItemGroup)&#125;;template &lt;class T&gt; inline T qgraphicsitem_cast(QGraphicsItem *item)&#123; typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type Item; return int(Item::Type) == int(QGraphicsItem::Type) || (item &amp;&amp; int(Item::Type) == item-&gt;type()) ? static_cast&lt;T&gt;(item) : 0;&#125;template &lt;class T&gt; inline T qgraphicsitem_cast(const QGraphicsItem *item)&#123; typedef typename std::remove_cv&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::type Item; return int(Item::Type) == int(QGraphicsItem::Type) || (item &amp;&amp; int(Item::Type) == item-&gt;type()) ? static_cast&lt;T&gt;(item) : 0;&#125;#ifndef QT_NO_DEBUG_STREAMQ_WIDGETS_EXPORT QDebug operator&lt;&lt;(QDebug debug, QGraphicsItem *item);Q_WIDGETS_EXPORT QDebug operator&lt;&lt;(QDebug debug, QGraphicsObject *item);Q_WIDGETS_EXPORT QDebug operator&lt;&lt;(QDebug debug, QGraphicsItem::GraphicsItemChange change);Q_WIDGETS_EXPORT QDebug operator&lt;&lt;(QDebug debug, QGraphicsItem::GraphicsItemFlag flag);Q_WIDGETS_EXPORT QDebug operator&lt;&lt;(QDebug debug, QGraphicsItem::GraphicsItemFlags flags);#endifQT_END_NAMESPACEQ_DECLARE_METATYPE(QGraphicsItem *)QT_BEGIN_NAMESPACEQT_END_NAMESPACE#endif // QGRAPHICSITEM_H]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
        <tag>QtGraphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QAbstractitemView]]></title>
    <url>%2FQT%2Fqabstractitemview%2F</url>
    <content type="text"><![CDATA[QAbstractItemView给view提供基础方法的抽象类，可通过信号与槽和model进行交互 Header: #include qmake: QT += widgets Inherits: QAbstractScrollArea Inherited By: QColumnView, QHeaderView, QListView, QTableView, and QTreeView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350#ifndef QABSTRACTITEMVIEW_H#define QABSTRACTITEMVIEW_H#include &lt;QtWidgets/qtwidgetsglobal.h&gt;#include &lt;QtWidgets/qabstractscrollarea.h&gt;#include &lt;QtCore/qabstractitemmodel.h&gt;#include &lt;QtCore/qitemselectionmodel.h&gt;#include &lt;QtWidgets/qabstractitemdelegate.h&gt;class tst_QAbstractItemView;class tst_QTreeView;QT_REQUIRE_CONFIG(itemviews);QT_BEGIN_NAMESPACEclass QMenu;class QDrag;class QEvent;class QAbstractItemViewPrivate;class Q_WIDGETS_EXPORT QAbstractItemView : public QAbstractScrollArea&#123; Q_OBJECT Q_PROPERTY(bool autoScroll READ hasAutoScroll WRITE setAutoScroll) Q_PROPERTY(int autoScrollMargin READ autoScrollMargin WRITE setAutoScrollMargin) Q_PROPERTY(EditTriggers editTriggers READ editTriggers WRITE setEditTriggers) Q_PROPERTY(bool tabKeyNavigation READ tabKeyNavigation WRITE setTabKeyNavigation)#if QT_CONFIG(draganddrop) Q_PROPERTY(bool showDropIndicator READ showDropIndicator WRITE setDropIndicatorShown) Q_PROPERTY(bool dragEnabled READ dragEnabled WRITE setDragEnabled) Q_PROPERTY(bool dragDropOverwriteMode READ dragDropOverwriteMode WRITE setDragDropOverwriteMode) Q_PROPERTY(DragDropMode dragDropMode READ dragDropMode WRITE setDragDropMode) Q_PROPERTY(Qt::DropAction defaultDropAction READ defaultDropAction WRITE setDefaultDropAction)#endif Q_PROPERTY(bool alternatingRowColors READ alternatingRowColors WRITE setAlternatingRowColors) Q_PROPERTY(SelectionMode selectionMode READ selectionMode WRITE setSelectionMode) Q_PROPERTY(SelectionBehavior selectionBehavior READ selectionBehavior WRITE setSelectionBehavior) Q_PROPERTY(QSize iconSize READ iconSize WRITE setIconSize NOTIFY iconSizeChanged) Q_PROPERTY(Qt::TextElideMode textElideMode READ textElideMode WRITE setTextElideMode) Q_PROPERTY(ScrollMode verticalScrollMode READ verticalScrollMode WRITE setVerticalScrollMode RESET resetVerticalScrollMode) Q_PROPERTY(ScrollMode horizontalScrollMode READ horizontalScrollMode WRITE setHorizontalScrollMode RESET resetHorizontalScrollMode)public: enum SelectionMode &#123; NoSelection, SingleSelection, MultiSelection, ExtendedSelection, ContiguousSelection &#125;; Q_ENUM(SelectionMode) enum SelectionBehavior &#123; SelectItems, SelectRows, SelectColumns &#125;; Q_ENUM(SelectionBehavior) enum ScrollHint &#123; EnsureVisible, PositionAtTop, PositionAtBottom, PositionAtCenter &#125;; Q_ENUM(ScrollHint) enum EditTrigger &#123; NoEditTriggers = 0, CurrentChanged = 1, DoubleClicked = 2, SelectedClicked = 4, EditKeyPressed = 8, AnyKeyPressed = 16, AllEditTriggers = 31 &#125;; Q_DECLARE_FLAGS(EditTriggers, EditTrigger) Q_FLAG(EditTriggers) enum ScrollMode &#123; ScrollPerItem, ScrollPerPixel &#125;; Q_ENUM(ScrollMode) explicit QAbstractItemView(QWidget *parent = nullptr); ~QAbstractItemView(); virtual void setModel(QAbstractItemModel *model); QAbstractItemModel *model() const; virtual void setSelectionModel(QItemSelectionModel *selectionModel); QItemSelectionModel *selectionModel() const; void setItemDelegate(QAbstractItemDelegate *delegate); QAbstractItemDelegate *itemDelegate() const; void setSelectionMode(QAbstractItemView::SelectionMode mode); QAbstractItemView::SelectionMode selectionMode() const; void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior); QAbstractItemView::SelectionBehavior selectionBehavior() const; QModelIndex currentIndex() const; QModelIndex rootIndex() const; void setEditTriggers(EditTriggers triggers); EditTriggers editTriggers() const; void setVerticalScrollMode(ScrollMode mode); ScrollMode verticalScrollMode() const; void resetVerticalScrollMode(); void setHorizontalScrollMode(ScrollMode mode); ScrollMode horizontalScrollMode() const; void resetHorizontalScrollMode(); void setAutoScroll(bool enable); bool hasAutoScroll() const; void setAutoScrollMargin(int margin); int autoScrollMargin() const; void setTabKeyNavigation(bool enable); bool tabKeyNavigation() const;#if QT_CONFIG(draganddrop) void setDropIndicatorShown(bool enable); bool showDropIndicator() const; void setDragEnabled(bool enable); bool dragEnabled() const; void setDragDropOverwriteMode(bool overwrite); bool dragDropOverwriteMode() const; enum DragDropMode &#123; NoDragDrop, DragOnly, DropOnly, DragDrop, InternalMove &#125;; Q_ENUM(DragDropMode) void setDragDropMode(DragDropMode behavior); DragDropMode dragDropMode() const; void setDefaultDropAction(Qt::DropAction dropAction); Qt::DropAction defaultDropAction() const;#endif void setAlternatingRowColors(bool enable); bool alternatingRowColors() const; void setIconSize(const QSize &amp;size); QSize iconSize() const; void setTextElideMode(Qt::TextElideMode mode); Qt::TextElideMode textElideMode() const; virtual void keyboardSearch(const QString &amp;search); virtual QRect visualRect(const QModelIndex &amp;index) const = 0; virtual void scrollTo(const QModelIndex &amp;index, ScrollHint hint = EnsureVisible) = 0; virtual QModelIndex indexAt(const QPoint &amp;point) const = 0; QSize sizeHintForIndex(const QModelIndex &amp;index) const; virtual int sizeHintForRow(int row) const; virtual int sizeHintForColumn(int column) const; void openPersistentEditor(const QModelIndex &amp;index); void closePersistentEditor(const QModelIndex &amp;index); bool isPersistentEditorOpen(const QModelIndex &amp;index) const; void setIndexWidget(const QModelIndex &amp;index, QWidget *widget); QWidget *indexWidget(const QModelIndex &amp;index) const; void setItemDelegateForRow(int row, QAbstractItemDelegate *delegate); QAbstractItemDelegate *itemDelegateForRow(int row) const; void setItemDelegateForColumn(int column, QAbstractItemDelegate *delegate); QAbstractItemDelegate *itemDelegateForColumn(int column) const; QAbstractItemDelegate *itemDelegate(const QModelIndex &amp;index) const; virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const override; using QAbstractScrollArea::update;public Q_SLOTS: virtual void reset(); virtual void setRootIndex(const QModelIndex &amp;index); virtual void doItemsLayout(); virtual void selectAll(); void edit(const QModelIndex &amp;index); void clearSelection(); void setCurrentIndex(const QModelIndex &amp;index); void scrollToTop(); void scrollToBottom(); void update(const QModelIndex &amp;index);protected Q_SLOTS: virtual void dataChanged(const QModelIndex &amp;topLeft, const QModelIndex &amp;bottomRight, const QVector&lt;int&gt; &amp;roles = QVector&lt;int&gt;()); virtual void rowsInserted(const QModelIndex &amp;parent, int start, int end); virtual void rowsAboutToBeRemoved(const QModelIndex &amp;parent, int start, int end); virtual void selectionChanged(const QItemSelection &amp;selected, const QItemSelection &amp;deselected); virtual void currentChanged(const QModelIndex &amp;current, const QModelIndex &amp;previous); virtual void updateEditorData(); virtual void updateEditorGeometries(); virtual void updateGeometries(); virtual void verticalScrollbarAction(int action); virtual void horizontalScrollbarAction(int action); virtual void verticalScrollbarValueChanged(int value); virtual void horizontalScrollbarValueChanged(int value); virtual void closeEditor(QWidget *editor, QAbstractItemDelegate::EndEditHint hint); virtual void commitData(QWidget *editor); virtual void editorDestroyed(QObject *editor);Q_SIGNALS: void pressed(const QModelIndex &amp;index); void clicked(const QModelIndex &amp;index); void doubleClicked(const QModelIndex &amp;index); void activated(const QModelIndex &amp;index); void entered(const QModelIndex &amp;index); void viewportEntered(); void iconSizeChanged(const QSize &amp;size);protected: QAbstractItemView(QAbstractItemViewPrivate &amp;, QWidget *parent = nullptr);#if QT_DEPRECATED_SINCE(5, 13) QT_DEPRECATED void setHorizontalStepsPerItem(int steps); QT_DEPRECATED int horizontalStepsPerItem() const; QT_DEPRECATED void setVerticalStepsPerItem(int steps); QT_DEPRECATED int verticalStepsPerItem() const;#endif enum CursorAction &#123; MoveUp, MoveDown, MoveLeft, MoveRight, MoveHome, MoveEnd, MovePageUp, MovePageDown, MoveNext, MovePrevious &#125;; virtual QModelIndex moveCursor(CursorAction cursorAction, Qt::KeyboardModifiers modifiers) = 0; virtual int horizontalOffset() const = 0; virtual int verticalOffset() const = 0; virtual bool isIndexHidden(const QModelIndex &amp;index) const = 0; virtual void setSelection(const QRect &amp;rect, QItemSelectionModel::SelectionFlags command) = 0; virtual QRegion visualRegionForSelection(const QItemSelection &amp;selection) const = 0; virtual QModelIndexList selectedIndexes() const; virtual bool edit(const QModelIndex &amp;index, EditTrigger trigger, QEvent *event); virtual QItemSelectionModel::SelectionFlags selectionCommand(const QModelIndex &amp;index, const QEvent *event = nullptr) const;#if QT_CONFIG(draganddrop) virtual void startDrag(Qt::DropActions supportedActions);#endif virtual QStyleOptionViewItem viewOptions() const; enum State &#123; NoState, DraggingState, DragSelectingState, EditingState, ExpandingState, CollapsingState, AnimatingState &#125;; State state() const; void setState(State state); void scheduleDelayedItemsLayout(); void executeDelayedItemsLayout(); void setDirtyRegion(const QRegion &amp;region); void scrollDirtyRegion(int dx, int dy); QPoint dirtyRegionOffset() const; void startAutoScroll(); void stopAutoScroll(); void doAutoScroll(); bool focusNextPrevChild(bool next) override; bool event(QEvent *event) override; bool viewportEvent(QEvent *event) override; void mousePressEvent(QMouseEvent *event) override; void mouseMoveEvent(QMouseEvent *event) override; void mouseReleaseEvent(QMouseEvent *event) override; void mouseDoubleClickEvent(QMouseEvent *event) override;#if QT_CONFIG(draganddrop) void dragEnterEvent(QDragEnterEvent *event) override; void dragMoveEvent(QDragMoveEvent *event) override; void dragLeaveEvent(QDragLeaveEvent *event) override; void dropEvent(QDropEvent *event) override;#endif void focusInEvent(QFocusEvent *event) override; void focusOutEvent(QFocusEvent *event) override; void keyPressEvent(QKeyEvent *event) override; void resizeEvent(QResizeEvent *event) override; void timerEvent(QTimerEvent *event) override; void inputMethodEvent(QInputMethodEvent *event) override; bool eventFilter(QObject *object, QEvent *event) override;#if QT_CONFIG(draganddrop) enum DropIndicatorPosition &#123; OnItem, AboveItem, BelowItem, OnViewport &#125;; DropIndicatorPosition dropIndicatorPosition() const;#endif QSize viewportSizeHint() const override;private: Q_DECLARE_PRIVATE(QAbstractItemView) Q_DISABLE_COPY(QAbstractItemView) Q_PRIVATE_SLOT(d_func(), void _q_columnsAboutToBeRemoved(const QModelIndex&amp;, int, int)) Q_PRIVATE_SLOT(d_func(), void _q_columnsRemoved(const QModelIndex&amp;, int, int)) Q_PRIVATE_SLOT(d_func(), void _q_columnsInserted(const QModelIndex&amp;, int, int)) Q_PRIVATE_SLOT(d_func(), void _q_rowsInserted(const QModelIndex&amp;, int, int)) Q_PRIVATE_SLOT(d_func(), void _q_rowsRemoved(const QModelIndex&amp;, int, int)) Q_PRIVATE_SLOT(d_func(), void _q_columnsMoved(const QModelIndex&amp;, int, int, const QModelIndex&amp;, int)) Q_PRIVATE_SLOT(d_func(), void _q_rowsMoved(const QModelIndex&amp;, int, int, const QModelIndex&amp;, int)) Q_PRIVATE_SLOT(d_func(), void _q_modelDestroyed()) Q_PRIVATE_SLOT(d_func(), void _q_layoutChanged()) Q_PRIVATE_SLOT(d_func(), void _q_headerDataChanged())#if QT_CONFIG(gestures) &amp;&amp; QT_CONFIG(scroller) Q_PRIVATE_SLOT(d_func(), void _q_scrollerStateChanged())#endif friend class ::tst_QAbstractItemView; friend class ::tst_QTreeView; friend class QTreeViewPrivate; // needed to compile with MSVC friend class QListModeViewBase; friend class QListViewPrivate; friend class QAbstractSlider;&#125;;Q_DECLARE_OPERATORS_FOR_FLAGS(QAbstractItemView::EditTriggers)QT_END_NAMESPACE#endif // QABSTRACTITEMVIEW_H]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
        <tag>QtMVD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QAbstractItemDelegate]]></title>
    <url>%2FQT%2Fqabstractitemdelegate%2F</url>
    <content type="text"><![CDATA[QAbstractItemDelegate Header: #include qmake: QT += widgets Inherits: QObject Inherited By: QItemDelegate and QStyledItemDelegate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#ifndef QABSTRACTITEMDELEGATE_H#define QABSTRACTITEMDELEGATE_H#include &lt;QtWidgets/qtwidgetsglobal.h&gt;#include &lt;QtCore/qobject.h&gt;#include &lt;QtWidgets/qstyleoption.h&gt;QT_REQUIRE_CONFIG(itemviews);QT_BEGIN_NAMESPACEclass QPainter;class QModelIndex;class QAbstractItemModel;class QAbstractItemView;class QHelpEvent;class QAbstractItemDelegatePrivate;class Q_WIDGETS_EXPORT QAbstractItemDelegate : public QObject&#123; Q_OBJECTpublic: enum EndEditHint &#123; NoHint, EditNextItem, EditPreviousItem, SubmitModelCache, RevertModelCache &#125;; explicit QAbstractItemDelegate(QObject *parent = nullptr); virtual ~QAbstractItemDelegate(); // painting virtual void paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const = 0; virtual QSize sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const = 0; // editing virtual QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; virtual void destroyEditor(QWidget *editor, const QModelIndex &amp;index) const; virtual void setEditorData(QWidget *editor, const QModelIndex &amp;index) const; virtual void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const; virtual void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; // for non-widget editors virtual bool editorEvent(QEvent *event, QAbstractItemModel *model, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index);#if QT_DEPRECATED_SINCE(5, 13) QT_DEPRECATED_X("Use QFontMetrics::elidedText() instead") static QString elidedText(const QFontMetrics &amp;fontMetrics, int width, Qt::TextElideMode mode, const QString &amp;text);#endif virtual bool helpEvent(QHelpEvent *event, QAbstractItemView *view, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index); virtual QVector&lt;int&gt; paintingRoles() const;Q_SIGNALS: void commitData(QWidget *editor); void closeEditor(QWidget *editor, QAbstractItemDelegate::EndEditHint hint = NoHint); void sizeHintChanged(const QModelIndex &amp;);protected: QAbstractItemDelegate(QObjectPrivate &amp;, QObject *parent = nullptr);private: Q_DECLARE_PRIVATE(QAbstractItemDelegate) Q_DISABLE_COPY(QAbstractItemDelegate) Q_PRIVATE_SLOT(d_func(), void _q_commitDataAndCloseEditor(QWidget*))&#125;;QT_END_NAMESPACE#endif // QABSTRACTITEMDELEGATE_H]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
        <tag>QtMVD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QAbstractItemModel]]></title>
    <url>%2FQT%2Fqabstractitemmodel%2F</url>
    <content type="text"><![CDATA[QAbstractItemModel Header: #include qmake: QT += core Inherits: QObject Inherited By: QAbstractListModel, QAbstractProxyModel, QAbstractTableModel, QConcatenateTablesProxyModel, QDirModel, QFileSystemModel, and QStandardItemModel 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433#ifndef QABSTRACTITEMMODEL_H#define QABSTRACTITEMMODEL_H#include &lt;QtCore/qvariant.h&gt;#include &lt;QtCore/qobject.h&gt;#include &lt;QtCore/qhash.h&gt;#include &lt;QtCore/qvector.h&gt;QT_REQUIRE_CONFIG(itemmodel);QT_BEGIN_NAMESPACEclass QAbstractItemModel;class QPersistentModelIndex;class Q_CORE_EXPORT QModelIndex&#123; friend class QAbstractItemModel;public: Q_DECL_CONSTEXPR inline QModelIndex() noexcept : r(-1), c(-1), i(0), m(nullptr) &#123;&#125; // compiler-generated copy/move ctors/assignment operators are fine! Q_DECL_CONSTEXPR inline int row() const noexcept &#123; return r; &#125; Q_DECL_CONSTEXPR inline int column() const noexcept &#123; return c; &#125; Q_DECL_CONSTEXPR inline quintptr internalId() const noexcept &#123; return i; &#125; inline void *internalPointer() const noexcept &#123; return reinterpret_cast&lt;void*&gt;(i); &#125; inline QModelIndex parent() const; inline QModelIndex sibling(int row, int column) const; inline QModelIndex siblingAtColumn(int column) const; inline QModelIndex siblingAtRow(int row) const;#if QT_DEPRECATED_SINCE(5, 8) QT_DEPRECATED_X("Use QAbstractItemModel::index") inline QModelIndex child(int row, int column) const;#endif inline QVariant data(int role = Qt::DisplayRole) const; inline Qt::ItemFlags flags() const; Q_DECL_CONSTEXPR inline const QAbstractItemModel *model() const noexcept &#123; return m; &#125; Q_DECL_CONSTEXPR inline bool isValid() const noexcept &#123; return (r &gt;= 0) &amp;&amp; (c &gt;= 0) &amp;&amp; (m != nullptr); &#125; Q_DECL_CONSTEXPR inline bool operator==(const QModelIndex &amp;other) const noexcept &#123; return (other.r == r) &amp;&amp; (other.i == i) &amp;&amp; (other.c == c) &amp;&amp; (other.m == m); &#125; Q_DECL_CONSTEXPR inline bool operator!=(const QModelIndex &amp;other) const noexcept &#123; return !(*this == other); &#125; Q_DECL_CONSTEXPR inline bool operator&lt;(const QModelIndex &amp;other) const noexcept &#123; return r &lt; other.r || (r == other.r &amp;&amp; (c &lt; other.c || (c == other.c &amp;&amp; (i &lt; other.i || (i == other.i &amp;&amp; std::less&lt;const QAbstractItemModel *&gt;()(m, other.m)))))); &#125;private: inline QModelIndex(int arow, int acolumn, void *ptr, const QAbstractItemModel *amodel) noexcept : r(arow), c(acolumn), i(reinterpret_cast&lt;quintptr&gt;(ptr)), m(amodel) &#123;&#125; Q_DECL_CONSTEXPR inline QModelIndex(int arow, int acolumn, quintptr id, const QAbstractItemModel *amodel) noexcept : r(arow), c(acolumn), i(id), m(amodel) &#123;&#125; int r, c; quintptr i; const QAbstractItemModel *m;&#125;;Q_DECLARE_TYPEINFO(QModelIndex, Q_MOVABLE_TYPE);#ifndef QT_NO_DEBUG_STREAMQ_CORE_EXPORT QDebug operator&lt;&lt;(QDebug, const QModelIndex &amp;);#endifclass QPersistentModelIndexData;// qHash is a friend, but we can't use default arguments for friends (§8.3.6.4)uint qHash(const QPersistentModelIndex &amp;index, uint seed = 0) noexcept;class Q_CORE_EXPORT QPersistentModelIndex&#123;public: QPersistentModelIndex(); QPersistentModelIndex(const QModelIndex &amp;index); QPersistentModelIndex(const QPersistentModelIndex &amp;other); ~QPersistentModelIndex(); bool operator&lt;(const QPersistentModelIndex &amp;other) const; bool operator==(const QPersistentModelIndex &amp;other) const; inline bool operator!=(const QPersistentModelIndex &amp;other) const &#123; return !operator==(other); &#125; QPersistentModelIndex &amp;operator=(const QPersistentModelIndex &amp;other); inline QPersistentModelIndex(QPersistentModelIndex &amp;&amp;other) noexcept : d(other.d) &#123; other.d = nullptr; &#125; inline QPersistentModelIndex &amp;operator=(QPersistentModelIndex &amp;&amp;other) noexcept &#123; qSwap(d, other.d); return *this; &#125; inline void swap(QPersistentModelIndex &amp;other) noexcept &#123; qSwap(d, other.d); &#125; bool operator==(const QModelIndex &amp;other) const; bool operator!=(const QModelIndex &amp;other) const; QPersistentModelIndex &amp;operator=(const QModelIndex &amp;other); operator const QModelIndex&amp;() const; int row() const; int column() const; void *internalPointer() const; quintptr internalId() const; QModelIndex parent() const; QModelIndex sibling(int row, int column) const;#if QT_DEPRECATED_SINCE(5, 8) QT_DEPRECATED_X("Use QAbstractItemModel::index") QModelIndex child(int row, int column) const;#endif QVariant data(int role = Qt::DisplayRole) const; Qt::ItemFlags flags() const; const QAbstractItemModel *model() const; bool isValid() const;private: QPersistentModelIndexData *d; friend uint qHash(const QPersistentModelIndex &amp;, uint seed) noexcept;#ifndef QT_NO_DEBUG_STREAM friend Q_CORE_EXPORT QDebug operator&lt;&lt;(QDebug, const QPersistentModelIndex &amp;);#endif&#125;;Q_DECLARE_SHARED(QPersistentModelIndex)inline uint qHash(const QPersistentModelIndex &amp;index, uint seed) noexcept&#123; return qHash(index.d, seed); &#125;#ifndef QT_NO_DEBUG_STREAMQ_CORE_EXPORT QDebug operator&lt;&lt;(QDebug, const QPersistentModelIndex &amp;);#endiftemplate&lt;typename T&gt; class QList;typedef QList&lt;QModelIndex&gt; QModelIndexList;class QMimeData;class QAbstractItemModelPrivate;class QTransposeProxyModelPrivate;template &lt;class Key, class T&gt; class QMap;class Q_CORE_EXPORT QAbstractItemModel : public QObject&#123; Q_OBJECT friend class QPersistentModelIndexData; friend class QAbstractItemViewPrivate; friend class QIdentityProxyModel; friend class QTransposeProxyModelPrivate;public: explicit QAbstractItemModel(QObject *parent = nullptr); virtual ~QAbstractItemModel(); Q_INVOKABLE bool hasIndex(int row, int column, const QModelIndex &amp;parent = QModelIndex()) const; Q_INVOKABLE virtual QModelIndex index(int row, int column, const QModelIndex &amp;parent = QModelIndex()) const = 0; Q_INVOKABLE virtual QModelIndex parent(const QModelIndex &amp;child) const = 0; Q_INVOKABLE virtual QModelIndex sibling(int row, int column, const QModelIndex &amp;idx) const; Q_INVOKABLE virtual int rowCount(const QModelIndex &amp;parent = QModelIndex()) const = 0; Q_INVOKABLE virtual int columnCount(const QModelIndex &amp;parent = QModelIndex()) const = 0; Q_INVOKABLE virtual bool hasChildren(const QModelIndex &amp;parent = QModelIndex()) const; Q_INVOKABLE virtual QVariant data(const QModelIndex &amp;index, int role = Qt::DisplayRole) const = 0; Q_INVOKABLE virtual bool setData(const QModelIndex &amp;index, const QVariant &amp;value, int role = Qt::EditRole); Q_INVOKABLE virtual QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const; virtual bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &amp;value, int role = Qt::EditRole); virtual QMap&lt;int, QVariant&gt; itemData(const QModelIndex &amp;index) const; virtual bool setItemData(const QModelIndex &amp;index, const QMap&lt;int, QVariant&gt; &amp;roles);#if QT_VERSION &gt;= QT_VERSION_CHECK(6, 0, 0) virtual bool clearItemData(const QModelIndex &amp;index);#endif virtual QStringList mimeTypes() const; virtual QMimeData *mimeData(const QModelIndexList &amp;indexes) const; virtual bool canDropMimeData(const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &amp;parent) const; virtual bool dropMimeData(const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &amp;parent); virtual Qt::DropActions supportedDropActions() const; virtual Qt::DropActions supportedDragActions() const;#if QT_DEPRECATED_SINCE(5, 0) QT_DEPRECATED void setSupportedDragActions(Qt::DropActions actions) &#123; doSetSupportedDragActions(actions); &#125;#endif virtual bool insertRows(int row, int count, const QModelIndex &amp;parent = QModelIndex()); virtual bool insertColumns(int column, int count, const QModelIndex &amp;parent = QModelIndex()); virtual bool removeRows(int row, int count, const QModelIndex &amp;parent = QModelIndex()); virtual bool removeColumns(int column, int count, const QModelIndex &amp;parent = QModelIndex()); virtual bool moveRows(const QModelIndex &amp;sourceParent, int sourceRow, int count, const QModelIndex &amp;destinationParent, int destinationChild); virtual bool moveColumns(const QModelIndex &amp;sourceParent, int sourceColumn, int count, const QModelIndex &amp;destinationParent, int destinationChild); inline bool insertRow(int row, const QModelIndex &amp;parent = QModelIndex()); inline bool insertColumn(int column, const QModelIndex &amp;parent = QModelIndex()); inline bool removeRow(int row, const QModelIndex &amp;parent = QModelIndex()); inline bool removeColumn(int column, const QModelIndex &amp;parent = QModelIndex()); inline bool moveRow(const QModelIndex &amp;sourceParent, int sourceRow, const QModelIndex &amp;destinationParent, int destinationChild); inline bool moveColumn(const QModelIndex &amp;sourceParent, int sourceColumn, const QModelIndex &amp;destinationParent, int destinationChild); Q_INVOKABLE virtual void fetchMore(const QModelIndex &amp;parent); Q_INVOKABLE virtual bool canFetchMore(const QModelIndex &amp;parent) const; Q_INVOKABLE virtual Qt::ItemFlags flags(const QModelIndex &amp;index) const; virtual void sort(int column, Qt::SortOrder order = Qt::AscendingOrder); virtual QModelIndex buddy(const QModelIndex &amp;index) const; Q_INVOKABLE virtual QModelIndexList match(const QModelIndex &amp;start, int role, const QVariant &amp;value, int hits = 1, Qt::MatchFlags flags = Qt::MatchFlags(Qt::MatchStartsWith|Qt::MatchWrap)) const; virtual QSize span(const QModelIndex &amp;index) const; virtual QHash&lt;int,QByteArray&gt; roleNames() const; using QObject::parent; enum LayoutChangeHint &#123; NoLayoutChangeHint, VerticalSortHint, HorizontalSortHint &#125;; Q_ENUM(LayoutChangeHint) enum class CheckIndexOption &#123; NoOption = 0x0000, IndexIsValid = 0x0001, DoNotUseParent = 0x0002, ParentIsInvalid = 0x0004, &#125;; Q_ENUM(CheckIndexOption) Q_DECLARE_FLAGS(CheckIndexOptions, CheckIndexOption) Q_REQUIRED_RESULT bool checkIndex(const QModelIndex &amp;index, CheckIndexOptions options = CheckIndexOption::NoOption) const;Q_SIGNALS: void dataChanged(const QModelIndex &amp;topLeft, const QModelIndex &amp;bottomRight, const QVector&lt;int&gt; &amp;roles = QVector&lt;int&gt;()); void headerDataChanged(Qt::Orientation orientation, int first, int last); void layoutChanged(const QList&lt;QPersistentModelIndex&gt; &amp;parents = QList&lt;QPersistentModelIndex&gt;(), QAbstractItemModel::LayoutChangeHint hint = QAbstractItemModel::NoLayoutChangeHint); void layoutAboutToBeChanged(const QList&lt;QPersistentModelIndex&gt; &amp;parents = QList&lt;QPersistentModelIndex&gt;(), QAbstractItemModel::LayoutChangeHint hint = QAbstractItemModel::NoLayoutChangeHint); void rowsAboutToBeInserted(const QModelIndex &amp;parent, int first, int last, QPrivateSignal); void rowsInserted(const QModelIndex &amp;parent, int first, int last, QPrivateSignal); void rowsAboutToBeRemoved(const QModelIndex &amp;parent, int first, int last, QPrivateSignal); void rowsRemoved(const QModelIndex &amp;parent, int first, int last, QPrivateSignal); void columnsAboutToBeInserted(const QModelIndex &amp;parent, int first, int last, QPrivateSignal); void columnsInserted(const QModelIndex &amp;parent, int first, int last, QPrivateSignal); void columnsAboutToBeRemoved(const QModelIndex &amp;parent, int first, int last, QPrivateSignal); void columnsRemoved(const QModelIndex &amp;parent, int first, int last, QPrivateSignal); void modelAboutToBeReset(QPrivateSignal); void modelReset(QPrivateSignal); void rowsAboutToBeMoved( const QModelIndex &amp;sourceParent, int sourceStart, int sourceEnd, const QModelIndex &amp;destinationParent, int destinationRow, QPrivateSignal); void rowsMoved( const QModelIndex &amp;parent, int start, int end, const QModelIndex &amp;destination, int row, QPrivateSignal); void columnsAboutToBeMoved( const QModelIndex &amp;sourceParent, int sourceStart, int sourceEnd, const QModelIndex &amp;destinationParent, int destinationColumn, QPrivateSignal); void columnsMoved( const QModelIndex &amp;parent, int start, int end, const QModelIndex &amp;destination, int column, QPrivateSignal);public Q_SLOTS: virtual bool submit(); virtual void revert();protected Q_SLOTS:#if QT_VERSION &gt;= QT_VERSION_CHECK(6, 0, 0) virtual#endif void resetInternalData();protected: QAbstractItemModel(QAbstractItemModelPrivate &amp;dd, QObject *parent = nullptr); inline QModelIndex createIndex(int row, int column, void *data = nullptr) const; inline QModelIndex createIndex(int row, int column, quintptr id) const; void encodeData(const QModelIndexList &amp;indexes, QDataStream &amp;stream) const; bool decodeData(int row, int column, const QModelIndex &amp;parent, QDataStream &amp;stream); void beginInsertRows(const QModelIndex &amp;parent, int first, int last); void endInsertRows(); void beginRemoveRows(const QModelIndex &amp;parent, int first, int last); void endRemoveRows(); bool beginMoveRows(const QModelIndex &amp;sourceParent, int sourceFirst, int sourceLast, const QModelIndex &amp;destinationParent, int destinationRow); void endMoveRows(); void beginInsertColumns(const QModelIndex &amp;parent, int first, int last); void endInsertColumns(); void beginRemoveColumns(const QModelIndex &amp;parent, int first, int last); void endRemoveColumns(); bool beginMoveColumns(const QModelIndex &amp;sourceParent, int sourceFirst, int sourceLast, const QModelIndex &amp;destinationParent, int destinationColumn); void endMoveColumns();#if QT_DEPRECATED_SINCE(5,0) QT_DEPRECATED void reset() &#123; beginResetModel(); endResetModel(); &#125;#endif void beginResetModel(); void endResetModel(); void changePersistentIndex(const QModelIndex &amp;from, const QModelIndex &amp;to); void changePersistentIndexList(const QModelIndexList &amp;from, const QModelIndexList &amp;to); QModelIndexList persistentIndexList() const;#if QT_DEPRECATED_SINCE(5,0) QT_DEPRECATED void setRoleNames(const QHash&lt;int,QByteArray&gt; &amp;theRoleNames) &#123; doSetRoleNames(theRoleNames); &#125;#endifprivate: void doSetRoleNames(const QHash&lt;int,QByteArray&gt; &amp;roleNames); void doSetSupportedDragActions(Qt::DropActions actions); Q_DECLARE_PRIVATE(QAbstractItemModel) Q_DISABLE_COPY(QAbstractItemModel)&#125;;Q_DECLARE_OPERATORS_FOR_FLAGS(QAbstractItemModel::CheckIndexOptions)inline bool QAbstractItemModel::insertRow(int arow, const QModelIndex &amp;aparent)&#123; return insertRows(arow, 1, aparent); &#125;inline bool QAbstractItemModel::insertColumn(int acolumn, const QModelIndex &amp;aparent)&#123; return insertColumns(acolumn, 1, aparent); &#125;inline bool QAbstractItemModel::removeRow(int arow, const QModelIndex &amp;aparent)&#123; return removeRows(arow, 1, aparent); &#125;inline bool QAbstractItemModel::removeColumn(int acolumn, const QModelIndex &amp;aparent)&#123; return removeColumns(acolumn, 1, aparent); &#125;inline bool QAbstractItemModel::moveRow(const QModelIndex &amp;sourceParent, int sourceRow, const QModelIndex &amp;destinationParent, int destinationChild)&#123; return moveRows(sourceParent, sourceRow, 1, destinationParent, destinationChild); &#125;inline bool QAbstractItemModel::moveColumn(const QModelIndex &amp;sourceParent, int sourceColumn, const QModelIndex &amp;destinationParent, int destinationChild)&#123; return moveColumns(sourceParent, sourceColumn, 1, destinationParent, destinationChild); &#125;inline QModelIndex QAbstractItemModel::createIndex(int arow, int acolumn, void *adata) const&#123; return QModelIndex(arow, acolumn, adata, this); &#125;inline QModelIndex QAbstractItemModel::createIndex(int arow, int acolumn, quintptr aid) const&#123; return QModelIndex(arow, acolumn, aid, this); &#125;class Q_CORE_EXPORT QAbstractTableModel : public QAbstractItemModel&#123; Q_OBJECTpublic: explicit QAbstractTableModel(QObject *parent = nullptr); ~QAbstractTableModel(); QModelIndex index(int row, int column, const QModelIndex &amp;parent = QModelIndex()) const override; QModelIndex sibling(int row, int column, const QModelIndex &amp;idx) const override; bool dropMimeData(const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &amp;parent) override; Qt::ItemFlags flags(const QModelIndex &amp;index) const override; using QObject::parent;protected: QAbstractTableModel(QAbstractItemModelPrivate &amp;dd, QObject *parent);private: Q_DISABLE_COPY(QAbstractTableModel) QModelIndex parent(const QModelIndex &amp;child) const override; bool hasChildren(const QModelIndex &amp;parent) const override;&#125;;class Q_CORE_EXPORT QAbstractListModel : public QAbstractItemModel&#123; Q_OBJECTpublic: explicit QAbstractListModel(QObject *parent = nullptr); ~QAbstractListModel(); QModelIndex index(int row, int column = 0, const QModelIndex &amp;parent = QModelIndex()) const override; QModelIndex sibling(int row, int column, const QModelIndex &amp;idx) const override; bool dropMimeData(const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &amp;parent) override; Qt::ItemFlags flags(const QModelIndex &amp;index) const override; using QObject::parent;protected: QAbstractListModel(QAbstractItemModelPrivate &amp;dd, QObject *parent);private: Q_DISABLE_COPY(QAbstractListModel) QModelIndex parent(const QModelIndex &amp;child) const override; int columnCount(const QModelIndex &amp;parent) const override; bool hasChildren(const QModelIndex &amp;parent) const override;&#125;;// inline implementationsinline QModelIndex QModelIndex::parent() const&#123; return m ? m-&gt;parent(*this) : QModelIndex(); &#125;inline QModelIndex QModelIndex::sibling(int arow, int acolumn) const&#123; return m ? (r == arow &amp;&amp; c == acolumn) ? *this : m-&gt;sibling(arow, acolumn, *this) : QModelIndex(); &#125;inline QModelIndex QModelIndex::siblingAtColumn(int acolumn) const&#123; return m ? (c == acolumn) ? *this : m-&gt;sibling(r, acolumn, *this) : QModelIndex(); &#125;inline QModelIndex QModelIndex::siblingAtRow(int arow) const&#123; return m ? (r == arow) ? *this : m-&gt;sibling(arow, c, *this) : QModelIndex(); &#125;#if QT_DEPRECATED_SINCE(5, 8)inline QModelIndex QModelIndex::child(int arow, int acolumn) const&#123; return m ? m-&gt;index(arow, acolumn, *this) : QModelIndex(); &#125;#endifinline QVariant QModelIndex::data(int arole) const&#123; return m ? m-&gt;data(*this, arole) : QVariant(); &#125;inline Qt::ItemFlags QModelIndex::flags() const&#123; return m ? m-&gt;flags(*this) : Qt::ItemFlags(); &#125;inline uint qHash(const QModelIndex &amp;index) noexcept&#123; return uint((uint(index.row()) &lt;&lt; 4) + index.column() + index.internalId()); &#125;QT_END_NAMESPACEQ_DECLARE_METATYPE(QModelIndexList)#endif // QABSTRACTITEMMODEL_H]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
        <tag>QtMVD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枚举名与字符串相互转换]]></title>
    <url>%2FC%2F%E6%9E%9A%E4%B8%BE%E5%90%8D%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[https://www.bilibili.com/video/BV1Ur4y1V7Kh?spm_id_from=333.999.0.0&amp;vd_source=3d0c7cbd0c95f2308054440260ab6f64 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#pragma once#include &lt;string&gt;namespace scienum &#123;namespace details &#123;template &lt;class T, T N&gt;const char *get_enum_name_static() &#123; //关键 根据宏获取函数名字符串#if defined(_MSC_VER) return __FUNCSIG__; //return "void __cdecl get_enum_name_static&lt;int&gt;(void)"#else return __PRETTY_FUNCTION__; //return "void get_enum_name_static() [with T = int]"#endif&#125;template &lt;bool Cond&gt;struct my_enable_if &#123;&#125;;template &lt;&gt;struct my_enable_if&lt;true&gt; &#123; typedef void type;&#125;;template &lt;int Beg, int End, class F&gt; //模板特化 用于结束循环typename my_enable_if&lt;Beg == End&gt;::type static_for(F const &amp;func) &#123;&#125;template &lt;int Beg, int End, class F&gt;typename my_enable_if&lt;Beg != End&gt;::type static_for(F const &amp;func) &#123; func.template call&lt;Beg&gt;(); static_for&lt;Beg + 1, End&gt;(func);&#125;template &lt;class T&gt;struct get_enum_name_functor &#123; int n; std::string &amp;s; get_enum_name_functor(int n, std::string &amp;s) : n(n), s(s) &#123;&#125; template &lt;int I&gt; void call() const &#123; if (n == I) s = details::get_enum_name_static&lt;T, (T)I&gt;(); //I需要编译期能确定的，这里不能通过call(int I)调用，虽然前面调用的Beg是编译期确定的值。 //这里可以使用std::integral_constant&lt;Beg&gt; 其中里面有个value成员是constexpr的 &#125;&#125;;&#125;template &lt;class T, T Beg, T End&gt;std::string get_enum_name(T n) &#123; std::string s; details::static_for&lt;Beg, End + 1&gt;(details::get_enum_name_functor&lt;T&gt;(n, s)); if (s.empty()) return "";#if defined(_MSC_VER)//下面是裁剪字符串了 size_t pos = s.find(','); pos += 1; size_t pos2 = s.find('&gt;', pos);#else size_t pos = s.find("N = "); pos += 4; size_t pos2 = s.find_first_of(";]", pos);#endif s = s.substr(pos, pos2 - pos); size_t pos3 = s.find("::"); if (pos3 != s.npos) s = s.substr(pos3 + 2); return s;&#125;template &lt;class T&gt;std::string get_enum_name(T n) &#123; return get_enum_name&lt;T, (T)0, (T)256&gt;(n);&#125;template &lt;class T, T Beg, T End&gt;T enum_from_name(std::string const &amp;s) &#123; for (int i = (int)Beg; i &lt; (int)End; i++) &#123; if (s == get_enum_name((T)i)) &#123; return (T)i; &#125; &#125; throw;&#125;template &lt;class T&gt;T enum_from_name(std::string const &amp;s) &#123; return enum_from_name&lt;T, (T)0, (T)256&gt;(s);&#125;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Cpp基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右值引用与完美转发]]></title>
    <url>%2FC%2F%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[右值引用与完美转发右值引用 左值（l-value - locator value）是指存储在内存中、有明确存储地址（可取地址）的数据；右值（r -value - read value）是指可以提供数据值的数据（不可取地址）可以对其取地址（&amp;）就是左值，否则为右值 。所有有名字的变量或对象都是左值，而右值是匿名的。 右值分两种 纯右值：非引用返回的临时变量、运算产生的临时变量、原始字面量和 lambda 等将亡值：与右值引用相关的，比如，T&amp;&amp; 类型函数的返回值、 std::move 的返回值等。 右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用的方式找到它。无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。 1234567891011int &amp;&amp; v = 10; //v 是对字面量 10 这个右值的引用OBJ getObj() &#123; return OBJ(); &#125;int main()&#123; int i1; int&amp;&amp; i2 = i1; // error 左值不能赋值给右值 OBJ&amp; o = getObj(); // error 左值引用不能接将亡值 OBJ&amp;&amp; o1 = getObj(); //右值引用可以接收将亡值 const OBJ&amp; o2 = getObj(); //会进行构造，常量左值是万能的 return 0;&#125; 12OBJ(const OBJ&amp; a);OBJ t = getObj(); t进行拷贝构造，根据将亡值创建、且将亡值会进行析构，效率不高。 12OBJ(OBJ&amp;&amp; a);OBJ t = getObj(); 因为getObj返回的是将亡值，编译器自动进行右值处理，可以理解为添加了个std::move进行类型转换。调用移动构造。 &amp;&amp;在模板中12template&lt;typename T&gt; void f(T&amp;&amp; param); //并不一定表示右值引用，若f(左值)则为左值引用 &amp;&amp;在auto中 &amp;&amp;在auto中，auto&amp;&amp; v = 左值，则v表示左值引用。 decltype(x)&amp;&amp;，表示一个确切的类型，没有auto灵活。此时用左值赋值会报错。 完美转发12std::forward&lt;&gt;() //因为参数为&amp;&amp;时，不知道是左值引用还是右值引用//所以使用forward帮助传递参数，会按实际情况进行转发 有时候右值会转为左值，左值会转为右值。 1234template&lt;typename T&gt; T&amp;&amp; move(T&amp; val) &#123; return static_cast&lt;T&amp;&amp;&gt;(val); //std::move实际上是个类型转换&#125; 123456789101112131415161718template&lt;typename T1, typename T2, typename T3&gt; B(T1&amp;&amp; t1, T2&amp;&amp; t2, T3&amp;&amp; t3) : a1_&#123;std::forward&lt;T1&gt;(t1)&#125;, a2_&#123;std::forward&lt;T2&gt;(t2)&#125;, a3_&#123;std::forward&lt;T3&gt;(t3)&#125; &#123; &#125;template&lt;typename T,class... U&gt;std::unique_ptr&lt;T&gt; make_unique1(U&amp;&amp;... u)&#123; //return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;U&gt;(u)...)); //右 左 右 return std::unique_ptr&lt;T&gt;(new T(std::move(u)...)); //右 右 右&#125;int main() &#123; int i = 0; make_unique1&lt;B&gt;(1,i,2); //右 左 右&#125;//无论是T&amp;&amp;、左值引用、右值引用，std::forward都会依照原来的类型完美转发]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Cpp基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23.官方示例ffplay结构体]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F23-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8Bffplay%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[12345typedef struct MyAVPacketList &#123;//Packet链表 不使用AVPacketList AVPacket pkt; struct MyAVPacketList *next; int serial;&#125; MyAVPacketList; 12345678910typedef struct PacketQueue &#123;//packet队列 MyAVPacketList *first_pkt, *last_pkt; int nb_packets; // 包数量，也就是队列元素数量 int size; // 队列所有元素的数据大小总和 int64_t duration; // 队列所有元素的数据播放持续时间 int abort_request; // 用户退出请求标志 int serial; // 播放序列，所谓播放序列就是一段连续的播放动作，一个seek操作会启动一段新的播放序列 SDL_mutex *mutex; // 互斥量 SDL_cond *cond; // 条件变量 产生阻塞&#125; PacketQueue; 123456789101112typedef struct FrameQueue &#123; Frame queue[FRAME_QUEUE_SIZE]; int rindex; // 读索引。待播放时读取此帧进行播放，播放后此帧成为上一帧 int windex; // 写索引 int size; // 总帧数 int max_size; // 队列可存储最大帧数 int keep_last; // 是否保留已播放的最后一帧使能标志 int rindex_shown; // 是否保留已播放的最后一帧实现手段 SDL_mutex *mutex; SDL_cond *cond; PacketQueue *pktq; // 指向对应的packet_queue&#125; FrameQueue; 12345678typedef struct AudioParams &#123;//音频参数 int freq; // 采样率 int channels; // 通道数 int64_t channel_layout; // 通道布局，比如2.1声道，5.1声道等 enum AVSampleFormat fmt; // 音频采样格式，比如AV_SAMPLE_FMT_S16表示为有符号16bit深度，交错排列模式。 int frame_size; // 一个采样单元占用的字节数（比如2通道时，则左右通道各采样一次合成一个采样单元） int bytes_per_sec; // 一秒时间的字节数，比如采样率48Khz，2 channel，16bit，则一秒48000*2*16/8=192000&#125; AudioParams; 12345678910111213141516typedef struct Clock &#123; // 当前帧(待播放)显示时间戳，播放后，当前帧变成上一帧 double pts; /* clock base */ // 当前帧显示时间戳与当前系统时钟时间的差值 double pts_drift; /* clock base minus time at which we updated the clock */ // 当前时钟(如视频时钟)最后一次更新时间，也可称当前时钟时间 double last_updated; // 时钟速度控制，用于控制播放速度 double speed; // 播放序列，所谓播放序列就是一段连续的播放动作，一个seek操作会启动一段新的播放序列 int serial; /* clock is based on a packet with this serial */ // 暂停标志 int paused; // 指向packet_serial int *queue_serial; /* pointer to the current packet queue serial, used for obsolete clock detection */&#125; Clock; 1234567891011121314typedef struct Frame &#123;//帧 AVFrame *frame; // 指向数据帧 AVSubtitle sub; // 用于字幕 int serial; // 帧序列，在seek的操作时serial会变化 double pts; // 时间戳，单位为秒 double duration; // 该帧持续时间，单位为秒 int64_t pos; // 该帧在输入文件中的字节位置 int width; // 图像宽度 int height; // 图像高读 int format; // 对于图像为(enum AVPixelFormat)，对于声音则为(enum AVSampleFormat) AVRational sar; // 图像的宽高比，如果未知或未指定则为0/1 int uploaded; // 用来记录该帧是否已经显示过？ int flip_v; // =1则旋转180， = 0则正常播放&#125; Frame; 1234567891011121314typedef struct Decoder &#123; AVPacket pkt; PacketQueue *queue; // 数据包队列 AVCodecContext *avctx; // 解码器上下文 int pkt_serial; // 包序列 int finished; // 0即解码器处于工作状态 int packet_pending; // 0即解码器处于异常状态，需要考虑重置解码器；1即解码器处于正常状态 SDL_cond *empty_queue_cond; // 检查到packet队列空时发送 signal缓存read_thread读取数据 int64_t start_pts; // 初始化时是stream的start time AVRational start_pts_tb; // 初始化时是stream的time_base int64_t next_pts; // 记录最近一次解码后的frame的pts，当解出来的部分帧没有有效的pts时则使用next_pts进行推算 AVRational next_pts_tb; // next_pts的单位 SDL_Thread *decoder_tid; // 线程句柄&#125; Decoder; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105typedef struct VideoState &#123; SDL_Thread *read_tid; // demux解复用线程 AVInputFormat *iformat; int abort_request; int force_refresh; int paused; int last_paused; int queue_attachments_req; int seek_req; // 标识一次SEEK请求 int seek_flags; // SEEK标志，诸如AVSEEK_FLAG_BYTE等 int64_t seek_pos; // SEEK的目标位置(当前位置+增量) int64_t seek_rel; // 本次SEEK的位置增量 int read_pause_return; AVFormatContext *ic; int realtime; Clock audclk; // 音频时钟 Clock vidclk; // 视频时钟 Clock extclk; // 外部时钟 FrameQueue pictq; // 视频frame队列 FrameQueue subpq; // 字幕frame队列 FrameQueue sampq; // 音频frame队列 Decoder auddec; // 音频解码器 Decoder viddec; // 视频解码器 Decoder subdec; // 字幕解码器 int audio_stream; // 音频流索引 int av_sync_type; double audio_clock; // 每个音频帧更新一下此值，以pts形式表示 int audio_clock_serial; // 播放序列，seek可改变此值 double audio_diff_cum; /* used for AV difference average computation */ double audio_diff_avg_coef; double audio_diff_threshold; int audio_diff_avg_count; AVStream *audio_st; // 音频流 PacketQueue audioq; // 音频packet队列 int audio_hw_buf_size; // SDL音频缓冲区大小(单位字节) uint8_t *audio_buf; // 指向待播放的一帧音频数据，指向的数据区将被拷入SDL音频缓冲区。若经过重采样则指向audio_buf1，否则指向frame中的音频 uint8_t *audio_buf1; // 音频重采样的输出缓冲区 unsigned int audio_buf_size; /* in bytes */ // 待播放的一帧音频数据(audio_buf指向)的大小 unsigned int audio_buf1_size; // 申请到的音频缓冲区audio_buf1的实际尺寸 int audio_buf_index; /* in bytes */ // 当前音频帧中已拷入SDL音频缓冲区的位置索引(指向第一个待拷贝字节) int audio_write_buf_size; // 当前音频帧中尚未拷入SDL音频缓冲区的数据量，audio_buf_size = audio_buf_index + audio_write_buf_size int audio_volume; // 音量 int muted; // 静音状态 struct AudioParams audio_src; // 音频frame的参数#if CONFIG_AVFILTER struct AudioParams audio_filter_src;#endif struct AudioParams audio_tgt; // SDL支持的音频参数，重采样转换：audio_src-&gt;audio_tgt struct SwrContext *swr_ctx; // 音频重采样context int frame_drops_early; // 丢弃视频packet计数 int frame_drops_late; // 丢弃视频frame计数 enum ShowMode &#123; SHOW_MODE_NONE = -1, SHOW_MODE_VIDEO = 0, SHOW_MODE_WAVES, SHOW_MODE_RDFT, SHOW_MODE_NB &#125; show_mode; int16_t sample_array[SAMPLE_ARRAY_SIZE]; int sample_array_index; int last_i_start; RDFTContext *rdft; int rdft_bits; FFTSample *rdft_data; int xpos; double last_vis_time; SDL_Texture *vis_texture; SDL_Texture *sub_texture; SDL_Texture *vid_texture; int subtitle_stream; // 字幕流索引 AVStream *subtitle_st; // 字幕流 PacketQueue subtitleq; // 字幕packet队列 double frame_timer; // 记录最后一帧播放的时刻 double frame_last_returned_time; double frame_last_filter_delay; int video_stream; AVStream *video_st; // 视频流 PacketQueue videoq; // 视频队列 double max_frame_duration; // maximum duration of a frame - above this, we consider the jump a timestamp discontinuity struct SwsContext *img_convert_ctx; struct SwsContext *sub_convert_ctx; int eof; char *filename; int width, height, xleft, ytop; int step;#if CONFIG_AVFILTER int vfilter_idx; AVFilterContext *in_video_filter; // the first filter in the video chain AVFilterContext *out_video_filter; // the last filter in the video chain AVFilterContext *in_audio_filter; // the first filter in the audio chain AVFilterContext *out_audio_filter; // the last filter in the audio chain AVFilterGraph *agraph; // audio filter graph#endif int last_video_stream, last_audio_stream, last_subtitle_stream; SDL_cond *continue_read_thread;&#125; VideoState; 12345678910111213141516171819202122232425static const struct TextureFormatEntry &#123;//sdl音频输出有限 需要重采样 enum AVPixelFormat format; int texture_fmt;&#125; sdl_texture_format_map[] = &#123; &#123; AV_PIX_FMT_RGB8, SDL_PIXELFORMAT_RGB332 &#125;, &#123; AV_PIX_FMT_RGB444, SDL_PIXELFORMAT_RGB444 &#125;, &#123; AV_PIX_FMT_RGB555, SDL_PIXELFORMAT_RGB555 &#125;, &#123; AV_PIX_FMT_BGR555, SDL_PIXELFORMAT_BGR555 &#125;, &#123; AV_PIX_FMT_RGB565, SDL_PIXELFORMAT_RGB565 &#125;, &#123; AV_PIX_FMT_BGR565, SDL_PIXELFORMAT_BGR565 &#125;, &#123; AV_PIX_FMT_RGB24, SDL_PIXELFORMAT_RGB24 &#125;, &#123; AV_PIX_FMT_BGR24, SDL_PIXELFORMAT_BGR24 &#125;, &#123; AV_PIX_FMT_0RGB32, SDL_PIXELFORMAT_RGB888 &#125;, &#123; AV_PIX_FMT_0BGR32, SDL_PIXELFORMAT_BGR888 &#125;, &#123; AV_PIX_FMT_NE(RGB0, 0BGR), SDL_PIXELFORMAT_RGBX8888 &#125;, &#123; AV_PIX_FMT_NE(BGR0, 0RGB), SDL_PIXELFORMAT_BGRX8888 &#125;, &#123; AV_PIX_FMT_RGB32, SDL_PIXELFORMAT_ARGB8888 &#125;, &#123; AV_PIX_FMT_RGB32_1, SDL_PIXELFORMAT_RGBA8888 &#125;, &#123; AV_PIX_FMT_BGR32, SDL_PIXELFORMAT_ABGR8888 &#125;, &#123; AV_PIX_FMT_BGR32_1, SDL_PIXELFORMAT_BGRA8888 &#125;, &#123; AV_PIX_FMT_YUV420P, SDL_PIXELFORMAT_IYUV &#125;, &#123; AV_PIX_FMT_YUYV422, SDL_PIXELFORMAT_YUY2 &#125;, &#123; AV_PIX_FMT_UYVY422, SDL_PIXELFORMAT_UYVY &#125;, &#123; AV_PIX_FMT_NONE, SDL_PIXELFORMAT_UNKNOWN &#125;,&#125;; 12345enum &#123;//音视频同步方式枚举 AV_SYNC_AUDIO_MASTER, // 以音频为基准 AV_SYNC_VIDEO_MASTER, // 以视频为基准 AV_SYNC_EXTERNAL_CLOCK, // 以外部时钟为基准，synchronize to an external clock */&#125;;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22.音视频同步参考]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F22-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[出处见链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576https://blog.csdn.net/myvest/article/details/97416415&#123; video-&gt;frameq.deQueue(&amp;video-&gt;frame); double current_pts = *(double *)video-&gt;frame-&gt;opaque;//当前帧的pts double delay = current_pts - video-&gt;frame_last_pts;//相减之后 就是前帧默认的时间 if (delay &lt;= 0 || delay &gt;= 1.0) &#123; delay = video-&gt;frame_last_delay;//数据波动太大 特殊处理 &#125; double ref_clock = audio-&gt;get_audio_clock();//参考时间 double diff = current_pts - ref_clock;//应该播放时间-当前时间 = 偏差时间 diff &lt; 0 :video slow,diff &gt; 0 :video fast double sync_threshold = FFMAX(MIN_SYNC_THRESHOLD, FFMIN(MAX_SYNC_THRESHOLD, delay)) ;//规定帧播放时间在一定范围内 audio-&gt;audio_wait_video(current_pts,false);//更新时钟 video-&gt;video_drop_frame(ref_clock,false); if (!isnan(diff) &amp;&amp; fabs(diff) &lt; NOSYNC_THRESHOLD) // 不同步 &#123; if (diff &lt;= -sync_threshold)//视频比音频慢，加快 &#123; delay = FFMAX(0, delay + diff);//表示直接覆盖上一帧 static int last_delay_zero_counts = 0; if(video-&gt;frame_last_delay &lt;= 0) &#123; last_delay_zero_counts++; &#125; else &#123; last_delay_zero_counts = 0; &#125; if(diff &lt; -1.0 &amp;&amp; last_delay_zero_counts &gt;= 10)//连续缓慢 视频解码跟不上 &#123; printf("maybe video codec too slow, adjust video&amp;audio\n"); #ifndef DORP_PACK audio-&gt;audio_wait_video(current_pts,true);//差距较大，需要反馈音频等待视频 #endif video-&gt;video_drop_frame(ref_clock,true);//差距较大，需要视频丢帧追上 &#125; &#125;//视频比音频快，减慢 else if (diff &gt;= sync_threshold &amp;&amp; delay &gt; SYNC_FRAMEDUP_THRESHOLD)//快了一帧以上 该帧与前帧相差了不少 delay = delay + diff;//直接跳过去 else if (diff &gt;= sync_threshold) delay = 2 * delay;//音视频差距较小，加倍延迟，逐渐缩小 &#125; video-&gt;frame_last_delay = delay;//该帧从current_pts播放了delay时长 video-&gt;frame_last_pts = current_pts; double curr_time = static_cast&lt;double&gt;(av_gettime()) / 1000000.0; if(video-&gt;frame_timer == 0) &#123; video-&gt;frame_timer = curr_time;//第一次 &#125; double actual_delay = video-&gt;frame_timer + delay - curr_time;//应该为curr_time-video-&gt;frame_timer + delay if (actual_delay &lt;= MIN_REFRSH_S) &#123; actual_delay = MIN_REFRSH_S; &#125; usleep(static_cast&lt;int&gt;(actual_delay * 1000 * 1000)); //printf("actual_delay[%lf] delay[%lf] diff[%lf]\n",actual_delay,delay,diff); // Display SDL_UpdateTexture(video-&gt;texture, &amp;(video-&gt;rect), video-&gt;frame-&gt;data[0], video-&gt;frame-&gt;linesize[0]); SDL_RenderClear(video-&gt;renderer); SDL_RenderCopy(video-&gt;renderer, video-&gt;texture, &amp;video-&gt;rect, &amp;video-&gt;rect); SDL_RenderPresent(video-&gt;renderer); video-&gt;frame_timer = static_cast&lt;double&gt;(av_gettime()) / 1000000.0 ;//刷新一帧显示时间 av_frame_unref(video-&gt;frame); //update next frame schedule_refresh(media, 1);&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21.官方示例H264的QSV加速简析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F21-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8Bh264%E7%9A%84qsv%E5%8A%A0%E9%80%9F%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[12345678/** * @file * Intel QSV-accelerated H.264 decoding example. * * @example qsvdec.c * This example shows how to do QSV-accelerated H.264 decoding with output * frames in the GPU video surfaces. */]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20.官方示例解复用和复用简析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F20-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%8D%E7%94%A8%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041/** * @file * libavformat/libavcodec demuxing and muxing API example. * * Remux streams from one container format to another. * @example remuxing.c */avformat_open_input();//打开输入流和读取文件头 ifmtCtxavformat_find_stream_info();//获取文件流信息av_dump_format();//输出format信息avformat_alloc_output_context2();//分配一个输出封装上下文ofmtCtxav_mallocz_array();//分配一个内存数组for (i = 0; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;//创建ofmtCtx里面的流 avformat_new_stream();//分配个新的流到封装上下文ofmtCtx 并创建一个oStream avcodec_parameters_copy();//编码器参数拷贝 oStream-&gt;codecpar-&gt;codec_tag=0;&#125;av_dump_format();if (!(ofmtCtx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)) &#123;//输出格式 不应该有文件被打开 ret = avio_open(&amp;ofmtCtx-&gt;pb, out_filename, AVIO_FLAG_WRITE);//创建初始化AVIOContext&#125;avformat_write_header();//给ofmtCtx定入头信息while(1)&#123; av_read_frame();//从ifmtCtx读取一个Pkt pkt.stream_index = stream_mapping[pkt.stream_index]; pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX); pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX); pkt.duration = av_rescale_q(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base); pkt.pos = -1; log_packet();//输出包信息 av_interleaved_write_frame();//写Pkt到ofmtCtx 内部会缓存 以保证按照dtx排序 av_packet_unref();//释放pkt&#125;av_write_trailer();//将流末尾写入ofmtCtx并释放文件私有数据avformat_close_input(&amp;ifmtCtx);//avformat_open_inputif (ofmtCtx &amp;&amp; !(ofmtCtx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)) avio_closep(&amp;ofmtCtx-&gt;pb);avformat_free_context(ofmtCtx);//avformat_new_streamav_freep(); 12345678910111213141516171819202122232425262728293031323334353637/*** @file* libavformat API example.** Output a media file in any supported libavformat format. The default* codecs are used.* @example muxing.c*/avformat_alloc_output_context2(&amp;oc, NULL, NULL, filename);//分配输出上下文if (!oc) &#123; avformat_alloc_output_context2(&amp;oc, NULL, "mpeg", filename);//尝试打开MPEG&#125;if（oc-&gt;oformat-&gt;video_codec!= AV_CODEC_ID_NONE）&#123; add_stream(&amp;video_st, oc, &amp;video_codec, fmt-&gt;video_codec); open_video(oc, video_codec, &amp;video_st, opt);&#125;if (fmt-&gt;audio_codec != AV_CODEC_ID_NONE) &#123; add_stream(&amp;audio_st, oc, &amp;audio_codec, fmt-&gt;audio_codec); open_audio(oc, audio_codec, &amp;audio_st, opt);&#125;av_dump_format();//输出信息if (!(fmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;//需要打开文件 avio_open(&amp;oc-&gt;pb, filename, AVIO_FLAG_WRITE);&#125;avformat_write_header();//写入流头信息while (encode_video || encode_audio) &#123; if (encode_video &amp;&amp; (!encode_audio || av_compare_ts(video_st.next_pts, video_st.enc-&gt;time_base,audio_st.next_pts, audio_st.enc-&gt;time_base) &lt;= 0)) &#123;//比较两个时间戳 encode_video = !write_video_frame(oc, &amp;video_st); &#125; else &#123; encode_audio = !write_audio_frame(oc, &amp;audio_st); &#125;&#125;av_write_trailer();if (!(fmt-&gt;flags &amp; AVFMT_NOFILE)) avio_closep(&amp;oc-&gt;pb);avformat_free_context(oc); 1234567891011121314151617181920212223242526static void log_packet(const AVFormatContext *fmt_ctx, const AVPacket *pkt, const char *tag)&#123; AVRational *time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base; printf("%s: pts:%s pts_time:%s dts:%s dts_time:%s duration:%s duration_time:%s stream_index:%d\n", tag, av_ts2str(pkt-&gt;pts), av_ts2timestr(pkt-&gt;pts, time_base), av_ts2str(pkt-&gt;dts), av_ts2timestr(pkt-&gt;dts, time_base), av_ts2str(pkt-&gt;duration), av_ts2timestr(pkt-&gt;duration, time_base), pkt-&gt;stream_index);&#125;static int write_frame(AVFormatContext *fmt_ctx, const AVRational *time_base, AVStream *st, AVPacket *pkt)&#123; av_packet_rescale_ts(pkt, *time_base, st-&gt;time_base);//修改时间戳 pkt-&gt;stream_index = st-&gt;index; log_packet(fmt_ctx, pkt); return av_interleaved_write_frame(fmt_ctx, pkt);&#125;static void close_stream(AVFormatContext *oc, OutputStream *ost)&#123; avcodec_free_context(&amp;ost-&gt;enc); av_frame_free(&amp;ost-&gt;frame); av_frame_free(&amp;ost-&gt;tmp_frame); sws_freeContext(ost-&gt;sws_ctx); swr_free(&amp;ost-&gt;swr_ctx);&#125; 123456789101112131415typedef struct OutputStream &#123; AVStream *st; AVCodecContext *enc; int64_t next_pts;//生成时下一帧的pts int samples_count; AVFrame *frame; AVFrame *tmp_frame; float t, tincr, tincr2; struct SwsContext *sws_ctx; struct SwrContext *swr_ctx;&#125; OutputStream; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static void add_stream(OutputStream *ost, AVFormatContext *oc,AVCodec **codec,enum AVCodecID codec_id)//根据AVCodecID添加一个输出流&#123; AVCodecContext *c; int i; *codec = avcodec_find_encoder(codec_id);//根据id查找一个编码器 if (!(*codec)) &#123; fprintf(stderr, "Could not find encoder for '%s'\n",avcodec_get_name(codec_id)); exit(1); &#125; ost-&gt;st = avformat_new_stream(oc, NULL);//为oc分配一个流 if (!ost-&gt;st) &#123; exit(1); &#125; ost-&gt;st-&gt;id = oc-&gt;nb_streams - 1; c = avcodec_alloc_context3(*codec);//分配和初始化c if (!c) &#123; exit(1); &#125; ost-&gt;enc = c; switch ((*codec)-&gt;type) &#123; case AVMEDIA_TYPE_AUDIO: c-&gt;sample_fmt = (*codec)-&gt;sample_fmts ?(*codec)-&gt;sample_fmts[0] : AV_SAMPLE_FMT_FLTP; c-&gt;bit_rate = 64000; c-&gt;sample_rate = 44100;//采样率 if ((*codec)-&gt;supported_samplerates) &#123; c-&gt;sample_rate = (*codec)-&gt;supported_samplerates[0]; for (i = 0; (*codec)-&gt;supported_samplerates[i]; i++) &#123; if ((*codec)-&gt;supported_samplerates[i] == 44100) c-&gt;sample_rate = 44100; &#125; &#125; c-&gt;channels = av_get_channel_layout_nb_channels(c-&gt;channel_layout);//获取通道数 c-&gt;channel_layout = AV_CH_LAYOUT_STEREO;//左右声道 if ((*codec)-&gt;channel_layouts) &#123; c-&gt;channel_layout = (*codec)-&gt;channel_layouts[0]; for (i = 0; (*codec)-&gt;channel_layouts[i]; i++) &#123; if ((*codec)-&gt;channel_layouts[i] == AV_CH_LAYOUT_STEREO) c-&gt;channel_layout = AV_CH_LAYOUT_STEREO; &#125; &#125; c-&gt;channels = av_get_channel_layout_nb_channels(c-&gt;channel_layout); ost-&gt;st-&gt;time_base = (AVRational) &#123; 1, c-&gt;sample_rate &#125;;//时基 break; case AVMEDIA_TYPE_VIDEO: c-&gt;codec_id = codec_id; c-&gt;bit_rate = 400000; c-&gt;width = 352; c-&gt;height = 288; ost-&gt;st-&gt;time_base = (AVRational) &#123; 1, 25 &#125;; c-&gt;time_base = ost-&gt;st-&gt;time_base; c-&gt;gop_size = 12;//每12帧一个帧 c-&gt;pix_fmt = AV_PIX_FMT_YUV420P; if (c-&gt;codec_id == AV_CODEC_ID_MPEG2VIDEO) &#123; c-&gt;max_b_frames = 2;//b帧数量 &#125; if (c-&gt;codec_id == AV_CODEC_ID_MPEG1VIDEO) &#123; c-&gt;mb_decision = 2;//FF_MB_DECISION_RD 2///失帧率 &#125; break; default: break; &#125; if (oc-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)//上下文需要全局头 c-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445static void open_video(AVFormatContext *oc, AVCodec *codec, OutputStream *ost, AVDictionary *opt_arg)&#123; int ret; AVCodecContext *c = ost-&gt;enc; AVDictionary *opt = NULL; av_dict_copy(&amp;opt, opt_arg, 0);//复制 ret = avcodec_open2(c, codec, &amp;opt);//根据codec初始化c av_dict_free(&amp;opt);//释放 if (ret &lt; 0) &#123; exit(1); &#125; ost-&gt;frame = alloc_picture(c-&gt;pix_fmt, c-&gt;width, c-&gt;height);//分配大小 if (!ost-&gt;frame) &#123; exit(1); &#125; ost-&gt;tmp_frame = NULL; if (c-&gt;pix_fmt != AV_PIX_FMT_YUV420P) &#123;//多存一个yuv420p用于转换 ost-&gt;tmp_frame = alloc_picture(AV_PIX_FMT_YUV420P, c-&gt;width, c-&gt;height); if (!ost-&gt;tmp_frame) &#123; exit(1); &#125; &#125; ret = avcodec_parameters_from_context(ost-&gt;st-&gt;codecpar, c);//复制流参数到复用器 if (ret &lt; 0) &#123; exit(1); &#125;&#125;static AVFrame *alloc_picture(enum AVPixelFormat pix_fmt, int width, int height)&#123; AVFrame *picture; int ret; picture = av_frame_alloc(); if (!picture) return NULL; picture-&gt;format = pix_fmt; picture-&gt;width = width; picture-&gt;height = height; ret = av_frame_get_buffer(picture, 32); if (ret &lt; 0) &#123; exit(1); &#125; return picture;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static void open_audio(AVFormatContext *oc, AVCodec *codec, OutputStream *ost, AVDictionary *opt_arg)&#123; AVCodecContext *c; int nb_samples; int ret; AVDictionary *opt = NULL; c = ost-&gt;enc; av_dict_copy(&amp;opt, opt_arg, 0); ret = avcodec_open2(c, codec, &amp;opt); av_dict_free(&amp;opt); if (ret &lt; 0) &#123; exit(1); &#125; ost-&gt;t = 0; ost-&gt;tincr = 2 * M_PI * 110.0 / c-&gt;sample_rate;//每秒增长110HZ ost-&gt;tincr2 = 2 * M_PI * 110.0 / c-&gt;sample_rate / c-&gt;sample_rate; if (c-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_VARIABLE_FRAME_SIZE)//编码器是否支持每次不同数量的样本 nb_samples = 10000; else nb_samples = c-&gt;frame_size; ost-&gt;frame = alloc_audio_frame(c-&gt;sample_fmt, c-&gt;channel_layout, c-&gt;sample_rate, nb_samples); ost-&gt;tmp_frame = alloc_audio_frame(AV_SAMPLE_FMT_S16, c-&gt;channel_layout, c-&gt;sample_rate, nb_samples); ret = avcodec_parameters_from_context(ost-&gt;st-&gt;codecpar, c);//根据codec填充par if (ret &lt; 0) &#123; exit(1); &#125;ost-&gt;swr_ctx = swr_alloc(); if (!ost-&gt;swr_ctx) &#123; exit(1); &#125; av_opt_set_int(ost-&gt;swr_ctx, "in_channel_count", c-&gt;channels, 0); av_opt_set_int(ost-&gt;swr_ctx, "in_sample_rate", c-&gt;sample_rate, 0); av_opt_set_sample_fmt(ost-&gt;swr_ctx, "in_sample_fmt", AV_SAMPLE_FMT_S16, 0); av_opt_set_int(ost-&gt;swr_ctx, "out_channel_count", c-&gt;channels, 0); av_opt_set_int(ost-&gt;swr_ctx, "out_sample_rate", c-&gt;sample_rate, 0); av_opt_set_sample_fmt(ost-&gt;swr_ctx, "out_sample_fmt", c-&gt;sample_fmt, 0); if ((ret = swr_init(ost-&gt;swr_ctx)) &lt; 0) &#123;//根据设置初始化上下文 exit(1); &#125;&#125;static AVFrame *alloc_audio_frame(enum AVSampleFormat sample_fmt,uint64_t channel_layout, int sample_rate, int nb_samples)&#123; AVFrame *frame = av_frame_alloc(); int ret; if (!frame) &#123; exit(1); &#125; frame-&gt;format = sample_fmt; frame-&gt;channel_layout = channel_layout; frame-&gt;sample_rate = sample_rate; frame-&gt;nb_samples = nb_samples; if (nb_samples) &#123; ret = av_frame_get_buffer(frame, 0); if (ret &lt; 0) &#123; exit(1); &#125; &#125; return frame;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172static int write_video_frame(AVFormatContext *oc, OutputStream *ost)&#123; int ret; AVCodecContext *c; AVFrame *frame; int got_packet = 0; AVPacket pkt = &#123; 0 &#125;; c = ost-&gt;enc; frame = get_video_frame(ost); av_init_packet(&amp;pkt);//初始化pkt ret = avcodec_encode_video2(c, &amp;pkt, frame, &amp;got_packet); if (ret &lt; 0) &#123; exit(1); &#125; if (got_packet) &#123; ret = write_frame(oc, &amp;c-&gt;time_base, ost-&gt;st, &amp;pkt);//写帧到oc &#125; else &#123; ret = 0; &#125; if (ret &lt; 0) &#123; exit(1); &#125; return (frame || got_packet) ? 0 : 1;//1表示结束&#125;static AVFrame *get_video_frame(OutputStream *ost)&#123; AVCodecContext *c = ost-&gt;enc; if (av_compare_ts(ost-&gt;next_pts, c-&gt;time_base,STREAM_DURATION, (AVRational) &#123; 1, 1 &#125;) &gt;= 0)//需要生成更多的帧 return NULL; if (av_frame_make_writable(ost-&gt;frame) &lt; 0)//确保帧可写 exit(1); if (c-&gt;pix_fmt != AV_PIX_FMT_YUV420P) &#123;//如果不是YUV420P进行转换 if (!ost-&gt;sws_ctx) &#123;//重采样上下文 ost-&gt;sws_ctx = sws_getContext(c-&gt;width, c-&gt;height, AV_PIX_FMT_YUV420P, c-&gt;width, c-&gt;height, c-&gt;pix_fmt, SCALE_FLAGS, NULL, NULL, NULL); if (!ost-&gt;sws_ctx) &#123; exit(1); &#125; &#125; fill_yuv_image(ost-&gt;tmp_frame, ost-&gt;next_pts, c-&gt;width, c-&gt;height); sws_scale(ost-&gt;sws_ctx, (const uint8_t * const *)ost-&gt;tmp_frame-&gt;data, ost-&gt;tmp_frame-&gt;linesize, 0, c-&gt;height, ost-&gt;frame-&gt;data, ost-&gt;frame-&gt;linesize); &#125; else &#123; fill_yuv_image(ost-&gt;frame, ost-&gt;next_pts, c-&gt;width, c-&gt;height); &#125; ost-&gt;frame-&gt;pts = ost-&gt;next_pts++; return ost-&gt;frame;&#125;static void fill_yuv_image(AVFrame *pict, int frame_index, int width, int height)//生成一个frame&#123; int x, y, i; i = frame_index; for (y = 0; y &lt; height; y++) for (x = 0; x &lt; width; x++) pict-&gt;data[0][y * pict-&gt;linesize[0] + x] = x + y + i * 3; for (y = 0; y &lt; height / 2; y++) &#123; for (x = 0; x &lt; width / 2; x++) &#123; pict-&gt;data[1][y * pict-&gt;linesize[1] + x] = 128 + y + i * 2; pict-&gt;data[2][y * pict-&gt;linesize[2] + x] = 64 + x + i * 5; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static int write_audio_frame(AVFormatContext *oc, OutputStream *ost)&#123; AVCodecContext *c; AVPacket pkt = &#123; 0 &#125;; AVFrame *frame; int ret; int got_packet; int dst_nb_samples; av_init_packet(&amp;pkt); c = ost-&gt;enc; frame = get_audio_frame(ost); if (frame) &#123; dst_nb_samples = av_rescale_rnd(swr_get_delay(ost-&gt;swr_ctx, c-&gt;sample_rate) + frame-&gt;nb_samples,c-&gt;sample_rate, c-&gt;sample_rate, AV_ROUND_UP); av_assert0(dst_nb_samples == frame-&gt;nb_samples);//检查样本是否丢失 ret = av_frame_make_writable(ost-&gt;frame);//确保帧是可写的 if (ret &lt; 0) exit(1); ret = swr_convert(ost-&gt;swr_ctx, ost-&gt;frame-&gt;data, dst_nb_samples, (const uint8_t **)frame-&gt;data, frame-&gt;nb_samples); if (ret &lt; 0) &#123; exit(1); &#125; frame = ost-&gt;frame; frame-&gt;pts = av_rescale_q(ost-&gt;samples_count, (AVRational) &#123; 1, c-&gt;sample_rate &#125;, c-&gt;time_base); ost-&gt;samples_count += dst_nb_samples; &#125; ret = avcodec_encode_audio2(c, &amp;pkt, frame, &amp;got_packet); if (ret &lt; 0) &#123; exit(1); &#125; if (got_packet) &#123; ret = write_frame(oc, &amp;c-&gt;time_base, ost-&gt;st, &amp;pkt); if (ret &lt; 0) &#123; exit(1); &#125; &#125; return (frame || got_packet) ? 0 : 1;&#125;static AVFrame *get_audio_frame(OutputStream *ost)&#123; AVFrame *frame = ost-&gt;tmp_frame; int j, i, v; int16_t *q = (int16_t*)frame-&gt;data[0]; if (av_compare_ts(ost-&gt;next_pts, ost-&gt;enc-&gt;time_base, STREAM_DURATION, (AVRational) &#123; 1, 1 &#125;) &gt;= 0) return NULL; for (j = 0; j &lt;frame-&gt;nb_samples; j++) &#123; v = (int)(sin(ost-&gt;t) * 10000); for (i = 0; i &lt; ost-&gt;enc-&gt;channels; i++) *q++ = v; ost-&gt;t += ost-&gt;tincr; ost-&gt;tincr += ost-&gt;tincr2; &#125; frame-&gt;pts = ost-&gt;next_pts; ost-&gt;next_pts += frame-&gt;nb_samples; return frame;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19.官方示例硬件解码简析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F19-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E7%A1%AC%E4%BB%B6%E8%A7%A3%E7%A0%81%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*** @file* HW-Accelerated decoding example.** @example hw_decode.c* This example shows how to do HW-accelerated decoding with output* frames from the HW video surfaces.*/av_hwdevice_find_type_by_name();//根据字符串找驱动/*列举所有驱动字符串while ((type = av_hwdevice_iterate_types(type)) != AV_HWDEVICE_TYPE_NONE) fprintf(stderr, " %s", av_hwdevice_get_type_name(type));*/avformat_open_input();//打开封装上下文avformat_find_stream_info();//查找流信息av_find_best_stream();//查找匹配的流for (i = 0;; i++) &#123; const AVCodecHWConfig *config = avcodec_get_hw_config(decoder, i);//根据decoder检索出config if (!config) &#123; fprintf(stderr, "Decoder %s does not support device type %s.\n", decoder-&gt;name, av_hwdevice_get_type_name(type)); return -1; &#125; if (config-&gt;methods &amp; AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &amp;&amp; config-&gt;device_type == type) &#123; hw_pix_fmt = config-&gt;pix_fmt; break; &#125;&#125;avcodec_alloc_context3();//分配并初始化codecCtxavcodec_parameters_to_context();//根据par填充codecCtxcodecCtx-&gt;get_format = get_hw_format;//提供回调av_hwdevice_ctx_create();//创建驱动上下文codecCtx-&gt;hw_device_ctx = av_buffer_ref(deviceCtx);//创建一个新的引用avcodec_open2();//根据codec创建codecCtxwhile (ret &gt;= 0) &#123; if ((ret = av_read_frame(input_ctx, &amp;packet)) &lt; 0)//读包 break; if (video_stream == packet.stream_index) ret = decode_write(decoder_ctx, &amp;packet);//解 av_packet_unref(&amp;packet);//释放&#125;packet.data = NULL;packet.size = 0;ret = decode_write(decoder_ctx, &amp;packet);av_packet_unref(&amp;packet);avcodec_free_context();avformat_close_input();av_buffer_unref(); 12345678910111213static enum AVPixelFormat get_hw_format(AVCodecContext *ctx, const enum AVPixelFormat *pix_fmts)&#123; const enum AVPixelFormat *p; for (p = pix_fmts; *p != -1; p++) &#123; if (*p == hw_pix_fmt) return *p; &#125; fprintf(stderr, "Failed to get HW surface format.\n"); return AV_PIX_FMT_NONE;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static int decode_write(AVCodecContext *avctx, AVPacket *packet)&#123; ret = avcodec_send_packet(avctx, packet);//发送到解码器 if (ret &lt; 0) &#123; return ret; &#125; while (1) &#123; if (!(frame = av_frame_alloc()) || !(sw_frame = av_frame_alloc())) &#123; ret = AVERROR(ENOMEM); goto fail; &#125; ret = avcodec_receive_frame(avctx, frame);//从解码器中读frame if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) &#123; av_frame_free(&amp;frame); av_frame_free(&amp;sw_frame); return 0; &#125; else if (ret &lt; 0) &#123; goto fail; &#125; if (frame-&gt;format == hw_pix_fmt) &#123; if ((ret = av_hwframe_transfer_data(sw_frame, frame, 0)) &lt; 0) &#123;//从gpu读到cpu goto fail; &#125; tmp_frame = sw_frame; &#125; else tmp_frame = frame; size = av_image_get_buffer_size(tmp_frame-&gt;format, tmp_frame-&gt;width, tmp_frame-&gt;height, 1);//求数据大小 buffer = av_malloc(size);//申请空间 if (!buffer) &#123; ret = AVERROR(ENOMEM); goto fail; &#125; ret = av_image_copy_to_buffer(buffer, size, (const uint8_t * const *)tmp_frame-&gt;data, (const int *)tmp_frame-&gt;linesize, tmp_frame-&gt;format, tmp_frame-&gt;width, tmp_frame-&gt;height, 1);//将frame数据复制到buffer if (ret &lt; 0) &#123; goto fail; &#125; if ((ret = fwrite(buffer, 1, size, output_file)) &lt; 0) &#123; goto fail; &#125; fail: av_frame_free(&amp;frame); av_frame_free(&amp;sw_frame); av_freep(&amp;buffer); if (ret &lt; 0) return ret; &#125;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18.官方示例HTTP多连接发送文件简析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F18-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8Bhttp%E5%A4%9A%E8%BF%9E%E6%8E%A5%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021/*** @file* libavformat multi-client network API usage example.** @example http_multiclient.c* This example will serve a file without decoding or demuxing it over http.* Multiple clients can connect and will receive the same file.*///out_url是服务器 in_url是文件av_format_network_init();//初始化网络库 只在线程安全时或者GnuTLS或者OpenSSLav_dict_set();//设置AVDictionaryavio_open2();//打开io上下文avio_accept();//从s服务端读取上下文到cfork();//分成两个同样的进程 父进程pid为正数 子进程pid为0//pid==0 // process_client();单独进程// avio_close();关闭s上下文//pid&gt;0// avio_close();关闭c上下文avio_close();//s 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static void process_client(AVIOContext *client, const char *in_uri)&#123; while ((ret = avio_handshake(client)) &gt; 0) &#123;//通过握手协议获取一个新连接 av_opt_get(client, "resource", AV_OPT_SEARCH_CHILDREN, &amp;resource);//获取resource属性 if (resource &amp;&amp; strlen(resource))//不是 ""和null break; av_freep(&amp;resource);//释放掉 &#125; if (ret &lt; 0) goto end; av_log(client, AV_LOG_TRACE, "resource=%p\n", resource); if (resource &amp;&amp; resource[0] == '/' &amp;&amp; !strcmp((resource + 1), in_uri)) &#123;//检查链接合法性 reply_code = 200; &#125; else &#123; reply_code = AVERROR_HTTP_NOT_FOUND; &#125; if ((ret = av_opt_set_int(client, "reply_code", reply_code, AV_OPT_SEARCH_CHILDREN)) &lt; 0) &#123;//设置到一个子对象上的reply_code av_log(client, AV_LOG_ERROR, "Failed to set reply_code: %s.\n", av_err2str(ret)); goto end; &#125; av_log(client, AV_LOG_TRACE, "Set reply code to %d\n", reply_code); while ((ret = avio_handshake(client)) &gt; 0);//正在握手 在这里等待 if (ret &lt; 0) goto end; fprintf(stderr, "Handshake performed.\n"); if (reply_code != 200) goto end; fprintf(stderr, "Opening input file.\n"); if ((ret = avio_open2(&amp;input, in_uri, AVIO_FLAG_READ, NULL, NULL)) &lt; 0) &#123;//通过url创建一个io上下文 av_log(input, AV_LOG_ERROR, "Failed to open input: %s: %s.\n", in_uri, av_err2str(ret)); goto end; &#125; for (;;) &#123; n = avio_read(input, buf, sizeof(buf));//读 if (n &lt; 0) &#123; if (n == AVERROR_EOF) break; av_log(input, AV_LOG_ERROR, "Error reading from input: %s.\n", av_err2str(n)); break; &#125; avio_write(client, buf, n);//写 avio_flush(client);//刷新 &#125;end: avio_flush(); avio_close(); avio_close(); av_freep();&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17.官方示例提取帧运动矢量简析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F17-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E6%8F%90%E5%8F%96%E5%B8%A7%E8%BF%90%E5%8A%A8%E7%9F%A2%E9%87%8F%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718//extract_mvs.cavformat_open_input();//打开封装上下文avformat_find_stream_info();//读取封装上下文的流信息open_codec_context();//从ctx中找出stream codecCtx codecav_dump_format();//输出封装信息av_frame_alloc();//申请framewhile (av_read_frame(fmt_ctx, &amp;pkt) &gt;= 0) &#123;//读取一个Pkt if (pkt.stream_index == video_stream_idx) ret = decode_packet(&amp;pkt);//解码 av_packet_unref(&amp;pkt);//释放 if (ret &lt; 0) break;&#125;decode_packet(NULL);//缓存avcodec_free_context();//释放codecCtxavformat_close_input();//释放ctxav_frame_free();//释放frame 123456789101112131415161718192021222324252627282930313233343536static int open_codec_context(AVFormatContext *fmt_ctx, enum AVMediaType type)&#123; int ret; AVStream *st; AVCodecContext *dec_ctx = NULL; AVCodec *dec = NULL; AVDictionary *opts = NULL; ret = av_find_best_stream(fmt_ctx, type, -1, -1, &amp;dec, 0);//找出流index和编码器 if (ret &lt; 0) &#123; fprintf(stderr, "Could not find %s stream in input file '%s'\n", av_get_media_type_string(type), src_filename);//返回AVMediaType的描述 return ret; &#125; else &#123; int stream_idx = ret; st = fmt_ctx-&gt;streams[stream_idx]; dec_ctx = avcodec_alloc_context3(dec);//申请编码上下文 if (!dec_ctx) &#123; return AVERROR(EINVAL); &#125; ret = avcodec_parameters_to_context(dec_ctx, st-&gt;codecpar);//根据codecpar的值填充ctx内 if (ret &lt; 0) &#123; return ret; &#125; av_dict_set(&amp;opts, "flags2", "+export_mvs", 0);//修改AVDictionary参数 因都是私有 需要通过函数修改 if ((ret = avcodec_open2(dec_ctx, dec, &amp;opts)) &lt; 0) &#123;//将dec和ctx绑定 fprintf(stderr, "Failed to open %s codec\n", av_get_media_type_string(type)); return ret; &#125; video_stream_idx = stream_idx; video_stream = fmt_ctx-&gt;streams[video_stream_idx]; video_dec_ctx = dec_ctx; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static int decode_packet(const AVPacket *pkt)&#123; int ret = avcodec_send_packet(video_dec_ctx, pkt);//将压缩包交给解码器 if (ret &lt; 0) &#123; return ret; &#125; while (ret &gt;= 0) &#123; ret = avcodec_receive_frame(video_dec_ctx, frame);//从解码器中返回数据 if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) &#123;//输入错误 或者已经解码缓存中所有数据 break; &#125; else if (ret &lt; 0) &#123; return ret; &#125; if (ret &gt;= 0) &#123; int i; AVFrameSideData *sd;//保存AVFrame边缘的数据 video_frame_count++; sd = av_frame_get_side_data(frame, AV_FRAME_DATA_MOTION_VECTORS);//从frame中取出运动矢量数据 保存在sd if (sd) &#123; const AVMotionVector *mvs = (const AVMotionVector *)sd-&gt;data;//转成运动矢量 for (i = 0; i &lt; sd-&gt;size / sizeof(*mvs); i++) &#123;//mvs是AVMotionVector数组指针 mv是一个数据指针 const AVMotionVector *mv = &amp;mvs[i];//取出一组数据 printf("%d,%2d,%2d,%2d,%4d,%4d,%4d,%4d,0x%"PRIx64"\n", video_frame_count, mv-&gt;source, mv-&gt;w, mv-&gt;h, mv-&gt;src_x, mv-&gt;src_y, mv-&gt;dst_x, mv-&gt;dst_y, mv-&gt;flags); &#125; &#125; av_frame_unref(frame);//清掉frame缓存 &#125; &#125; return 0;&#125;/*struct p &#123; p(int aa,int bb):a(aa),b(bb)&#123;&#125; int a; int b;&#125;;p aa[]=&#123; p&#123; 1,2 &#125;, p&#123; 2,3 &#125;, p&#123; 3,4 &#125;&#125;;p * pa = aa;//pa即mvsfor (int i = 0; i &lt; sizeof(aa) / sizeof(*pa); i++) &#123; p *PPA = &amp;pa[i];//取出一个 &amp;pa[i]==pa+i QMessageBox::about(nullptr, "", QString("%1 %2").arg(PPA-&gt;a).arg( PPA-&gt;b));&#125; */]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16.官方示例解码音视频简析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F16-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E7%A0%81%E9%9F%B3%E8%A7%86%E9%A2%91%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @file * audio decoding with libavcodec API example * * @example decode_audio.c */av_packet_alloc();//分配并初始化pktavcodec_find_decoder();//根据id找一个解码器codecav_parser_init();//根据编码器id返回一个解析器上下文parserctxavcodec_alloc_context3();//根据codec分配ctxavcodec_open2();//用编码器打开上下文data = inbuf;//一个数组data_size = fread(inbuf, 1, AUDIO_INBUF_SIZE, f);while (data_size &gt; 0) &#123; if (!frame) &#123; if (!(frame = av_frame_alloc())) &#123;//分配和初始化完整包 exit(1); &#125; &#125; ret = av_parser_parse2(parser, c, &amp;pkt-&gt;data, &amp;pkt-&gt;size,data, data_size, AV_NOPTS_VALUE, AV_NOPTS_VALUE, 0);//从上下文中解析一个压缩包 if (ret &lt; 0) &#123; exit(1); &#125; data += ret;//指针移动 data_size -= ret;//缓存数量减少 if (pkt-&gt;size) decode(c, frame, pkt, outfile);//解码 并写到文件中去 if (data_size &lt; AUDIO_REFILL_THRESH) &#123;//若数据少于AUDIO_REFILL_THRESH，就去文件中读取缺少的部分 直到达到AUDIO_INBUF_SIZE memmove(inbuf, data, data_size);//将inbuf内容变为由data开始 连续data_size data = inbuf; len = fread(data + data_size, 1,AUDIO_INBUF_SIZE - data_size, f); if (len &gt; 0) data_size += len; &#125;&#125;pkt-&gt;data = NULL;pkt-&gt;size = 0;decode(c, frame, pkt, outfile);//有可能文件没解析完avcodec_free_context();//关闭编码器上下文av_parser_close();//关闭解析器av_frame_free();//释放帧av_packet_free();//释放压缩包 1234567891011121314151617181920212223242526272829303132333435/** * @file * video decoding with libavcodec API example * * @example decode_video.c */av_packet_alloc();//初始化pktmemset(inbuf + INBUF_SIZE, 0, AV_INPUT_BUFFER_PADDING_SIZE);//初始化缓存数组 防止越界avcodec_find_decoder();//查找一个解码器 codecav_parser_init();//初始化parseravcodec_alloc_contex3();//初始化ctxav_frame_alloc();//初始化framewhile (!feof(f)) &#123; data_size = fread(inbuf, 1, INBUF_SIZE, f); if (!data_size) break; data = inbuf; while (data_size &gt; 0) &#123; ret = av_parser_parse2(parser, c, &amp;pkt-&gt;data, &amp;pkt-&gt;size, data, data_size, AV_NOPTS_VALUE, AV_NOPTS_VALUE, 0);//根据parser拆分一个压缩包 if (ret &lt; 0) &#123; exit(1); &#125; data += ret; data_size -= ret; if (pkt-&gt;size) decode(c, frame, pkt, outfilename); &#125;&#125;decode(c, frame, NULL, outfilename);//缓存av_parser_close();avcodec_free_context();av_frame_free();av_packet_free(); 12345678910111213141516171819202122232425262728293031323334static void decode(AVCodecContext *dec_ctx, AVFrame *frame, AVPacket *pkt, const char *filename)&#123; char buf[1024]; int ret; ret = avcodec_send_packet(dec_ctx, pkt);//将ctx中的一些字段保存到解码器中 去解码pkt if (ret &lt; 0) &#123; exit(1); &#125; while (ret &gt;= 0) &#123; ret = avcodec_receive_frame(dec_ctx, frame);//返回解码后的数据到frame if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) return; else if (ret &lt; 0) &#123; exit(1); &#125; /*video printf("saving frame %3d\n", dec_ctx-&gt;frame_number); fflush(stdout); for (i = 0; i &lt; frame-&gt;height; i++) fwrite(frame-&gt;data[0] + i * frame-&gt;linesize[0], 1, frame-&gt;width, f); */ /*audio: data_size = av_get_bytes_per_sample(dec_ctx-&gt;sample_fmt);//每个样本的字节数 if (data_size &lt; 0) &#123; exit(1); &#125; for (i = 0; i &lt; frame-&gt;nb_samples; i++) for (ch = 0; ch &lt; dec_ctx-&gt;channels; ch++) fwrite(frame-&gt;data[ch] + data_size*i, 1, data_size, f); */ &#125;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15.官方示例AVIO读取源码简析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F15-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8Bavio%E8%AF%BB%E5%8F%96%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1234567891011//avio_dir_cmd.cav_log_set_level();//设置日志等级avformat_network_init();//GnuTLS和OpenSSL的线程安全考虑 否则就不需要再使用avpriv_io_move();//移动或者重名avpriv_io_delete();//删除avio_open_dir();//打开目录avio_read_dir();//从目录读取一个条目avio_free_directory_entry();//关闭条目avformat_network_deinit();//有avformat_network_init必须有这个进行关闭 1234567891011121314151617181920212223242526272829303132333435363738/** * @file * libavformat AVIOContext API example. * * Make libavformat demuxer access media content through a custom * AVIOContext read callback. * @example avio_reading.c */av_file_map();//读取文件到buffer和buffersizeavformat_alloc_context();//分配和初始化封装上下文ctxav_malloc();//申请一块空间得到ctxbuffer//bd结构体 包含buffer和buffersizeavio_alloc_context(ctxbuffer, ctxbuffersize,0, &amp;bd, &amp;read_packet, NULL, NULL);//为比特流上下文申请空间 得到avio_ctxctx-&gt;pb = avio_ctx;avformat_open_input();//打开流avformat_find_stream_info();//读文件流信息av_dump_format();//打印封装上下文avformat_close_input();//关闭封装上下文并指为NULLav_freep();//av_malloc()av_context_free();//关闭比特流上下文av_file_unmap();//av_file_map()static int read_packet(void *opaque, uint8_t *buf, int buf_size)//从opaque中读取buf_size长的数据保存在buf&#123; struct buffer_data *bd = (struct buffer_data *)opaque; buf_size = FFMIN(buf_size, bd-&gt;size); if (!buf_size) return AVERROR_EOF; printf("ptr:%p size:%zu\n", bd-&gt;ptr, bd-&gt;size); /* copy internal buffer data to buf */ memcpy(buf, bd-&gt;ptr, buf_size); bd-&gt;ptr += buf_size; bd-&gt;size -= buf_size; return buf_size;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14.官方示例编码音视频简析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F14-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E7%BC%96%E7%A0%81%E9%9F%B3%E8%A7%86%E9%A2%91%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @file * audio encoding with libavcodec API example. * * @example encode_audio.c */avcodec_find_encoder();//查找一个编码器encodecavcodec_alloc_contex3();//根据编码器 申请一个编码上下文ctxctx-&gt;bit_rate;ctx-&gt;sample_fmt;//根据encodec-&gt;sample_fmts查看是否支持ctx-&gt;sample_rate;//根据encodec-&gt;supported_samplerates找一个最适合的ctx-&gt;channel_layout;//根据const uint64_t *p=encodec-&gt;channel_layouts av_get_channel_layout_nb_channels(*p)找最大的通道ctx-&gt;channels;//av_get_channel_layout_nb_channels(ctx-&gt;channel_layout)avcodec_open2();//打开编码器与上下文绑定av_packet_alloc();//分配并初始化一个pktav_frame_alloc();//分配并初始化一个frameframe-&gt;nb_samples=ctx-&gt;frame_size;frame-&gt;format=ctx-&gt;ctx-&gt;sample_fmt;frame-&gt;channel_layout=ctx-&gt;channel_layout;av_frame_get_buffer();//为frame分配buff空间av_frame_make_writable();//确定帧是可写的/ *以每秒110Hz增加频率tincr = 2 * M_PI * 110.0 / c-&gt; sample_rate; tincr2 = 2 * M_PI * 110.0 / c-&gt; sample_rate / c-&gt; sample_rate; 填充一段正弦波*/t = 0;tincr = 2 * M_PI * 440.0 / ctx-&gt;sample_rate;for (i = 0; i &lt; 200; i++) &#123; ret = av_frame_make_writable(frame); if (ret &lt; 0) exit(1); samples = (uint16_t*)frame-&gt;data[0]; for (j = 0; j &lt; c-&gt;frame_size; j++) &#123; samples[2 * j] = (int)(sin(t) * 10000); for (k = 1; k &lt; c-&gt;channels; k++) samples[2 * j + k] = samples[2 * j]; t += tincr; &#125; encode(ctx, frame, pkt, f);//avcodec_send_frame avcodec_receive_packet av_packet_unref&#125;encode(ctx, NULL, pkt, f);av_frame_free();//释放freamav_packet_free();//释放pktavcodec_free_contex();//释放编码上下文 123456789101112131415161718192021222324252627282930313233/*** @file* video encoding with libavcodec API example** @example encode_video.c*/avcodec_find_encoder_by_name();//根据名字查找编码器encodecavcodec_alloc_context3();//根据编码器 申请编码上下文ctxav_packet_alloc();//分配pktctx-&gt;bit_rate;ctx-&gt;width;ctx-&gt;height;ctx-&gt;time_base;//AVRational&#123;1,25&#125; fps25ctx-&gt;framerate;//AVRational&#123;25,1&#125;ctx-&gt;gop_size;//多久一个关键帧ctx-&gt;max_b_frames;//最多b帧ctx-&gt;pix_fmt;//帧格式if (codec-&gt;id == AV_CODEC_ID_H264) av_opt_set(ctx-&gt;priv_data, "preset", "slow", 0);/*AVOption除了可以对常用的结构体AVFormatContext、AVCodecContext等进行设置之外，还可以对它们的私有数据priv_data进行赋值。这些字段里面通常存储了各种编码器特有的结构体。如使用libx264进行编码的时候，通过AVCodecContext的priv_data字段可以对X264Context（libavcodec\libx264.c）结构体中的变量进行赋值，设置preset、profile等*/avcodec_open2();//打开编码器与上下文绑定av_frame_alloc();//初始化frameframe-&gt;format=ctx-&gt;pix_fmt;frame-&gt;width=ctx-&gt;width;frame-&gt;height=ctx-&gt;height;av_frame_get_buffer();//为frame申请内部空间av_frame_make_writable();//确定帧是可写的填满frame-&gt;data;encodec();avcodec_free_context();av_frame_free();av_packet_free(); 1234567891011121314151617181920212223242526encode(AVCodecContext *enc_ctx, AVFrame *frame, AVPacket *pkt,FILE *outfile)&#123; int ret; /* send the frame to the encoder */ if (frame) printf("Send frame %3"PRId64"\n", frame-&gt;pts); ret = avcodec_send_frame(enc_ctx, frame); if (ret &lt; 0) &#123; fprintf(stderr, "Error sending a frame for encoding\n"); exit(1); &#125; while (ret &gt;= 0) &#123; ret = avcodec_receive_packet(enc_ctx, pkt); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) return; else if (ret &lt; 0) &#123; fprintf(stderr, "Error during encoding\n"); exit(1); &#125; printf("Write packet %3"PRId64" (size=%5d)\n", pkt-&gt;pts, pkt-&gt;size); fwrite(pkt-&gt;data, 1, pkt-&gt;size, outfile); av_packet_unref(pkt); &#125;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13.官方示例解复用和解编码.c]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F13-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%92%8C%E8%A7%A3%E7%BC%96%E7%A0%81-c%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363extern "C" &#123;#include &lt;libavutil/imgutils.h&gt;#include &lt;libavutil/samplefmt.h&gt;#include &lt;libavutil/timestamp.h&gt;#include &lt;libavformat/avformat.h&gt;&#125;static AVFormatContext *fmt_ctx = NULL;static AVCodecContext *video_dec_ctx = NULL, *audio_dec_ctx;static int width, height;static enum AVPixelFormat pix_fmt;static AVStream *video_stream = NULL, *audio_stream = NULL;static const char *src_filename = NULL;static const char *video_dst_filename = NULL;static const char *audio_dst_filename = NULL;static FILE *video_dst_file = NULL;static FILE *audio_dst_file = NULL;static uint8_t *video_dst_data[4] = &#123; NULL &#125;;static int video_dst_linesize[4];static int video_dst_bufsize;static int video_stream_idx = -1, audio_stream_idx = -1;static AVFrame *frame = NULL;static AVPacket pkt;static int video_frame_count = 0;static int audio_frame_count = 0;/* Enable or disable frame reference counting. You are not supposed to support* both paths in your application but pick the one most appropriate to your* needs. Look for the use of refcount in this example to see what are the* differences of API usage between them. */static int refcount = 0;static int decode_packet(int *got_frame, int cached)&#123; int ret = 0; int decoded = pkt.size; *got_frame = 0; if (pkt.stream_index == video_stream_idx) &#123; /* decode video frame */ ret = avcodec_decode_video2(video_dec_ctx, frame, got_frame, &amp;pkt);//解码帧 已经弃用不再维护 if (ret &lt; 0) &#123; fprintf(stderr, "Error decoding video frame (%s)\n", av_err2str(ret)); return ret; &#125; if (*got_frame) &#123; if (frame-&gt;width != width || frame-&gt;height != height || frame-&gt;format != pix_fmt) &#123;//帧大小不对 /* To handle this change, one could call av_image_alloc again and * decode the following frames into another rawvideo file. */ fprintf(stderr, "Error: Width, height and pixel format have to be " "constant in a rawvideo file, but the width, height or " "pixel format of the input video changed:\n" "old: width = %d, height = %d, format = %s\n" "new: width = %d, height = %d, format = %s\n", width, height, av_get_pix_fmt_name(pix_fmt), frame-&gt;width, frame-&gt;height, av_get_pix_fmt_name(frame-&gt;format)); return -1; &#125; printf("video_frame%s n:%d coded_n:%d\n", cached ? "(cached)" : "", video_frame_count++, frame-&gt;coded_picture_number); /* copy decoded frame to destination buffer: * this is required since rawvideo expects non aligned data */ av_image_copy(video_dst_data, video_dst_linesize, (const uint8_t **)(frame-&gt;data), frame-&gt;linesize, pix_fmt, width, height);//复制帧数据到video_dst_data和video_dst_linesize 因为是rawvideo /* write to rawvideo file */ fwrite(video_dst_data[0], 1, video_dst_bufsize, video_dst_file); &#125; &#125; else if (pkt.stream_index == audio_stream_idx) &#123; /* decode audio frame */ ret = avcodec_decode_audio4(audio_dec_ctx, frame, got_frame, &amp;pkt);//解码音频 已经放弃维护 if (ret &lt; 0) &#123; fprintf(stderr, "Error decoding audio frame (%s)\n", av_err2str(ret)); return ret; &#125; /* Some audio decoders decode only part of the packet, and have to be * called again with the remainder of the packet data. * Sample: fate-suite/lossless-audio/luckynight-partial.shn * Also, some decoders might over-read the packet. */ decoded = FFMIN(ret, pkt.size);//该帧的大小 if (*got_frame) &#123; size_t unpadded_linesize = frame-&gt;nb_samples * av_get_bytes_per_sample(frame-&gt;format);//采样数*采样样本大小 printf("audio_frame%s n:%d nb_samples:%d pts:%s\n", cached ? "(cached)" : "", audio_frame_count++, frame-&gt;nb_samples, av_ts2timestr(frame-&gt;pts, &amp;audio_dec_ctx-&gt;time_base)); /* Write the raw audio data samples of the first plane. This works * fine for packed formats (e.g. AV_SAMPLE_FMT_S16). However, * most audio decoders output planar audio, which uses a separate * plane of audio samples for each channel (e.g. AV_SAMPLE_FMT_S16P). * In other words, this code will write only the first audio channel * in these cases. * You should use libswresample or libavfilter to convert the frame * to packed data. */ fwrite(frame-&gt;extended_data[0], 1, unpadded_linesize, audio_dst_file);//对于plane是可以的 planar需要使用libswresample or libavfilter进行优化 &#125; &#125; /* If we use frame reference counting, we own the data and need * to de-reference it when we don't use it anymore */ if (*got_frame &amp;&amp; refcount) av_frame_unref(frame); return decoded;&#125;static int open_codec_context(int *stream_idx, AVCodecContext **dec_ctx, AVFormatContext *fmt_ctx, enum AVMediaType type)//根据type从fmt_ctx中返回stream_idx和dec_ctx&#123; int ret, stream_index; AVStream *st; AVCodec *dec = NULL; AVDictionary *opts = NULL; ret = av_find_best_stream(fmt_ctx, type, -1, -1, NULL, 0);//根据type 查找流的下标 if (ret &lt; 0) &#123; fprintf(stderr, "Could not find %s stream in input file '%s'\n", av_get_media_type_string(type), src_filename); return ret; &#125; else &#123; stream_index = ret; st = fmt_ctx-&gt;streams[stream_index]; /* find decoder for the stream */ dec = avcodec_find_decoder(st-&gt;codecpar-&gt;codec_id);//根据流保存的编码id 找到解码器 if (!dec) &#123; fprintf(stderr, "Failed to find %s codec\n", av_get_media_type_string(type)); return AVERROR(EINVAL); &#125; /* Allocate a codec context for the decoder */ *dec_ctx = avcodec_alloc_context3(dec);//根据编解码器 为ctx分配空间和初始化 if (!*dec_ctx) &#123; fprintf(stderr, "Failed to allocate the %s codec context\n", av_get_media_type_string(type)); return AVERROR(ENOMEM); &#125; /* Copy codec parameters from input stream to output codec context */ if ((ret = avcodec_parameters_to_context(*dec_ctx, st-&gt;codecpar)) &lt; 0) &#123;//将codecpar的字段替换dec_ctx内相应的字段 fprintf(stderr, "Failed to copy %s codec parameters to decoder context\n", av_get_media_type_string(type)); return ret; &#125; /* Init the decoders, with or without reference counting */ av_dict_set(&amp;opts, "refcounted_frames", refcount ? "1" : "0", 0);//设置AVDictionary属性 if ((ret = avcodec_open2(*dec_ctx, dec, &amp;opts)) &lt; 0) &#123;//根据AVcode初始化一个编解码上下文 fprintf(stderr, "Failed to open %s codec\n", av_get_media_type_string(type)); return ret; &#125; *stream_idx = stream_index; &#125; return 0;&#125;static int get_format_from_sample_fmt(const char **fmt, enum AVSampleFormat sample_fmt)&#123; int i; struct sample_fmt_entry &#123; enum AVSampleFormat sample_fmt; const char *fmt_be, *fmt_le; &#125; sample_fmt_entries[] = &#123; &#123; AV_SAMPLE_FMT_U8, "u8", "u8" &#125;, &#123; AV_SAMPLE_FMT_S16, "s16be", "s16le" &#125;, &#123; AV_SAMPLE_FMT_S32, "s32be", "s32le" &#125;, &#123; AV_SAMPLE_FMT_FLT, "f32be", "f32le" &#125;, &#123; AV_SAMPLE_FMT_DBL, "f64be", "f64le" &#125;, &#125;; *fmt = NULL; for (i = 0; i &lt; FF_ARRAY_ELEMS(sample_fmt_entries); i++) &#123; struct sample_fmt_entry *entry = &amp;sample_fmt_entries[i]; if (sample_fmt == entry-&gt;sample_fmt) &#123; *fmt = AV_NE(entry-&gt;fmt_be, entry-&gt;fmt_le);//大小端 return 0; &#125; &#125; fprintf(stderr, "sample format %s is not supported as output format\n", av_get_sample_fmt_name(sample_fmt)); return -1;&#125;int main(int argc, char **argv)&#123; int ret = 0, got_frame; if (argc != 4 &amp;&amp; argc != 5) &#123; fprintf(stderr, "usage: %s [-refcount] input_file video_output_file audio_output_file\n" "API example program to show how to read frames from an input file.\n" "This program reads frames from a file, decodes them, and writes decoded\n" "video frames to a rawvideo file named video_output_file, and decoded\n" "audio frames to a rawaudio file named audio_output_file.\n\n" "If the -refcount option is specified, the program use the\n" "reference counting frame system which allows keeping a copy of\n" "the data for longer than one decode call.\n" "\n", argv[0]);//refcount 引用计数帧系统，但是保存副本的时间比编码长 exit(1); &#125; if (argc == 5 &amp;&amp; !strcmp(argv[1], "-refcount")) &#123; refcount = 1; argv++; &#125; src_filename = argv[1]; video_dst_filename = argv[2]; audio_dst_filename = argv[3]; /* open input file, and allocate format context */ if (avformat_open_input(&amp;fmt_ctx, src_filename, NULL, NULL) &lt; 0) &#123;//打开输入流，并且读取文件头 fmt_ctx为NULL时 不必再调用avformat_alloc_context fprintf(stderr, "Could not open source file %s\n", src_filename); exit(1); &#125; /* retrieve stream information */ if (avformat_find_stream_info(fmt_ctx, NULL) &lt; 0) &#123;//查找流信息 fprintf(stderr, "Could not find stream information\n"); exit(1); &#125; if (open_codec_context(&amp;video_stream_idx, &amp;video_dec_ctx, fmt_ctx, AVMEDIA_TYPE_VIDEO) &gt;= 0) &#123;//查找视频流 并得到编码器 video_stream = fmt_ctx-&gt;streams[video_stream_idx]; video_dst_file = fopen(video_dst_filename, "wb"); if (!video_dst_file) &#123; fprintf(stderr, "Could not open destination file %s\n", video_dst_filename); ret = 1; goto end; &#125; /* allocate image where the decoded image will be put */ width = video_dec_ctx-&gt;width; height = video_dec_ctx-&gt;height; pix_fmt = video_dec_ctx-&gt;pix_fmt; ret = av_image_alloc(video_dst_data, video_dst_linesize, width, height, pix_fmt, 1);//根据width height pix_fmt分配video_dst_data和video_dst_linesize的一张图片 if (ret &lt; 0) &#123; fprintf(stderr, "Could not allocate raw video buffer\n"); goto end; &#125; video_dst_bufsize = ret; &#125; if (open_codec_context(&amp;audio_stream_idx, &amp;audio_dec_ctx, fmt_ctx, AVMEDIA_TYPE_AUDIO) &gt;= 0) &#123;//查找音频流 并得到编码器 audio_stream = fmt_ctx-&gt;streams[audio_stream_idx]; audio_dst_file = fopen(audio_dst_filename, "wb"); if (!audio_dst_file) &#123; fprintf(stderr, "Could not open destination file %s\n", audio_dst_filename); ret = 1; goto end; &#125; &#125; /* dump input information to stderr */ av_dump_format(fmt_ctx, 0, src_filename, 0);//打印输入输出封装上下文 if (!audio_stream &amp;&amp; !video_stream) &#123; fprintf(stderr, "Could not find audio or video stream in the input, aborting\n"); ret = 1; goto end; &#125; frame = av_frame_alloc();//初始化帧 if (!frame) &#123; fprintf(stderr, "Could not allocate frame\n"); ret = AVERROR(ENOMEM); goto end; &#125; /* initialize packet, set data to NULL, let the demuxer fill it */ av_init_packet(&amp;pkt);//初始化压缩包 pkt.data = NULL; pkt.size = 0; if (video_stream) printf("Demuxing video from file '%s' into '%s'\n", src_filename, video_dst_filename); if (audio_stream) printf("Demuxing audio from file '%s' into '%s'\n", src_filename, audio_dst_filename); /* read frames from the file */ while (av_read_frame(fmt_ctx, &amp;pkt) &gt;= 0) &#123; AVPacket orig_pkt = pkt; do &#123; ret = decode_packet(&amp;got_frame, 0);//解码一帧 if (ret &lt; 0) break; pkt.data += ret;//数据指针移动 pkt.size -= ret;//数据长度减少 &#125; while (pkt.size &gt; 0); av_packet_unref(&amp;orig_pkt);//删掉缓存 &#125; /* flush cached frames */ pkt.data = NULL; pkt.size = 0; do &#123; decode_packet(&amp;got_frame, 1); &#125; while (got_frame);//清除缓存中的帧 printf("Demuxing succeeded.\n"); if (video_stream) &#123; printf("Play the output video file with the command:\n" "ffplay -f rawvideo -pix_fmt %s -video_size %dx%d %s\n", av_get_pix_fmt_name(pix_fmt), width, height, video_dst_filename); &#125; if (audio_stream) &#123; enum AVSampleFormat sfmt = audio_dec_ctx-&gt;sample_fmt; int n_channels = audio_dec_ctx-&gt;channels; const char *fmt; if (av_sample_fmt_is_planar(sfmt)) &#123; const char *packed = av_get_sample_fmt_name(sfmt); printf("Warning: the sample format the decoder produced is planar " "(%s). This example will output the first channel only.\n", packed ? packed : "?"); sfmt = av_get_packed_sample_fmt(sfmt); n_channels = 1; &#125; if ((ret = get_format_from_sample_fmt(&amp;fmt, sfmt)) &lt; 0) goto end; printf("Play the output audio file with the command:\n" "ffplay -f %s -ac %d -ar %d %s\n", fmt, n_channels, audio_dec_ctx-&gt;sample_rate, audio_dst_filename); &#125;end: avcodec_free_context(&amp;video_dec_ctx);//释放视频解码器 avcodec_free_context(&amp;audio_dec_ctx);//释放音频解码器 avformat_close_input(&amp;fmt_ctx);//释放封装上下文 if (video_dst_file) fclose(video_dst_file); if (audio_dst_file) fclose(audio_dst_file); av_frame_free(&amp;frame);//释放帧 av_free(video_dst_data[0]);//释放图片 return ret &lt; 0;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-12FFmepg命令行参数]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-12ffmepg%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[命令行参数FFmpeg.exe官网详细 FFplay.exe雷神 官网 FFprobe.exe官网 123456789101112ffmpeg -h type=name 查看属性的参数 type是下表通用上的，去掉s例ffmpeg -h filter=atempo 查看音频播放速率输出Filter atempo Adjust audio tempo. Inputs: #0: default (audio) Outputs:25 #0: default (audio)atempo AVOptions: tempo &lt;double&gt; ..F.A.... set tempo scale factor (from 0.5 to 100) (default 1) 通用 参数 说明 -L 许可证书 -h -? -help –help 帮助 -version 版本信息 -buildconf 编译配置 -formats 支持的封装或者解封装格式 -muxers 支持的封装格式 -demuxers 支持的解封装格式 -codecs 编解码器对编解码的支持 -decoders 支持解码的格式 -encoders 支持编码的格式 -bsfs 比特流过虑器 -protocols 支持输入和输出的协议 -filters 过虑器 -pix_fmts 像素格式的支持 -layouts 声道布局 -sample_fmts 音频采样格式 -colors 颜色 -sources device 输入设备的源 -sinks device 输出设备的源 -hwaccels 硬件加速 文件主选项 参数 说明 -f fmt 设定输出格式 -c codec -codec codec 设置编码器 -pre preset 预置预处理集 -map_metadata outfile[,metadata]:infile[,metadata] 设置输出文件的元数据信息 -t duration 设置录制或转码的时间 秒 -to time_stop 设置录制或转码的停止时间点 -fs limit_size 设置文件最大值 byte -ss time_off 设置开始时间点 -sseof time_off 设置开始时间点 从结束开始倒数 -seek_timestamp 启动或者禁止时间戳对-ss的影响 -timestamp time 设置录制的时间戳（now是当前时间） -metadata string=string 添加元数据 -program title=string:st=number… 给指定的流添加program -target type 指定目标文件的类型 -apad 音频补齐 -frames number 设置输出多少帧 -filter filter_graph 设置流的滤镜图 -filter_script filename 从一个文件中获取滤镜图的描述 -reinit_filter 输入参数变化时重新初始化滤镜图 -discard 丢弃 -disposition 配置 视频选项 参数 说明 -vframes number 输出多少帧视频 -r rate 设置帧率 HZ -s size 设置帧大小 -aspect aspect 设置视频宽高比 w:h或者浮点数 -bits_per_raw_sample 设置每个原始样本的比特数 -vn 禁止视频 -vcodec codec 设置视频编解码（copy复制输入流的） -timecode hh:mm:ss[:;.]ff 设置初始时间码 -pass n 选择通道1~3 -vf filter_graph 设置视频滤镜 -ab bitrate 设置音频比特率 -b:a同样 -b bitrate 设置视频比特率 -b:v同样 -dn 禁止数据缓存 音频选项 参数 说明 -aframes number 设置输出多少帧音频 -aq quality 设置音频质量 -ar rate 设置音频采样率 -ac channels 设置音频通道 -an 禁止音频 -acodec codec 设置音频编解码 -vol volume 改变音量 正常=256 -af filter_graph 设置音频滤镜 字幕选项 参数 说明 -s size 设置帧大小W*H -sn 禁止字幕 -scodec codec 设置字幕的编解码器（copy表示使用输入源） -stag fourcc/tag 设置字幕tag/fourcc -fix_sub_duration 修改字幕的时间 -canvas_size size 设置画布大小 -spre preset 设置字幕选项的预设]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-11.UDP-RTP协议解析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-11-udp-rtp%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[UDP RTP头结构UDP 源数据端口，目的端口各占2个字节，长度也占2个字节，checksum 校检和也占2个字节长度 Rtp头标准长度为12个字节。其中，rtp协议版本号V占2位，填充标准P占1位，扩展标准X占1位，CSRC计数器CC占4位，这四个共占8位，一个字节。M标记占1位，有效载荷占7位，共占用1个字节。序列化占16位，占用2个字节。时间戳（Timestamp）占32位，占用4个字节。同步信源（SSRC）占32位，共占用4个字节。特约信源（CSRC），每个特约信源占32位，可以有0到15个。 MPEG-TS包头信息 详细 Sync byte:同步字节，值为0x47；Transport error indicator:传输错误指示位，置1时，表示传送包中至少有一个不可纠正的错误位。Payload unit start indicator:负载单元起始指标位，表示TS包的有效净荷以PES/PSI包的第一个字节开始，举个例子，一个PES包可能由多个TS包构成，第一个TS包的负载单元起始指标位才会被置位。Transport priority:传输优先级，表明该包比同个PID的但未置位的TS包有更高的优先级。PID:该TS包的ID号，如果净荷是PAT包，则PID固定为0x00。Transport scrambling control:传输加扰控制位Adaption field control:自适应调整域控制位，置位则表明该TS包存在自适应调整字段。Continuity counter:连续计数器，随着具有相同PID的TS包的增加而增加，达到最大时恢复为0，如果两个连续相同PID的TS包具有相同的计数，则表明这两个包是一样的，只取一个解析即可。Payload:负载内容，可能为PAT/PMT/PES。data_byte为1B长度的数据，为负载字节。 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#pragma comment(lib, "ws2_32.lib") #pragma pack(1) /* * [memo] FFmpeg stream Command: * ffmpeg -re -i sintel.ts -f mpegts udp://127.0.0.1:8880 * ffmpeg -re -i sintel.ts -f rtp_mpegts udp://127.0.0.1:8880 */ typedef struct RTP_FIXED_HEADER&#123; /* byte 0 */ unsigned char csrc_len:4; /* expect 0 */ unsigned char extension:1; /* expect 1 */ unsigned char padding:1; /* expect 0 */ unsigned char version:2; /* expect 2 */ /* byte 1 */ unsigned char payload:7; unsigned char marker:1; /* expect 1 */ /* bytes 2, 3 */ unsigned short seq_no; /* bytes 4-7 */ unsigned long timestamp; /* bytes 8-11 */ unsigned long ssrc; /* stream number is used here. */&#125; RTP_FIXED_HEADER; typedef struct MPEGTS_FIXED_HEADER &#123; unsigned sync_byte: 8; unsigned transport_error_indicator: 1; unsigned payload_unit_start_indicator: 1; unsigned transport_priority: 1; unsigned PID: 13; unsigned scrambling_control: 2; unsigned adaptation_field_exist: 2; unsigned continuity_counter: 4;&#125; MPEGTS_FIXED_HEADER; int simplest_udp_parser(int port)&#123; WSADATA wsaData;//https://baike.baidu.com/item/WSADATA/3031763?fr=aladdina //这个结构被用来存储被WSAStartup函数调用后返回的Windows Sockets数据。 WORD sockVersion = MAKEWORD(2,2);//声明调用不同的Winsock版本。例如MAKEWORD(2,2)就是调用2.2版 MAKEWORD(2,2)构成一个16位无符号的整形 MAKEWORD(a,b) ((WORD) (((BYTE) (a)) | ((WORD) ((BYTE) (b))) &lt;&lt; 8)) int cnt=0; //FILE *myout=fopen("output_log.txt","wb+"); FILE *myout=stdout; FILE *fp1=fopen("output_dump.ts","wb+"); if(WSAStartup(sockVersion, &amp;wsaData) != 0)&#123; return 0; &#125; SOCKET serSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if(serSocket == INVALID_SOCKET)&#123; printf("socket error !"); return 0; &#125; sockaddr_in serAddr;//sockaddr_in易于操作 与sockaddr大小一致 可强制转换为sockaddr serAddr.sin_family = AF_INET; serAddr.sin_port = htons(port);//网络字节顺序 变成大端 serAddr.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(serSocket, (sockaddr *)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR)&#123; printf("bind error !"); closesocket(serSocket); return 0; &#125; sockaddr_in remoteAddr; int nAddrLen = sizeof(remoteAddr); //How to parse? int parse_rtp=1; int parse_mpegts=1; printf("Listening on port %d\n",port); char recvData[10000]; while (1)&#123; int pktsize = recvfrom(serSocket, recvData, 10000, 0, (sockaddr *)&amp;remoteAddr, &amp;nAddrLen); if (pktsize &gt; 0)&#123; //printf("Addr:%s\r\n",inet_ntoa(remoteAddr.sin_addr)); //printf("packet size:%d\r\n",pktsize); //Parse RTP // if(parse_rtp!=0)&#123; char payload_str[10]=&#123;0&#125;; RTP_FIXED_HEADER rtp_header; int rtp_header_size=sizeof(RTP_FIXED_HEADER); //RTP Header memcpy((void *)&amp;rtp_header,recvData,rtp_header_size); //RFC3551 char payload=rtp_header.payload; switch(payload)&#123; case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: sprintf(payload_str,"Audio");break; case 31: sprintf(payload_str,"H.261");break; case 32: sprintf(payload_str,"MPV");break; case 33: sprintf(payload_str,"MP2T");break; case 34: sprintf(payload_str,"H.263");break; case 96: sprintf(payload_str,"H.264");break; default:sprintf(payload_str,"other");break; &#125; unsigned int timestamp=ntohl(rtp_header.timestamp);//将网络字节顺序 转成本机 无符号长整 unsigned int seq_no=ntohs(rtp_header.seq_no);//无符号短整 fprintf(myout,"[RTP Pkt] %5d| %5s| %10u| %5d| %5d|\n",cnt,payload_str,timestamp,seq_no,pktsize); //RTP Data char *rtp_data=recvData+rtp_header_size; int rtp_data_size=pktsize-rtp_header_size; fwrite(rtp_data,rtp_data_size,1,fp1); //Parse MPEGTS if(parse_mpegts!=0&amp;&amp;payload==33)&#123; MPEGTS_FIXED_HEADER mpegts_header; for(int i=0;i&lt;rtp_data_size;i=i+188)&#123;//一段固定188 if(rtp_data[i]!=0x47)//同步字 固定0x47 break; //MPEGTS Header //memcpy((void *)&amp;mpegts_header,rtp_data+i,sizeof(MPEGTS_FIXED_HEADER)); fprintf(myout," [MPEGTS Pkt]\n"); &#125; &#125; &#125;else&#123; fprintf(myout,"[UDP Pkt] %5d| %5d|\n",cnt,pktsize); fwrite(recvData,pktsize,1,fp1); &#125; cnt++; &#125; &#125; closesocket(serSocket); WSACleanup(); fclose(fp1); return 0;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-10.FLV封装格式解析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-10-flv%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[FLV封装格式FLV包含文件头和文件体两部分，文件体由多个Tag组成，Tag的类型可以是视频、音频和Script，每个Tag只能包含以上三种类型的数据中的一种 。如下图 Type为0x08即音频 名称 音频编码类型 音频采样率 音频采样精度 音频类型 0 Linear PCM，platform endian 5.5kHz 8bits sndMono 1 ADPCM 11KHz 16bits sndStereo 2 MP3 22 kHz 3 Linear PCM，little endian 44 kHz 4 Nellymoser 16-kHz mono 5 Nellymoser 8-kHz mono 6 Nellymoser 7 G.711 A-law logarithmic PCM 8 G.711 mu-law logarithmic PCM 9 reserved 10 AAC 14 MP3 8-Khz 15 Device-specific sound Type为0x09即视频 名称 帧类型 视频编码类型 1 keyframe （for AVC，a seekable frame） JPEG （currently unused） 2 inter frame （for AVC，a nonseekable frame） Sorenson H.263 3 disposable inter frame （H.263 only） Screen video 4 generated keyframe （reserved for server use） On2 VP6 5 video info/command frame On2 VP6 with alpha channel 6 Screen video version 2 7 AVC Type为0x12即控制帧 该类型Tag又通常被称为Metadata Tag，会放一些关于FLV视频和音频的元数据信息如：duration、width、height等。通常该类型Tag会跟在File Header后面作为第一个Tag出现，而且只有一个。 AMF1： 第1个字节表示AMF包类型，一般总是0x02，表示字符串。第2-3个字节为UI16类型值，标识字符串的长度，一般总是0x000A（“onMetaData”长度）。后面字节为具体的字符串，一般总为“onMetaData”（6F,6E,4D,65,74,61,44,61,74,61） 第1个字节表示AMF包类型，一般总是0x08，表示数组。第2-5个字节为UI32类型值，表示数组元素的个数。后面即为各数组元素的封装，数组元素为元素名称和值组成的对。 | 值 | 含义 || ————— | ———— || duration | 时长 || width | 视频宽度 || height | 视频高度 || videodatarate | 视频码率 || framerate | 视频帧率 || videocodecid | 视频编码方式 || audiosamplerate | 音频采样率 || audiosamplesize | 音频采样精度 || stereo | 是否为立体 || audiocodecid | 音频编码方式 || filesize | 文件大小 | 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#pragma pack(1) //包大小设为1 #define TAG_TYPE_SCRIPT 18#define TAG_TYPE_AUDIO 8#define TAG_TYPE_VIDEO 9 typedef unsigned char byte;typedef unsigned int uint; typedef struct &#123; byte Signature[3]; byte Version; byte Flags; uint DataOffset;&#125; FLV_HEADER; typedef struct &#123; byte TagType; byte DataSize[3]; byte Timestamp[3]; uint Reserved;&#125; TAG_HEADER; //大端转小端uint reverse_bytes(byte *p, char c) &#123; int r = 0; int i; for (i=0; i&lt;c; i++) r |= ( *(p+i) &lt;&lt; (((c-1)*8)-8*i)); return r;&#125; int simplest_flv_parser(char *url)&#123; //whether output audio/video stream int output_a=1; int output_v=1; FILE *ifh=NULL,*vfh=NULL, *afh = NULL; //FILE *myout=fopen("output_log.txt","wb+"); FILE *myout=stdout; FLV_HEADER flv; TAG_HEADER tagheader; uint previoustagsize, previoustagsize_z=0; uint ts=0, ts_new=0; ifh = fopen(url, "rb+"); if ( ifh== NULL) &#123; printf("Failed to open files!"); return -1; &#125; //FLV file header fread((char *)&amp;flv,1,sizeof(FLV_HEADER),ifh); fprintf(myout,"============== FLV Header ==============\n"); fprintf(myout,"Signature: 0x %c %c %c\n",flv.Signature[0],flv.Signature[1],flv.Signature[2]); fprintf(myout,"Version: 0x %X\n",flv.Version); fprintf(myout,"Flags : 0x %X\n",flv.Flags); fprintf(myout,"HeaderSize: 0x %X %d\n",reverse_bytes((byte *)&amp;flv.DataOffset, sizeof(flv.DataOffset))); fprintf(myout,"========================================\n"); //move the file pointer to the end of the header fseek(ifh, reverse_bytes((byte *)&amp;flv.DataOffset, sizeof(flv.DataOffset)), SEEK_SET); //process each tag do &#123; previoustagsize = _getw(ifh); fread((void *)&amp;tagheader,sizeof(TAG_HEADER),1,ifh); //int temp_datasize1=reverse_bytes((byte *)&amp;tagheader.DataSize, sizeof(tagheader.DataSize)); int tagheader_datasize=tagheader.DataSize[0]*65536+tagheader.DataSize[1]*256+tagheader.DataSize[2]; int tagheader_timestamp=tagheader.Timestamp[0]*65536+tagheader.Timestamp[1]*256+tagheader.Timestamp[2]; char tagtype_str[10]; switch(tagheader.TagType)&#123; case TAG_TYPE_AUDIO:sprintf(tagtype_str,"AUDIO");break; case TAG_TYPE_VIDEO:sprintf(tagtype_str,"VIDEO");break; case TAG_TYPE_SCRIPT:sprintf(tagtype_str,"SCRIPT");break; default:sprintf(tagtype_str,"UNKNOWN");break; &#125; fprintf(myout,"[%6s] %6d %6d |",tagtype_str,tagheader_datasize,tagheader_timestamp); //if we are not past the end of file, process the tag if (feof(ifh)) &#123; break; &#125; //process tag by type switch (tagheader.TagType) &#123; case TAG_TYPE_AUDIO:&#123; char audiotag_str[100]=&#123;0&#125;; strcat(audiotag_str,"| "); char tagdata_first_byte; tagdata_first_byte=fgetc(ifh); int x=tagdata_first_byte&amp;0xF0; x=x&gt;&gt;4; switch (x) &#123; case 0:strcat(audiotag_str,"Linear PCM, platform endian");break; case 1:strcat(audiotag_str,"ADPCM");break; case 2:strcat(audiotag_str,"MP3");break; case 3:strcat(audiotag_str,"Linear PCM, little endian");break; case 4:strcat(audiotag_str,"Nellymoser 16-kHz mono");break; case 5:strcat(audiotag_str,"Nellymoser 8-kHz mono");break; case 6:strcat(audiotag_str,"Nellymoser");break; case 7:strcat(audiotag_str,"G.711 A-law logarithmic PCM");break; case 8:strcat(audiotag_str,"G.711 mu-law logarithmic PCM");break; case 9:strcat(audiotag_str,"reserved");break; case 10:strcat(audiotag_str,"AAC");break; case 11:strcat(audiotag_str,"Speex");break; case 14:strcat(audiotag_str,"MP3 8-Khz");break; case 15:strcat(audiotag_str,"Device-specific sound");break; default:strcat(audiotag_str,"UNKNOWN");break; &#125; strcat(audiotag_str,"| "); x=tagdata_first_byte&amp;0x0C; x=x&gt;&gt;2; switch (x) &#123; case 0:strcat(audiotag_str,"5.5-kHz");break; case 1:strcat(audiotag_str,"1-kHz");break; case 2:strcat(audiotag_str,"22-kHz");break; case 3:strcat(audiotag_str,"44-kHz");break; default:strcat(audiotag_str,"UNKNOWN");break; &#125; strcat(audiotag_str,"| "); x=tagdata_first_byte&amp;0x02; x=x&gt;&gt;1; switch (x) &#123; case 0:strcat(audiotag_str,"8Bit");break; case 1:strcat(audiotag_str,"16Bit");break; default:strcat(audiotag_str,"UNKNOWN");break; &#125; strcat(audiotag_str,"| "); x=tagdata_first_byte&amp;0x01; switch (x) &#123; case 0:strcat(audiotag_str,"Mono");break; case 1:strcat(audiotag_str,"Stereo");break; default:strcat(audiotag_str,"UNKNOWN");break; &#125; fprintf(myout,"%s",audiotag_str); //if the output file hasn't been opened, open it. if(output_a!=0&amp;&amp;afh == NULL)&#123; afh = fopen("output.mp3", "wb"); &#125; //TagData - First Byte Data int data_size=reverse_bytes((byte *)&amp;tagheader.DataSize, sizeof(tagheader.DataSize))-1;//-1是个迷 FirstBYteData为什么是1和减掉 if(output_a!=0)&#123;//读完TagData for (int i=0; i&lt;data_size; i++) fputc(fgetc(ifh),afh);//将音频输出到mp3文件 &#125;else&#123; for (int i=0; i&lt;data_size; i++) fgetc(ifh); &#125; break; &#125; case TAG_TYPE_VIDEO:&#123; char videotag_str[100]=&#123;0&#125;; strcat(videotag_str,"| "); char tagdata_first_byte; tagdata_first_byte=fgetc(ifh); int x=tagdata_first_byte&amp;0xF0; x=x&gt;&gt;4; switch (x) &#123; case 1:strcat(videotag_str,"key frame ");break; case 2:strcat(videotag_str,"inter frame");break; case 3:strcat(videotag_str,"disposable inter frame");break; case 4:strcat(videotag_str,"generated keyframe");break; case 5:strcat(videotag_str,"video info/command frame");break; default:strcat(videotag_str,"UNKNOWN");break; &#125; strcat(videotag_str,"| "); x=tagdata_first_byte&amp;0x0F; switch (x) &#123; case 1:strcat(videotag_str,"JPEG (currently unused)");break; case 2:strcat(videotag_str,"Sorenson H.263");break; case 3:strcat(videotag_str,"Screen video");break; case 4:strcat(videotag_str,"On2 VP6");break; case 5:strcat(videotag_str,"On2 VP6 with alpha channel");break; case 6:strcat(videotag_str,"Screen video version 2");break; case 7:strcat(videotag_str,"AVC");break; default:strcat(videotag_str,"UNKNOWN");break; &#125; fprintf(myout,"%s",videotag_str); fseek(ifh, -1, SEEK_CUR);//往回走一位 迷 前四位是tagdata_first_byte&amp;0xF0 后四位是tagdata_first_byte&amp;0x0F 不应该啊 //if the output file hasn't been opened, open it. if (vfh == NULL&amp;&amp;output_v!=0) &#123; //write the flv header (reuse the original file's hdr) and first previoustagsize vfh = fopen("output.flv", "wb"); fwrite((char *)&amp;flv,1, sizeof(flv),vfh); fwrite((char *)&amp;previoustagsize_z,1,sizeof(previoustagsize_z),vfh); &#125;#if 0 //延长时间戳 变成双倍 //Change Timestamp //Get Timestamp ts = reverse_bytes((byte *)&amp;tagheader.Timestamp, sizeof(tagheader.Timestamp)); ts=ts*2; //Writeback Timestamp ts_new = reverse_bytes((byte *)&amp;ts, sizeof(ts)); memcpy(&amp;tagheader.Timestamp, ((char *)&amp;ts_new) + 1, sizeof(tagheader.Timestamp));//Timestamp只占三位 大端模式 去掉首位#endif //TagData + Previous Tag Size int data_size=reverse_bytes((byte *)&amp;tagheader.DataSize, sizeof(tagheader.DataSize))+4; if(output_v!=0)&#123; //TagHeader fwrite((char *)&amp;tagheader,1, sizeof(tagheader),vfh); //TagData for (int i=0; i&lt;data_size; i++) fputc(fgetc(ifh),vfh); &#125;else&#123; for (int i=0; i&lt;data_size; i++) fgetc(ifh); &#125; //rewind 4 bytes, because we need to read the previoustagsize again for the loop's sake fseek(ifh, -4, SEEK_CUR); break; &#125; default: //skip the data of this tag fseek(ifh, reverse_bytes((byte *)&amp;tagheader.DataSize, sizeof(tagheader.DataSize)), SEEK_CUR); &#125; fprintf(myout,"\n"); &#125; while (!feof(ifh)); _fcloseall(); return 0;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-9.AAC音频码流解析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-9-aac%E9%9F%B3%E9%A2%91%E7%A0%81%E6%B5%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[AAC基本结构详细 由图可见，ADTS frame (Audio Data Transport Stream) 之间由syncword（同步字进行分离），即0xFFF。 名称 备注 syncword 总是0xFFF, 代表一个ADTS帧的开始 ID MPEG Version: 0 for MPEG-4, 1 for MPEG-2 layer always: ‘00’ protection_absent Warning, set to 1 if there is no CRC and 0 if there is CRC profile sampling_frequency_index channel_configuration aac_frame_length 一个ADTS帧的长度包括ADTS头和AAC原始流，aac_frame_length = (protection_absent == 1 ? 7 : 9) + size(AACFrame) adts_buffer_fullness 0x7FF 说明是码率可变的码流 number_of_raw_data_blocks_in_frame 有number_of_raw_data_blocks_in_frame+1个AAC原始帧(一个AAC原始帧包含一段时间内1024个采样及相关数据) 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100int getADTSframe(unsigned char* buffer, int buf_size, unsigned char* data ,int* data_size)&#123; int size = 0; if(!buffer || !data || !data_size )&#123; return -1; &#125; while(1)&#123; if(buf_size &lt; 7 )&#123; return -1; &#125; //找出同步码 然后找到aac_frame_length的大小 保存在size if((buffer[0] == 0xff) &amp;&amp; ((buffer[1] &amp; 0xf0) == 0xf0) )&#123;//同步码 实际为0xF0FF? size |= ((buffer[3] &amp; 0x03) &lt;&lt;11); //high 2 bit size |= buffer[4]&lt;&lt;3; //middle 8 bit size |= ((buffer[5] &amp; 0xe0)&gt;&gt;5); //low 3bit break; &#125; --buf_size; ++buffer; &#125; if(buf_size &lt; size)&#123;//此段不完整 buf_size为剩下的 size为应该的大小 return 1; &#125; memcpy(data, buffer, size); *data_size = size; return 0;&#125;int aacParser(char *url)&#123; int data_size = 0; int size = 0; int cnt=0; int offset=0; unsigned char *aacframe=(unsigned char *)malloc(1024*5); unsigned char *aacbuffer=(unsigned char *)malloc(1024*1024); FILE *fp=fopen(url,"rb"); while(!feof(fp))&#123; data_size = fread(aacbuffer+offset, 1, 1024*1024-offset, ifile); unsigned char* input_data = aacbuffer; while(1) &#123; int ret=getADTSframe(input_data, data_size, aacframe, &amp;size); if(ret==-1)&#123;//段中没有完整的ADTS了 break; &#125;else if(ret==1)&#123; memcpy(aacbuffer,input_data,data_size); offset=data_size; break; &#125; char profile_str[10]=&#123;0&#125;; char frequence_str[10]=&#123;0&#125;; unsigned char profile=aacframe[2]&amp;0xC0; profile=profile&gt;&gt;6; switch(profile)&#123; case 0: sprintf(profile_str,"Main");break; case 1: sprintf(profile_str,"LC");break; case 2: sprintf(profile_str,"SSR");break; default:sprintf(profile_str,"unknown");break; &#125; unsigned char sampling_frequency_index=aacframe[2]&amp;0x3C; sampling_frequency_index=sampling_frequency_index&gt;&gt;2; switch(sampling_frequency_index)&#123; case 0: sprintf(frequence_str,"96000Hz");break; case 1: sprintf(frequence_str,"88200Hz");break; case 2: sprintf(frequence_str,"64000Hz");break; case 3: sprintf(frequence_str,"48000Hz");break; case 4: sprintf(frequence_str,"44100Hz");break; case 5: sprintf(frequence_str,"32000Hz");break; case 6: sprintf(frequence_str,"24000Hz");break; case 7: sprintf(frequence_str,"22050Hz");break; case 8: sprintf(frequence_str,"16000Hz");break; case 9: sprintf(frequence_str,"12000Hz");break; case 10: sprintf(frequence_str,"11025Hz");break; case 11: sprintf(frequence_str,"8000Hz");break; default:sprintf(frequence_str,"unknown");break; &#125; fprintf(myout,"%5d| %8s| %8s| %5d|\n",cnt,profile_str ,frequence_str,size); data_size -= size; input_data += size; cnt++; &#125; &#125; fclose(ifile); free(aacbuffer); free(aacframe); return 0;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-8.H264视频码流解析]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-8-h264%E8%A7%86%E9%A2%91%E7%A0%81%E6%B5%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[H.264结构基本介绍 H264比特流 = Start_Code_Prefix + NALU + Start_Code_Prefix + NALU + … 由此可见，H264由一个起始码将各个NALU（ Network Abstract Layer，即网络抽象层 U单元 ），其中，起始码分为3Byte和4Byte的0x000001和0x00000001。如果以Slice为一帧开始就用0x00000001，否则用0x000001。在起始码后面的第一个字节，就是NALU的类型。详细 类型值 解释 1 非IDR图像的编码条带，为P或B帧。P帧，前向预测编码帧，表示该帧与前一帧的差别（I或P），在I中找 出P某点的预测值和运动矢量，一起传送。接收端根据运动矢量从I中找出P某点的预测值并与差值相加得到样值。 1P帧在I帧后面1~2帧的位置 2压缩率比较高 3采用运动补偿传送差值和运动矢量 4可造成解码错误扩散 B帧，双向预测编码帧，通过前后帧与本帧数据叠加取得最终画面。先找出B帧中某点的预测值和两个运动矢量，传送预测值和运动矢量。接收端根据运动矢量在两个帧中找出预测值并求和。 1B帧由前面的I或者P和后面的P帧来计算 2压缩率最高，只反映帧间运动主体的变化 3不会造成解码错误扩散 2 编码条带数据分割块A 3 编码条带数据分割块B 4 编码条带数据分割块C 5 I帧，IDR图像的编码条带，俗称关键帧，也叫帧内编码帧。1全帧JPEG压缩编码 2描述了图像背景和运动主体的详情 3是P和B帧的参考帧 4一组只有一个 6 辅助增强信息 (SEI) 7 SPS（Sequence Parameter Set）序列参数集。包括编码所用的profile，level，图像的宽和高，deblock滤波器等 8 PPS（Picture Parameter Set）图像参数集。包括编码所用的profile，level，图像的宽和高，deblock滤波器等 9 访问单元分隔符 10 序列结尾 11 流结尾 12 填充数据 13 序列参数集扩展 19 未分割的辅助编码图像的编码条带 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179typedef enum &#123; NALU_TYPE_SLICE = 1, NALU_TYPE_DPA = 2, NALU_TYPE_DPB = 3, NALU_TYPE_DPC = 4, NALU_TYPE_IDR = 5, NALU_TYPE_SEI = 6, NALU_TYPE_SPS = 7, NALU_TYPE_PPS = 8, NALU_TYPE_AUD = 9, NALU_TYPE_EOSEQ = 10, NALU_TYPE_EOSTREAM = 11, NALU_TYPE_FILL = 12,&#125; NaluType; typedef enum &#123; NALU_PRIORITY_DISPOSABLE = 0, NALU_PRIRITY_LOW = 1, NALU_PRIORITY_HIGH = 2, NALU_PRIORITY_HIGHEST = 3&#125; NaluPriority; typedef struct&#123; int startcodeprefix_len; //slice表示4位 否则3位 unsigned len; //NALU的长度 不包括起始码 unsigned max_size; //NALU缓冲区大小 int forbidden_bit; //FALSE int nal_reference_idc; //NALU_PRIORITY_xxxx int nal_unit_type; //NALU_TYPE_xxxx char *buf; //包含EBSP后面的第一个字节&#125; NALU_t;FILE *h264bitstream;int info2=0, info3=0; static int FindStartCode2 (unsigned char *Buf)&#123; if(Buf[0]!=0 || Buf[1]!=0 || Buf[2] !=1) return 0; //0x000001? else return 1;&#125; static int FindStartCode3 (unsigned char *Buf)&#123; if(Buf[0]!=0 || Buf[1]!=0 || Buf[2] !=0 || Buf[3] !=1) return 0;//0x00000001? else return 1;&#125;int GetAnnexbNALU(NALU_t *nalu)&#123; int pos = 0; int StartCodeFound, rewind; unsigned char *Buf; if ((Buf = (unsigned char*)calloc (nalu-&gt;max_size , sizeof(char))) == NULL) printf ("GetAnnexbNALU: Could not allocate Buf memory\n"); nalu-&gt;startcodeprefix_len=3;//假设是0x000001 if (3 != fread (Buf, 1, 3, h264bitstream))&#123; free(Buf); return 0; &#125; info2 = FindStartCode2 (Buf); if(info2 != 1) &#123;//不是0x000001 if(1 != fread(Buf+3, 1, 1, h264bitstream))&#123;//多读取一个 free(Buf); return 0; &#125; info3 = FindStartCode3 (Buf);//是不是0x00000001 if (info3 != 1)&#123; free(Buf); return -1; &#125; else &#123; pos = 4; nalu-&gt;startcodeprefix_len = 4; &#125; &#125; else&#123; nalu-&gt;startcodeprefix_len = 3; pos = 3; &#125; StartCodeFound = 0; info2 = 0; info3 = 0; while (!StartCodeFound)&#123; if (feof (h264bitstream))&#123;//读到文件尾 nalu-&gt;len = (pos-1)-nalu-&gt;startcodeprefix_len; memcpy (nalu-&gt;buf, &amp;Buf[nalu-&gt;startcodeprefix_len], nalu-&gt;len); nalu-&gt;forbidden_bit = nalu-&gt;buf[0] &amp; 0x80; //1 bit 10000000 nalu-&gt;nal_reference_idc = nalu-&gt;buf[0] &amp; 0x60; // 2 bit 01100000 nalu-&gt;nal_unit_type = (nalu-&gt;buf[0]) &amp; 0x1f;// 5 bit 00011111 free(Buf); return pos-1; &#125; Buf[pos++] = fgetc (h264bitstream); //判断本段是否结束 info3 = FindStartCode3(&amp;Buf[pos-4]); if(info3 != 1) info2 = FindStartCode2(&amp;Buf[pos-3]); StartCodeFound = (info2 == 1 || info3 == 1); &#125; // Here, we have found another start code (and read length of startcode bytes more than we should // have. Hence, go back in the file rewind = (info3 == 1)? -4 : -3; if (0 != fseek (h264bitstream, rewind, SEEK_CUR))&#123; free(Buf); printf("GetAnnexbNALU: Cannot fseek in the bit stream file"); &#125; // Here the Start code, the complete NALU, and the next start code is in the Buf. // The size of Buf is pos, pos+rewind are the number of bytes excluding the next // start code, and (pos+rewind)-startcodeprefix_len is the size of the NALU excluding the start code nalu-&gt;len = (pos+rewind)-nalu-&gt;startcodeprefix_len; memcpy (nalu-&gt;buf, &amp;Buf[nalu-&gt;startcodeprefix_len], nalu-&gt;len);// nalu-&gt;forbidden_bit = nalu-&gt;buf[0] &amp; 0x80; //1 bit nalu-&gt;nal_reference_idc = nalu-&gt;buf[0] &amp; 0x60; // 2 bit nalu-&gt;nal_unit_type = (nalu-&gt;buf[0]) &amp; 0x1f;// 5 bit free(Buf); return (pos+rewind);&#125;int h264Parser(char *url)&#123; int data_offset=0; int nal_num=0; NALU_t *n=(NALU_t*)calloc(1,sizeof(NALU_t)); n-&gt;max_size=100000; n-&gt;buf = (char*)calloc (buffersize, sizeof (char)); h264bitstream=fopen(url, "rb+"); while(!feof(h264bitstream)) &#123; int data_lenth; data_lenth=GetAnnexbNALU(n); char type_str[20]=&#123;0&#125;; switch(n-&gt;nal_unit_type)&#123; case NALU_TYPE_SLICE:sprintf(type_str,"SLICE");break; case NALU_TYPE_DPA:sprintf(type_str,"DPA");break; case NALU_TYPE_DPB:sprintf(type_str,"DPB");break; case NALU_TYPE_DPC:sprintf(type_str,"DPC");break; case NALU_TYPE_IDR:sprintf(type_str,"IDR");break; case NALU_TYPE_SEI:sprintf(type_str,"SEI");break; case NALU_TYPE_SPS:sprintf(type_str,"SPS");break; case NALU_TYPE_PPS:sprintf(type_str,"PPS");break; case NALU_TYPE_AUD:sprintf(type_str,"AUD");break; case NALU_TYPE_EOSEQ:sprintf(type_str,"EOSEQ");break; case NALU_TYPE_EOSTREAM:sprintf(type_str,"EOSTREAM");break; case NALU_TYPE_FILL:sprintf(type_str,"FILL");break; &#125; char idc_str[20]=&#123;0&#125;; switch(n-&gt;nal_reference_idc&gt;&gt;5)&#123; case NALU_PRIORITY_DISPOSABLE:sprintf(idc_str,"DISPOS");break; case NALU_PRIRITY_LOW:sprintf(idc_str,"LOW");break; case NALU_PRIORITY_HIGH:sprintf(idc_str,"HIGH");break; case NALU_PRIORITY_HIGHEST:sprintf(idc_str,"HIGHEST");break; &#125; fprintf(myout,"%5d| %8d| %7s| %6s| %8d|\n",nal_num,data_offset,idc_str,type_str,n-&gt;len); data_offset=data_offset+data_lenth; nal_num++; &#125; if (n)&#123; if (n-&gt;buf)&#123; free(n-&gt;buf); n-&gt;buf=NULL; &#125; free (n); &#125; return 0;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-7.PCM音频数据处理]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-7-pcm%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[分离PCM16LE双声道音频PCM16LE中左右声道是间隔存储的。16表示采样位数是16bit，LE表示Litter Endian，小端模式。 1234567891011121314151617181920int pcm16leSplit(const char * url)&#123; FILE *fp=fopen("","wb+"); FILE *fp1=fopen("","wb+"); FILE *fp2=fopen(url,"rb+"); unsigned char *temp=(unsigned char *)malloc(4); while(!feof(fp2))&#123; fread(temp,1,4,fp2); fwrite(temp,1,2,fp); fwrite(temp+2,1,2,fp1); &#125; free(temp); fclose(fp); fclose(fp1); fclose(fp2); return 0;&#125; 左声道音量减半123456789101112131415161718192021int pcm16leCutLeft(char *url)&#123; FILE *fp=fopen("","wb+"); FILE *fp2=fopen(url,"rb+"); unsigned char *temp=(unsigned char *)malloc(4); while(!feof(fp2))&#123; fread(temp,1,4,fp2); short *sh=(short *)temp; *sh=(*sh)/2; fwrite(temp,1,2,fp); fwrite(temp+2,1,2,fp); &#125; free(temp); fclose(fp); fclose(fp2); return 0;&#125; PCM16LE2PCM812345678910111213141516171819202122//将-32768~32767转换为0~255int pcm16le2pcm8(char *url)&#123; FILE *fp=fopen("","wb+"); FILE *fp2=fopen(url,"rb+"); unsigned char *temp=(unsigned char *)malloc(4); while(!feof(fp2))&#123; fread(temp,1,4,fp2); char pcm8; pcm8= (*(short*)temp)&gt;&gt;256+128; fwrite(&amp;pcm8,1,1,fp); pcm8= (*(short*)(temp+2)&gt;&gt;256+128; fwrite(&amp;pcm8,1,1,fp); &#125; free(temp); fclose(fp); fclose(fp2); return 0;&#125; PCM16LE2WAVE123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475WAVE是微软上常见的音频格式，具体为在PCM前加了一个文件头WAVE_HEADERWAVE_FMTWAVE_DATAPCM数据 ;typedef struct WAVE_HEADER&#123; char fccID[4]; unsigned long dwSize; char fccType[4]; &#125;WAVE_HEADER; typedef struct WAVE_FMT&#123; char fccID[4]; unsigned long dwSize; unsigned short wFormatTag; unsigned short wChannels; unsigned long dwSamplesPerSec; unsigned long dwAvgBytesPerSec; unsigned short wBlockAlign; unsigned short uiBitsPerSample; &#125;WAVE_FMT; typedef struct WAVE_DATA&#123; char fccID[4]; unsigned long dwSize; &#125;WAVE_DATA; int pcm16le2wave(const char *pcmUrl,int channels,int sample_rate/*44100*/,const char * waveUrl)&#123; int bits=16; unsigned short m_pcmData; WAVE_HEADER pcmHEADER; WAVE_FMT pcmFMT; WAVE_DATA pcmDATA; FILE *fp=fopen(pcmUrl,"rb+"); FILE *fp2=fopen(waveUrl,"wb+"); memcpy(pcmHEADER.fccID,"RIFF",strlen("RIFF")); memcpy(pcmHEADER.fccType,"WAVE",strlen("WAVE")); fseek(fp2,sizeof(WAVE_HEADER),1); pcmFMT.dwSamplesPerSec=sample_rate; pcmFMT.dwAvgBytesPerSec=pcmFMT.dwSamplesPerSec*sizeof(m_pcmData); pcmFMT.uiBitsPerSample=bits; memcpy(pcmFMT.fccID,"fmt ",strlen("fmt ")); pcmFMT.dwSize=16; pcmFMT.wBlockAlign=2; pcmFMT.wChannels=channels; pcmFMT.wFormatTag=1; fwrite(&amp;pcmFMT,sizeof(WAVE_FMT),1,fp2); memcpy(pcmDATA.fccID,"data",strlen("data")); pcmDATA.dwSize=0; fseek(fp2,sizeof(WAVE_DATA),SEEK_CUR); fread(&amp;m_pcmData,sizeof(unsigned short),1,fp); while(!feof(fp))&#123; pcmDATA.dwSize+=2; fwrite(&amp;m_pcmData,sizeof(unsigned short),1,fp2); fread(&amp;m_pcmData,sizeof(unsigned short),1,fp); &#125; pcmHEADER.dwSize=44+pcmDATA.dwSize;//44没说是啥 应该是文件头 rewind(fp2); fwrite(&amp;pcmHEADER,sizeof(WAVE_HEADER),1,fp2); fseek(fp2,sizeof(WAVE_FMT),SEEK_CUR); fwrite(&amp;pcmDATA,sizeof(WAVE_DATA),1,fp2); fclose(fp); fclose(fp2); return 0;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-6.YUV像素数据处理]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-6-yuv%E5%83%8F%E7%B4%A0%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[分离YUV420P12345678910111213141516int yuv420pSplit(char *url,int w,int h,int num)&#123; unsigned char *pic=(unsigned char *)malloc(w*h*3/2); FILE *fp=fopen(url,"rb+"); for(int i=0;i&lt;num;i++)&#123; fread(pic,1,w*h*3/2,fp); pic;//Y w*h pic+w*h;//U w*h/4 pic+w*h*5/4;//V w*h/4 &#125; free(pic); close(fp); return 0;&#125; 分离YUV444P12345678910111213141516int yuv444Split(char *url,int w,int h,int num)&#123; unsigned char *pic=(unsigned char *)malloc(w*h*3); FILE *fp=fopen(url,"rb+"); for(int i=0;i&lt;num;i++)&#123; fread(pic,1,w*h*3,fp); pic;//Y w*h pic+w*h;//U w*h pic+w*h*2;//V w*h &#125; free(pic); close(fp); return 0;&#125; 去掉YUV420P的颜色12345678910111213141516int yuv420Gray(char *url,int w,int h,int num)&#123; unsigned char *pic=(unsigned char *)malloc(w*h*3/2); FILE *fp=fopen(url,"rb+"); for(int i=0;i&lt;num;i++)&#123; fread(pic,1,w*h*3/2,fp); memset(pic+w*h,128,w*h/2); //色度分量在偏置处理前的取值范围是-128至127,此时无色对应0。经偏置后变成0-255，此时无色对应为128 //因此只需要将U V设置成128 &#125; free(pic); close(fp); return 0;&#125; YUV的PSNR计算 PSNR是最基本的视频质量评价方法， RGB2BMPBMP文件是由BITMAPFILEHEADER、BITMAPINFOHEADER、BGR像素数据共3个部分构成，它的结构如下图所示 12345678910111213141516171819202122typedef struct tagBITMAPFILEHEADER&#123; unsigned short int bfType; //位图文件的类型，必须为BM unsigned long bfSize; //文件大小，以字节为单位unsigned short int bfReserverd1; //位图文件保留字，必须为0 unsigned short int bfReserverd2; //位图文件保留字，必须为0 unsigned long bfbfOffBits; //位图文件头到数据的偏移量，以字节为单位&#125;BITMAPFILEHEADER; typedef struct tagBITMAPINFOHEADER &#123; long biSize; //该结构大小，字节为单位long biWidth; //图形宽度以象素为单位long biHeight; //图形高度以象素为单位short int biPlanes; //目标设备的级别，必须为1 short int biBitcount; //颜色深度，每个象素所需要的位数short int biCompression; //位图的压缩类型long biSizeImage; //位图的大小，以字节为单位long biXPelsPermeter; //位图水平分辨率，每米像素数long biYPelsPermeter; //位图垂直分辨率，每米像素数long biClrUsed; //位图实际使用的颜色表中的颜色数long biClrImportant; //位图显示过程中重要的颜色数&#125;BITMAPINFOHEADER; 12345678910111213141516171819202122232425262728293031323334353637383940414243void RGB2BMP(const char * rgbUrl,int width,int height,const char * bmpUrl)&#123; int i=0,j=0; BITMAPFILEHEADER m_BMPHeader=&#123;0&#125;; BITMAPINFOHEADER m_BMPInfoHeader=&#123;0&#125;; char bfType[2]=&#123;'B','M'&#125;; int header_size=sizeof(bfType)+sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER); unsigned char *rgb24_buffer=(unsigned char *)malloc(width*height*3); FILE *fp_rgb24=fopen(rgb24path,"rb"),*fp_bmp=fopen(bmppath,"wb"); fread(rgb24_buffer,1,width*height*3,fp_rgb24); m_BMPHeader.bfSize=3*width*height+header_size; m_BMPHeader.bfbfOffBits=header_size; m_BMPInfoHeader.biSize=sizeof(InfoHead); m_BMPInfoHeader.biWidth=width; //BMP storage pixel data in opposite direction of Y-axis (from bottom to top). m_BMPInfoHeader.biHeight=-height; m_BMPInfoHeader.biPlanes=1; m_BMPInfoHeader.biBitcount=24; m_BMPInfoHeader.biSizeImage=3*width*height; fwrite(bfType,1,sizeof(bfType),fp_bmp); fwrite(&amp;m_BMPHeader,1,sizeof(m_BMPHeader),fp_bmp); fwrite(&amp;m_BMPInfoHeader,1,sizeof(m_BMPInfoHeader),fp_bmp); //BMP save R1|G1|B1,R2|G2|B2 as B1|G1|R1,B2|G2|R2 //It saves pixel data in Little Endian //So we change 'R' and 'B' for(j =0;j&lt;height;j++)&#123; for(i=0;i&lt;width;i++)&#123; char temp=rgb24_buffer[(j*width+i)*3+2]; rgb24_buffer[(j*width+i)*3+2]=rgb24_buffer[(j*width+i)*3+0]; rgb24_buffer[(j*width+i)*3+0]=temp; &#125; &#125; fwrite(rgb24_buffer,3*width*height,1,fp_bmp); fclose(fp_rgb24); fclose(fp_bmp); free(rgb24_buffer); return 0;&#125; RGB2YUV420P123456789101112131415161718192021222324252627282930313233343536373839int RGB2YUV420P(unsigned char *rgbBuf,int w,int h,unsigned char *yuvBuf)&#123; memset(yuvBuf,0,w*h*3/2); unsigned char *pY,*pU,*pV,*pRGB; pY=yuvBuf; pU=yuvBuf+w*h; pV=yuvBuf+w*h*5/4; unsigned char y,u,v,r,g,b; for (int j = 0; j&lt;h;j++)&#123; pRGB = rgbBuf + w*j*3 ; for (int i = 0;i&lt;w;i++)&#123; r = *(pRGB++); g = *(pRGB++); b = *(pRGB++); y = (unsigned char)( ( 66 * r + 129 * g + 25 * b + 128) &gt;&gt; 8) + 16 ; u = (unsigned char)( ( -38 * r - 74 * g + 112 * b + 128) &gt;&gt; 8) + 128 ; v = (unsigned char)( ( 112 * r - 94 * g - 18 * b + 128) &gt;&gt; 8) + 128 ; //过滤一下y u v的大小 确保在0~255 *(pY++) = y; if (j%2==0&amp;&amp;i%2 ==0)&#123; *(pU++) =u; &#125;else&#123; if (i%2==0)&#123; *(pV++) =v; &#125; &#125; &#125; return 0;&#125; /*Y= 0.299*R+0.587*G+0.114*BU=-0.147*R-0.289*G+0.463*BV= 0.615*R-0.515*G-0.100*B */]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-5.YUV与RGB]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-5-yuv%E4%B8%8Ergb%2F</url>
    <content type="text"><![CDATA[RGB先说RGB，人对红绿蓝三种光敏感，可以通过不同的组合达到不同的颜色。需要保存三个数据才能表示一个颜色。忽略RGBA。 YUVY表示明亮度（Luminance或Luma），也就是灰度值，而U和V表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。 内存占比RGB24一帧的大小size＝width×heigth×3 ByteRGB32一帧的大小size＝width×heigth×4 ByteYUV420一帧的大小size=width×heigth×1.5 Byte 结构分析 来源 详细黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量 YUV 4:4:4采样，每一个Y对应一组UV分量。 YUV 4:2:2采样，每两个Y共用一组UV分量。 YUV 4:2:0采样，每四个Y共用一组UV分量。 YUYV（属yuv422）：Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00 UYVY（属YUV422）：同上，只是顺序不同 YUV422P（属YUV422）：同上上，顺序不同 YV12、YU12（属YUV420）： Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00。I420的Cr和Cb互换了。 NV12、NV21（属YUV420）： Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00 I420: YYYYYYYY UU VV =&gt;YUV420PYV12: YYYYYYYY VV UU =&gt;YUV420PNV12: YYYYYYYY UVUV =&gt;YUV420SPNV21: YYYYYYYY VUVU =&gt;YUV420SP 存储空间 以720*480图像，yuv420 Y分量： (720×480)个字节 U(Cb)分量：(720×480&gt;&gt;2)个字节 V(Cr)分量：(720×480&gt;&gt;2)个字节 422与420相互转换422-&gt;420：Y不变， 将U和V信号值隔行抽样。420-&gt;422：Y不变， 将U和V信号值的每一行分别拷贝一份 。 YUV与RGB相互转换转跳1 转跳2 英文 FFmpeg中的SwsContext yuv420p( planar )与yuv420区别数据在内存中的排布不同： yuv420p: yyyyyyyy uuuu vvvvv 在AVFrame的data[]中 0表示Y、1表示U、2表示V linesize[]中 0表示Y的宽度、1表示U的宽度、2表示V的宽度 yuv420: yuv yuv yuv yuv 保存yuv420p123456789101112131415161718192021void saveYUV420p(const AVFrame * pFrame)&#123; int fWidth=pFrame-&gt;width; int fHeight=pFrame-&gt;height; int yBytes=pFrame-&gt;linesize[0]; int uBytes=pFrame-&gt;linesize[1]; int vBytes=pFrame-&gt;linesize[2]; //QFile.write((char *)pFrame-&gt;data[0],fWidth*fHeight); //QFile.write((char *)pFrame-&gt;data[1],fWidth/2*fHeight/2); //QFile.write((char *)pFrame-&gt;data[2].fWidth/2*fHeight/2); for(int i=0;i&lt;fHeight;i++)&#123; QFile.write((char *)pFrame-&gt;data[0]+i*yBytes,fWidth); &#125; for(int i=0;i&lt;fHeight/2;i++)&#123; QFile.write((char *)pFrame-&gt;data[1]+i*uBytes,fWidth/2); &#125; for(int i=0;i&lt;fHeight/2;i++)&#123; QFile.write((char *)pFrame-&gt;data[2]+i*vBytes,fWidth/2); &#125;&#125;]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-4.网络视频传输的服务质量]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-4-%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[QoSQoS（Qualityof Service）服务质量，是网络的一种安全机制, 是用来解决网络延迟和阻塞等问题的一种技术。当网络过载或拥塞时，能确保重要业务量不受延迟或丢弃，同时保证网络的高效运行。主要参数有：传输带宽、传输时延和抖动、丢包率。 传输带宽传输带宽也指的是数据传输的速率。 当传输下载速度小于视频流播放数率，则会出现卡顿，解决方法只有选择低品质、低码流的视频进行传输。 传输时延和抖动传输时延定义为从服务器端发送数据到接受端接收到该数据之间的时间差，它是用来描述网络时延的一个指标。 端到端所产生时延由如下原因：1.信息源媒体采样、压缩编码和打包；2.传输；3.接收端排除和播放缓冲；4.接收端拆包、解码和输出。 时延抖动定义为网络传输延时的变化率。一般采用缓存队列平滑数据报的抖动，但是抖动过大需要使用大的缓存空间，有可能影响体验。 丢包率小的丢包率会造成图像的失真和语音的间歇中断，过高的丢包率甚至可以导致业务的中断。]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-3.音视频压缩编码基本原理]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-3-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[视频编码基本原理 为什么需要编码 记录数字视频的YUV分量格式为例，YUV分别代表亮度与两个色差信号。其中Y采样频率为13.5MHz，色度信号一般为一半或更少，为6.75或3.375MHz。以4：2：2采样频率为例，采样信号以8bit量化，码率为： 13.5 8 + 6.75 8 + 6.75 * 8 = 216Mbit/s，数字量非常的大，因此需要压缩以减少码率。 视频码率就是数据传输时单位时间传送的数据位数，一般我们用的单位是kbps即千位每秒。通俗一点的理解就是取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件。 哪方面入手压缩 数据冗余。 空间冗余、时间冗余、结构冗余、信息熵冗余等，即图像的各像素之间存在着很强的相关性，可以消除。属于无损压缩。 视觉冗余。利用人眼的特性，亮度辨别阈值、视觉阈值，引入适量误差，以一定的失真换取数据压缩。属于有损压缩。 通常使用变换编码来消去除图像的帧内冗余，用运动估计和运动补偿来去除图像的帧间冗余，用熵编码来进一步提高压缩的效率。 压缩编码的方法 变换编码 作用是将空间域描述的图像信号变换到频率域 ，变换到频率域可以实现去相关和能量集中 ，然后对变换后的系数进行编码处理。 常用的正交变换有离散傅里叶变换，离散余弦变换等等。数字视频压缩过程中应用广泛的是离散余弦变换。 离散余弦变换简称为DCT变换。 它可以将L*L的图像块从空间域变换为频率域。 将图像分成互不重叠的图像块再进行DCT变换。 下图是上图中图像块经过DCT变换后的结果。从图中可以看出经过DCT变换后，左上角的低频系数集中了大 量能量，而右下角的高频系数上的能量很小。 量化过程通过对低频区的系数进行细量化，高频区的系数进行粗量化，去除了人眼不敏感的高频信息，从而降低信息传送量，此处是视频压缩中操作的主要原因。 量化的过程可以用下面的公式表示： 其中FQ（u,v）表示经过量化后的DCT系数；F（u,v）表示量化前的DCT系数；Q（u,v）表示量化加权矩阵；q表示量化步长；round表示归整，即将输出的值取为与之最接近的整数值。 DCT系数经过量化之后大部分经变为0，而只有很少一部分系数为非零值，此时只需将这些非0值进行压缩编码即可。 熵编码 熵编码多用可变字长编码（VLC，Variable Length Coding）实现。其基本原理是对信源中出现概率大的符号赋予短码，对于出现概率小的符号赋予长码，从而在统计上获得较短的平均码长。 可变字长编码通常有霍夫曼编码、算术编码、游程编码等。游程编码的压缩效率不高，但编码、解码速度快。 输出直流系数后对紧跟其后的交流系数进行Z型扫描（如图箭头线所示）。Z型扫描将二维的量化系数转换为一维的序列，并在此基础上进行游程编码。最后再对游程编码后的数据进行另一种变长编码，例如霍夫曼编码。通过这种变长编码，进一步提高编码的效率。 运动估计和运动补偿 消除图像序列时间方向相关性的有效手段。 1和2都是消除同帧图像内的像素在空间上的相关系。但是帧和帧的相关信即时间上的相关系由此进行消除，如果两帧之间背景变化不大，那就没必要每一帧单独进行编码，而只对相信帧中变化的部分进行编码。 运动估计：一般将当前的输入图像分割成若干彼此不相重叠的小图像子块，在前或后帧的搜索范围内为每个子块寻找最相似的图像子块。 运动补偿：计算两个子块会得到一个运动矢量。将当前图像的块与参考图像运动矢量所指向的最相似的图像块相减，得到残差图像块；这样可以得到更高的压缩比。 图像帧分为： I（Intra）帧、B（Bidirection prediction）帧、P（Prediction）帧。 I帧只使用本帧内的数据进行编码，在编码过程中它不需要进行运动估计和运动补偿。 P帧在编码过程中使用一个前面的I帧或P帧作为参考图像进行运动补偿，实际上是对当前图像与参考图像的差值进行编码 。 B帧的编码方式与P帧相似，惟一不同的地方是在编码过程中它要使用一个前面的I帧或P帧和一个后面的I帧或P帧进行预测。 综合 图像经过分块，得到的图像块与经过运动补偿的预测图像相减得到差值图像，然后对差值图像进行DCT变换和量化，量化输出的数据有两个去处：1.送给熵编码器编码，编码后的码流输出到缓存器中，等待传送。2.进行反量化和反变化后得到信号，该信号与运动补偿输出的图像块相加得到新的预测图像信号，并将新的预测图像块送至帧存储器。 音频编码基本原理 为什么需要编码 一套双声道数字音频，取样频率为44.1KHz，每样按16bit量化，则其码率为：2 44.1 16 = 1.411 Mbit/s 哪方面入手压缩 去除不能被人耳感知到的信号（20Hz~20KHz），即听觉范围外的音频信号以及被掩蔽掉的音频信号。当同时存在强弱音频时，掩蔽弱音信号。 频谱掩蔽效应 简单来说，人耳对音频有一定的限制，过高或者过底都听不见，同一音频不同的声贝也有可能听不见。因此可以根据这个条件去掉一部份音频。但是如果某音频的音贝提高了，临近的阈值也会提高，所以可以去除掉这一部份的音频。如下图所示： 0.2kHz处出现60dB的声音时，0.1至1kHz的阈值都升高了，虚线以下的声音都需要去除掉，不必传送。 时域掩蔽效应 当强弹音信号同时发出时，还存在时域掩蔽效应。前掩蔽指听到强信号之前短暂时间内，已经存在的弱信号会被掩蔽而听不到。同时掩蔽指同时存在，弱信号会被强信号掩蔽。后掩蔽指强信号消失后，经一段时间才能重新听见弱信号。被掩蔽的弱信号可视为冗余信号。 压缩编码的方法 对于每个音频声道中的音频采样信号，先从时域映射到频域中（子带滤波器）。音频采样块根据心理声学模型计算掩蔽门限值，由此来决定公共比特池中分配给该声道的不同频率域中多少比特数，接着进行量化以及编码工作，最后结合控制参数及辅助数据，产生编码后的数据流。]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-2.主流协议与编码格式]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-2-%E4%B8%BB%E6%B5%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[流媒体协议服务器与客户端之间通信遵循的规定。目前网上主流的媒体协议如下表： 名称 传输层协议 客户端 RTSP+RTP TCP+UDP VLC，WMP RTMP TCP Flash RTMFP UDP Flash MMS TCP/UDP WMP HTTP TCP Flash RTSP(Real-TimeStream Protocol )是一种基于文本的应用层协议，被用于建立的控制媒体流的传输，它为多媒体服务扮演“网络远程控制”的角色。详细 RTMP协议是一个互联网TCP/IP五层体系结构中应用层的协议。RTMP协议中基本的数据单元称为消息（Message）。当RTMP协议在互联网中传输数据的时候，消息会被拆分成更小的单元，称为消息块（Chunk）。 详细 封装格式音视频码流按某种格式存储在一个文件中。如今流行的封闭格式如下： 名称 流媒体(边下边播) 支持的视频编码 支持的音频编码 AVI NO 几乎所有 几乎所有 MP4 YES MPEG-2, MPEG-4, H.264, H.263等 AAC, MPEG-1 Layers I, II, III, AC-3等 TS YES MPEG-1, MPEG-2, MPEG-4, H.264 MPEG-1 Layers I, II, III, AAC FLV YES Sorenson, VP6, H.264 MP3, ADPCM, Linear PCM, AAC等 MKV YES 几乎所有格式 几乎所有格式 RMVB YES RealVideo 8, 9, 10 AAC, Cook Codec, RealAudio Lossless 视频编码主要作用是将视频像素数据（RGB、YUV等）转换成码流，如果不压缩一部电影可达上百G，因此这一步骤非常的重要。命令行使用方式 视频码流分析工具 名称 推出时间 使用领域 备注 HEVC(H.265) 2013 研发中 HM的使用 H.264 2003 各领域 官方标准JM MPEG4 2001 使用率不高 MPEG2 1994 数字电视 VP9 2013 研发中 VP8 2008 不普及 深入 VC-1 2006 微软 H.264仅仅是一个编码标准，而不是一个具体的编码器。瓶颈与解决方法 VP8与H.264 AVS与H.264 音频编码主要 作用是将采集到的（PCM等）压缩成码流，但是一般数据量远小于视频，使用落后的编码标准数据量不会差距很大，主要是为了更高的音质。 名称 推出时间 使用领域 备注 AAC 1997 各个领域 简介 AC-3 1992 电影 MP3 1993 各个领域 WMA 1999 微软 AAC的音频文件格式有以下两种： ADIF：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。这种格式可以用于广播电视。 简言之。ADIF只有一个文件头，ADTS每个包前面有一个文件头。 图中表示出了ADTS一帧的简明结构，其两边的空白矩形表示一帧前后的数据。]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-1.FFmpeg处理流程]]></title>
    <url>%2F%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-1-ffmpeg%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介根据雷神介绍，使用FFmpeg进行音视频处理的步骤分为如下： 解协议，解封装，解码，像素转换，编码，封装，发送。这些步骤又可以分为几个不同的层次，如协议层，封装层，编码层，像素层。 图解 存在某协议的数据，在协议层读取数据（可以从设备中读取Device或者从内存中读取Mem Handler），然后在解封装层进行音视频分离（此时也可进行转换封装格式），得到几个不同的音视频位流。现在可以在解编码层进行解码播放音视频，得到原始数据。此时到了像素层，这里可以进行像素格式转换和添加滤镜等效果，这里还是原始数据，到编码层时，可以进行音视频编码，得到音视频位流，再进行音视频封装或者转换得到封装好的数据，最后进行流推送即可。 协议层（Protocol Layer）：该层处理的数据为符合特定流媒体协议规范的数据，例如http，rtmp，file等。 封装层（Format Layer）：该层处理的数据为符合特定封装格式规范的数据，例如mkv，mp4，flv，mpegts，avi等。 编码层（Codec Layer）：该层处理的数据为符合特定编码标准规范的数据，例如h264，h265，mpeg2，mpeg4等。 像素层（Pixel Layer）：该层处理的数据为符合特定像素格式规范的数据，例如yuv420p，yuv422p，yuv444p，rgb24等。 原文链接：https://blog.csdn.net/leixiaohua1020/article/details/42658139 协议层处理包含以下项目： simplest ffmpeg device：使用FFmpeg读取设备中的媒体数据。 simplest ffmpeg mem handler：使用FFmpeg读取内存中的数据。 simplest ffmpeg streamer：使用FFmpeg发送流媒体数据。 封装层处理包含以下项目： simplest ffmpeg format：使用FFmpeg分离音视频（demux），封装音视频（mux），转换封装格式（remux）。 编码层处理包含以下项目： simplest ffmpeg player：使用FFmpeg解码播放视频数据。 simplest ffmpeg audio player：使用FFmpeg解码播放音频数据。 simplest ffmpeg video encoder：使用FFmpeg编码视频数据。 simplest ffmpeg audio encoder：使用FFmpeg编码音频数据。 simplest ffmpeg picture encoder：使用FFmpeg编码图片。 像素层处理包含以下项目： simplest ffmpeg swscale：使用FFmpeg转换像素格式。 simplest ffmpeg video filter：使用FFmpeg给视频添加滤镜效果。 原文链接：https://blog.csdn.net/leixiaohua1020/article/details/42658139 解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。 解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。 解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。 视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。 原文链接：https://blog.csdn.net/leixiaohua1020/article/details/18893769]]></content>
      <categories>
        <category>视频图像</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[演示五]]></title>
    <url>%2Funcategorized%2F%E6%BC%94%E7%A4%BA%E4%BA%94%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[编译QT5.5.1版本OpenCV]]></title>
    <url>%2FQT%2F%E7%BC%96%E8%AF%91qt5-5-1%E7%89%88%E6%9C%ACopencv%2F</url>
    <content type="text"><![CDATA[前沿因为官方不提供Mingw版本，或者没找到~~~这里选择自己编译一遍。 OpenCV下载 https://opencv.org/releases/ 准备工具CMake与QT5.5.1 本次编译的版本为2.4.13，为目前官方最新版本 编译工作 将下载的OpenCV源码，放于一个文件夹，如下图放于../opencv_2_4_13/sources 创建一个文件夹，用于存放编译完成的文件，下图放于../opencv2_4_13/build_qt 点击Configure弹出对话框，选择MinGW MakeFile和勾选Specify native compilers，点击Next生成makefile 选择QT编译器中的gcc.exe和g++.exe填于对话框中，点击Finish 此时会进行验证 验证通过后，勾选WITH_QT和WITH_OPENGL，其它不动，点击Configure 如果还显示有红色，如下图，再次点击Configure 如果全部都是白色，此时已经配置成功，点击Generate，生成MakeFile 使用CMD打开对应路径，输入mingw32-make make完成 接着进行install 打开生成的目录，include为头文件，x86里面包含lib和dll，收工！！ 编译错误 第一次错误出现在44%的时候，找了半天，需要把源码下的CMakeLists.txt，由ON改成OFF OCV_OPTION(ENABLE_PRECOMPILED_HEADERS “Use precompiled headers” OFF IF (NOT IOS) )]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT编译</tag>
        <tag>视频图像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2FLinux%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前沿以前博客的文章，关于Linux常用命令的总结 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199查看类pwd 查看当前路径more 查看文件内容 分屏一页一页显示ls 查看当前路径的文件 -l详细 -a显示所有 -h人性化 -d显示目录属性 -i查id号ls [选项] [参数] []可有可无head [选项] 文件 查看文件首几行 -q隐藏文件 -v 显示文件 -c 显示多少字节 -n 显示文件头多少行tail [选项] 文件 查看文件末几行 -n末多少行 -f循环读 -s与-f同时使用表示休眠多久再读top 动态显示当前最占资源的进程 ps瞬间网络类ifconfig 查看网卡设置netstat -an 查看当前网络连接curl 命令行浏览器 http://www.cnblogs.com/wangkangluo1/archive/2012/04/17/2453975.htmlwget 网址 下载文件到当前目录tracepath ip或网址 查看本地到达目的地所要跳的点和时间mtr ping和tracepath合并 不断的发数据 查看网络丢包比较好ifdown 网卡名 关闭网卡 ifup 开启dhclient 使用dhcp获得新IP -r 释放当前ipnetstat 查看接口信息 -p 打开socket对应程序 -s 显示端口信息Route 查看路由表权限权限10位 第一位类型 -文件 d目录 l软链接 块设备 字符设备 套接字 管道 -rw-r--r--. 2-4所有者u 5-7所属组g 8-10其它o .代表acl权限 r可读取内容 w可写入(不可删除)chmod [选项] 模式 文件名 修改文件权限 chmod u+w abc 给abc的所有者添加读权限chown 用户名 文件名 把文件的所有者变成用户 或者 用户名:用户组 可以同时改变 chgrp 组名 文件 更改文件组信息umask 查看默认权限 默认不能有执行权限 建立文件后 默认权限为666-umask 目录为777-umaskacl权限 dumpe2fs -h 硬盘名 查看是否开启acl权限mount -o remount,acl 分区名 临时开启 在/tct/fstab上修改永久开启编辑目录类touch 创建空文件mkdir -p [目录名] 创建目录 -p创建一个路径 单个文件不需要cd [目录] 切换目录 cd -回到上次 cd .. 回到上一级相对路径 ../usr/local从当前目录上一级查找 绝对路径 /etc/ 从根目录开始rmdir [目录名] 只能删空的目录 不推荐rm -rf [目录名] 强制删除 -f 强制 -r 一直问cp [选项] [目录] [目标目录] 复制 -r复制目录 -p带属性 -d复制链接文件 -a全部mv [目录] [目标目录] 剪切或者改名ln -s [原文件] [目标文件] 生成链接文件 硬链接与原文件有相同I节点和block 可看作同一文件 不能跨分区 不能对目录使用 软链接 与windows快捷方式类似 用-s创建 使用绝对路径搜索命令locate 文件名 速度快 在后台/var/lib/mlocate搜索 新文件搜不到 更新数据库命令updatedb 部份即可搜到 只能搜文件 /etc/updatedb.conf 查看 筛选规则 prunefs不搜索的文件系统 prunenames不搜文件包含关键字 prunepaths不搜目录更新文件whereis 命令名 只搜索命令 -b 只查可执 -m 只查帮助文档which 文件名 与whereis类似 并且显示该命令的别名find [范围] [条件] 占资源多 功能强大 完全匹配 除非用通配符find /root -iname install.log 按名字查找-user root 按所有者 -nouser 查找没有所有者的文件 -mtime +10 查找10天前修改的文件 -10 10天内 atime文件访问时间 ctime改变文件属性 -size +表示大于 -表示小于 查找文件大小写 k M -inum 以id号查找 -a 逻辑与 -o 逻辑或 grep [选项] 字符串 文件名 在文件当中匹配符合条件的字符串 -i忽略大小写 -v取反 *包含匹配*-exec ls -h &#123;&#125; \; 在find之后 使用第二条命令把找到的结果改变通配符 *补充 ？一个字符 []里面的任意一个 需用“”括起 [a-z] [^a-z]取反 [abc] 帮助命令man 命令 获取指定命令帮助 -f 查看该命令有哪些级别 相当于whatis 命令 -k 查找与该命令相关的 相当于apropos 命令命令 --help 获取命令选项 whereis 命令 判断是否为shell内部命令 help cd 获取内部命令帮助info 命令 查看超详细命令 回车 进入子页面 u上层 n下一小节 p上一小节 q退出压缩命令zip 压缩文件名 源文件 压缩文件 -r 压缩目录unzip 文件名 解压缩gzip 源文件 压缩为.gz 源文件会消失 gzip -c 源文件 &gt; 压缩文件 源文件保留gzip -r 目录 压缩目录下的所有子文件 单个 但是不压缩目录gzip -d 文件名 解压缩 或者 gunzip 文件名bzip2 源文件 不保留源文件 -k保留 不能压缩目录 -d解压缩 或者 bunzip2 加-k保留压缩文件tar -cvf 打包文件名 源文件 打包 -c打包 -v显示过程 -f指定打包后的文件名tar -xvf 打包文件名 -x 解打包 -zcvf 压缩名名.tar.gz 源文件 -z压缩为.tar.gz -zxvf 压缩包名.tar.gz -x解压缩.tar.gz -jcvf压缩成tar.bz2 -jxvf 解压缩.tar.bz2 -ztvf 查找该压缩名内有什么关机与重启命令shutdown -r hh:mm &amp;（后台运行） -c取消 -h关机 -r重启 （halt poweroff init 0 直接关机 不推荐） reboot 重启可以使用 init 6runlevel 查找当前运行级别 x y 当前y从x过来 /etc/inittab 查找开机时运行的级别logout 退出当前用户挂载命令 用户登录查看和用户交互命令即分配盘符mount 查询系统已经挂载设备 -a 依据/etc/fstab的内容 自动挂载mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点 -o：exec/noexec 设定是否允许在文件系统中执行可执行文件; remount 重新挂载已经挂载的文件系统如果系统已经挂载的可以不写设备文件名 mount -t ios9660 /dev/sr0 /mnt/cdrom 挂载光盘umount 设备文件名或者挂载点 都一样 卸载挂载点fdish -l 查看系统识别的硬盘，主要用于查看外设备名 光盘默认/dev/sr0 或者/dev/cdrom（软链接）mount -t vfat /dev/sdb1 /mnt/usb/ 挂载u盘 vfat==fat32w命令 查看登录用户信息 who命令 与w类似last命令 查询当前与过去登录用户和时间 /var/log/wtmp数据lastlog命令 查看系统中所有的用户登录时间 /var/log/lastlogecho [选项] [内容] 要使用转义 需要加选项 -e &quot;\e[1;31m \e[0m&quot; 从\e到\e 把里面变成红色vi或者vim 文件名 打开并进入或者创建并进入运行 bash shell文件名 或者 chmod 755 shell文件名 ./shell文件名alias 查看系统命令的 原名 或者 alias vi=&amp;#39;vim&amp;#39;即把vi变成vim unalias 别名 删除别名 vi ~/.bashrc 别名永久生效命令顺序 绝对路径或相对路径的命令 &gt; 别名 &gt; bash的内部命令 &gt; $path上找到的第一个命令history [选项] [历史命令保存文件] 查看历史命令 -c清空 -w写入文件 ~/.bash_history /etc/profile里面可以更改保存数据多少输出重定向命令&gt;文件 覆盖的方式 输出到指定文件或设备 &gt;覆盖 &gt;&gt;追加错误命令 2&gt;文件 2不可缺失 与上面使用类似 但是左不能有空格命令 &gt; 文件 2&gt;&amp;1 正确就输出到文件 错误就把错误写到正确当中 再写到文件 与 &amp;&gt; 一样命令 &gt;&gt;文件1 2&gt;&gt;文件2wc [选项] [文件名] -c统计字节数 -w统计单词数 -l统计行数&lt; 输入重定向 如 wc &lt; 文件 wc &lt;&lt; abc 一直输入到abc 统计之间的数据多命令顺序执行命令1;命令2 一个一个执行 &amp;&amp; ||管道 命令1 | 命令2 将1的正确输出作为2的操作对象 a=123 echo $a 输出123 echo &amp;#39;$a&amp;#39; 输出$a echo &quot;$a&quot; 输出123&amp;#39;&amp;#39; 所有特殊符号都无效 &quot;&quot;除了$(取值) `(引用命令) \(转义) 其他符号无效a=`ls` echo &quot;$aa&quot; 相当于执行ls 相当于 a=$(ls) echo $avi编辑器vi-&gt;vim 支持多级撤销 跨平台 语法高亮 图形界面vim 文件名 打开或者创建文件 vim +x 文件名 光标处于第x行打开或者创建文件 若没有x 即最后一行 vim +/字符串 文件名 打开文件 光标跳到第一次配的行首 vim aa bb cc 即打开aa bb cc文件 以在命令行上输入n向下个文件 N或者prev向上个文件 进入后 属于命令模式 输入 i 转向编辑模式 esc切换至低行模式 输入:wq (w保存 q退出 !即强制 退不出去可强制退出!q) 命令模式连按两个d 删除光标当前行 o在当前行下方插入一行并切换到输入 yy 复制当前行 p在当前行下方粘贴 P上方 :ls 列出打开的文件 :数字 光标跳转 :/xxx 向后匹配 :?xxx向前匹配 kjhi 光标上下左右 ctrl+f向下翻页 +b向上 +d向下半页 +u向上磁盘管理df 查看磁盘分区使用情况 -l显示本地磁盘 a 显示所有文件系统 h人性化 H以1000进制输出单位 T显示磁盘分区类型 t显示指定类型文件系统分区 x不显示du 统计磁盘上文件大小 -b 以byte为单位 k 以kb m以mb h以1024 H以1000 s指定统计目标fdisk 显示硬盘信息（MBR） fdisk 硬盘名 m查看操作信息 看显示信息操作 操作完w即可保存parted 分区工具 （可gpt也可mbr） 输入select 硬盘名 mklabel msdos或者gpt确实格式 mkpart 添加分区 交互式操作 print查看当前分区情况 mkpart 分区名 开始位置M 结束位置M (直接命令生成) rm 分区号 删除分区 mkfs.ext3 /dev/sda 分区格式化 将sda这个分区格式化为ext3 与mkfs -t ext3 /dev/sda效果一样开机自动挂载 /etc/fstab 文件 在末行 设备名称 挂载点 文件类型 defaults 0 0mkswap /dev/sdb 把该分区建立成交换分区 swapon /dev/sdb启动 swapoff关闭 在 fdisk接着t里面设置为82号格式用户信息/etc/group 组名 : 组密码占位符 : 组编号 : 组中用户名列表/etc/gshadow 与group一一对应 组名称 : 组密码 : 组管理者 : 组用户列表/etc/passwd 用户名 密码点位符 编号 组编号 注释信息 主目录 shell类型/etc/shadow 用户名 密码(加密了) 后面没啥用 groupadd 组名 添加组 -g 带编号groupmod -n 改名后名 改名前名 更改组名 -g 编号 组名 更改组编号groupdel 组名 删除组(注意先删除用户)useradd -g 用户组 用户名 添加用户 -d 路径 用户名 指定路径创建用户 -G 接着-g后面 用户组2，用户组3.。。同时添加多用户组usermod -c 备注信息 用户名 给该用户添加备注 -l 后用户名 前用户名 修改用户名 -d 目录 用户名 更改用户目录 -g 新用户组 原用户组 更改用户组userdel 用户名 删除用户 -r包括文件passwd -l 用户名 锁定用户 -u 解锁 -d 不需要密码登录gpasswd -a 用户名 组名 添加用户到该组 该组为附属组 -d为删除newgrp 用户组 切换用户组gpasswd imooc 修改组密码id 用户名 显示用户信息 groups 用户名 显示用户所在组chfn 用户名 设置用户资料finger 用户名 显示详细资料根目录下的文件夹用途bin sbin usr/bin usr/sbin 存放系统命令 bin普通 sbin超级用户boot 启动目录 保存启动数据dev 硬件文件etc 系统默认配置文件home root 用户目录lib 函数库media misc mnt 空目录 挂载使用proc sys 内存过载点 不能动tmp 临时目录usr 系统软件资源var 启动可变文档tab键 一下补全 两下把所有相关的显示上下键 翻出历史命令 !n运行第n条命令 !!运行上一条命令 !字串 重复执行第一个匹配命令ctrl+l清屏ctrl+c或者ctrl+d 强制终止ctrl+a 移动到命令行首ctrl+e 移动到行尾ctrl+z 从光标位删除到行首ctrl+z 把命令放入后台ctrl+r 历史命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT数据库之SQLite]]></title>
    <url>%2FQT%2Fqt%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8Bsqlite%2F</url>
    <content type="text"><![CDATA[前沿QT中，已经内置了一个专门为数据库操作的库，并且QSqlQuery提供了执行SQL语句并返回结果。并提供了抽象层的QSqlTableModel和QSqlRelationalTableModel。 层次 描述 驱动层 数据库与SQL接口底层桥接，如QSqlDriver、QSqlDriverCreator、QSqlDriverCreatorBase、QSqlDriverPlugin、QSqlResult SQL接口层 QSqlDatabase类提供了数据库访问类、数据库连接操作，QSqlQuery类提供了与数据库的交互操作，还有QSqlError、QSqlField、QSqlTableModel、QSqlRecord 用户接口层 提供从数据库数据到用于数据表示的窗体映射，包括QSqlQueryModel、QSqlTableModel、QSqlRelationalTabl SQLite基于C语言，已经广泛应用各行业。可以直接读写硬盘数据，也可存在内存中，无须服务器进程或引擎。开源，代码量少，注释多。占用内存极少。支持视图、触发器和事务，支持嵌套SQL。提供虚拟机处理SQL语句。不配置、不安装。编程接口易用。 基本使用，插入，更新，删除，查找pro文件上 QT += sql 12345678910111213141516171819202122232425262728293031323334353637QSqlDatabase db;if (QSqlDatabase::contains("qt_sql_default_connection")) //默认库名，如果存在 不需要再设置&#123; db = QSqlDatabase::database("qt_sql_default_connection");&#125; else &#123; db = QSqlDatabase::addDatabase("QSQLITE");//第二个参数可以填一个char *类型，方便下次使用，下次可以用上面的方法直接取到该数据库，而且一个程序中，不需要多次打开库。 db.setHostName("localhost"); db.setDatabaseName("database.db"); db.setUserName("root"); db.setPassword("123456"); &#125; if (!db.open()) &#123; qDebug() &lt;&lt; "open false:" &lt;&lt; db.lastError(); &#125; QSqlQuery sqlQuery; qDebug()&lt;&lt;sqlQuery.exec("drop table girlfriend"); qDebug()&lt;&lt;sqlQuery.exec("create table girlfriend (id int primary key,name varchar(50),money double)");//建表 qDebug()&lt;&lt;sqlQuery.exec("insert into girlfriend values(1,'ming',6.66)"); qDebug()&lt;&lt;sqlQuery.exec("insert into girlfriend values(2,'ning',8.88)"); qDebug()&lt;&lt;sqlQuery.prepare("insert into girlfriend values(?,?,?)"); sqlQuery.bindValue(0,3); sqlQuery.bindValue(1,"ling"); sqlQuery.bindValue(2,9.99); sqlQuery.exec(); sqlQuery.exec(QString("update girlfriend set money=%1 where name = 'ling'").arg(99.99)); sqlQuery.exec("delete from girlfriend where id = 1"); qDebug()&lt;&lt;sqlQuery.exec("select * from girlfriend"); while(sqlQuery.next())&#123; qDebug()&lt;&lt;sqlQuery.value(0)&lt;&lt;sqlQuery.value(1)&lt;&lt;sqlQuery.value(2); &#125; 当前支持数据库 驱动 数据库管理系统 QDB2 IBM DB2及以上 QIBASE Borland InterBase QMYSQL MySQL QOCI Oracle call Interface Driver QODBC ODBC包括微软SQL Server和其它兼容ODBC QPSQL PostgreSQL 6和7 QSQLITE 3及以上 QSQLITE2 2 QTDS Sybase Adaptive Server]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提取HTML信息]]></title>
    <url>%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%2F%E6%8F%90%E5%8F%96html%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[前沿 有时候需要从HTML文件上找指定标签上的内容，自己平时用QString的字符串操作，比较麻烦，于是网上找了几个库，记录下来。使用平台是windows QT mingw32 HTMLCXX经过使用，该库符合以下几项要求：使用简单，运行高效。将HTML文件夹和CSS文件夹导入工程即可。使用参考下文。这样已经可以满足我们获取标签上的内容。如果还需要获取CSS，可以看htmlcxx.cc，里面有一个很完整的例子。该库还可以编译成.lib导入工程使用。 手册，找不到原出处，贴上博客：https://blog.csdn.net/ictextr9/article/details/6893085 123456789101112131415161718192021222324252627282930313233343536#include &lt;htmlcxx/html/ParserDom.h&gt; ... using namespace std; using namespace htmlcxx; //Parse some html code string html = "&lt;html&gt;&lt;body&gt;hey&lt;/body&gt;&lt;/html&gt;"; HTML::ParserDom parser; tree&lt;HTML::Node&gt; dom = parser.parseTree(html); //Print whole DOM tree cout &lt;&lt; dom &lt;&lt; endl; //Dump all links in the tree tree&lt;HTML::Node&gt;::iterator it = dom.begin(); tree&lt;HTML::Node&gt;::iterator end = dom.end(); for (; it != end; ++it) &#123; if (strcasecmp(it-&gt;tagName().c_str(), "A") == 0) &#123; it-&gt;parseAttributes(); cout &lt;&lt; it-&gt;attribute("href").second &lt;&lt; endl; &#125; &#125; //Dump all text of the document it = dom.begin(); end = dom.end(); for (; it != end; ++it) &#123; if ((!it-&gt;isTag()) &amp;&amp; (!it-&gt;isComment())) &#123; cout &lt;&lt; it-&gt;text(); &#125; &#125; cout &lt;&lt; endl; GUMBO该库完全由C99编写。另外有C++版本（https://github.com/lazytiger/gumbo-query） 官方设定： 完全符合HTML5规范。 坚固耐用，输入不良。 简单的API，可以很容易地被其他语言包装。 支持源位置和指针返回原始文本。 支持片段解析。 相对轻量级，没有外部依赖性。 传递所有html5lib测试，包括模板标记。 测试了谷歌指数超过25亿页。 根据官方介绍，进行编译，在QT mingw32下，直接导入源文件也能使用。或者编译出.h lib*.a .dll导入工程即可。数据结构大概参考下图，下图省略了很多小标签，结构非常值得参考。 图片转自 12345678910 使用下面两个方式，将html字符串传入，得到GumboOutput*的一个结构体，可以从该结构体中获取到想要的数值。 方式一： GumboOutput* output = gumbo_parse(contents.c_str());//do something gumbo_destroy_output(&amp;kGumboDefaultOptions, output); 方式二： GumboOutput* output = gumbo_parse_with_options( &amp;kGumboDefaultOptions, contents.data(), contents.length());//do something gumbo_destroy_output(&amp;kGumboDefaultOptions, output); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647官方示例，实际用得不深入，以后还会另开博客写该类。简单介绍下example，为查找A标签的href属性值#include &lt;stdlib.h&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include "gumbo.h"static void search_for_links(GumboNode* node) &#123; if (node-&gt;type != GUMBO_NODE_ELEMENT) &#123;//不是元素，递归返回 return; &#125; GumboAttribute* href; if (node-&gt;v.element.tag == GUMBO_TAG_A &amp;&amp; (href = gumbo_get_attribute(&amp;node-&gt;v.element.attributes, "href"))) &#123;//是A标签，gumbo_get_attribute查找href属性，如果找到就返回，找不到返回NULL，不区分大小写 std::cout &lt;&lt; href-&gt;value &lt;&lt; std::endl; &#125; GumboVector* children = &amp;node-&gt;v.element.children;//指向子结点 for (unsigned int i = 0; i &lt; children-&gt;length; ++i) &#123; search_for_links(static_cast&lt;GumboNode*&gt;(children-&gt;data[i]));//递归查找 &#125;&#125;int main(int argc, char** argv) &#123; if (argc != 2) &#123; std::cout &lt;&lt; "Usage: find_links &lt;html filename&gt;.\n"; exit(EXIT_FAILURE); &#125; const char* filename = argv[1]; std::ifstream in(filename, std::ios::in | std::ios::binary); if (!in) &#123; std::cout &lt;&lt; "File " &lt;&lt; filename &lt;&lt; " not found!\n"; exit(EXIT_FAILURE); &#125; std::string contents; in.seekg(0, std::ios::end); contents.resize(in.tellg()); in.seekg(0, std::ios::beg); in.read(&amp;contents[0], contents.size()); in.close(); GumboOutput* output = gumbo_parse(contents.c_str());//将从文本读到的html字符串传入，获得GumboOutput结构体 search_for_links(output-&gt;root); gumbo_destroy_output(&amp;kGumboDefaultOptions, output);//析构结构体&#125;]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>Library</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIOS与系统引导]]></title>
    <url>%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%2Fbios%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[前言从某书上看到，记录下来~~ BIOSBasic Input/Output System，输入输出系统。当CPU的复位引脚被触发，在0xfffffff0处执行一条命令，转跳到ROM中的启动代码，并开始执行，这些代码称为BIOS。 主要作用硬件自检（BIOS自检、上电自检POST），检测系统外围关键设备是否正常。如果自检发现严重故障，直接停机，没有任何提示或者信号，非严重故障，出现提示或者报警信号。 引导设备在BIOS中需要设定一个顺序，在自检完成之后，按顺序将控制权转交给外部设备。 系统引导PC引导（bootloader）分两部分，主引导记录（MBR），引导位于某个分区上的第二部分引导程序，如NTLDR、BOOTMGR、GRUB。主引导主要告诉计算机，硬盘哪个位置找操作系统，1~446字节：调用操作系统的机器码，447~510：分区表，511~512：主引导记录签名（0x55和0xAA） 从BIOS上获取到控制权后，读取该设备的第一扇区（前512字节），如果最后两字节为0x55和0xAA，就表明设备可以启动，否则将控制权移到下一设备。 分区分区表长度64字节，分为4项，每项16字节，所以一个硬盘最多只有4个一级分区（主分区）。第1字节：0x80表示主分区激活，一级分区只能有一个是激活的。2~4字节：主分区第一扇区的物理地址（柱面、磁头、扇区号等）。5：主分区类型。6~8：主分区最后一个扇区的物理位置。9~12：第一个扇区的逻辑地址。13~16：主分区的扇区总数。所以一个分区最大为扇区大小*(2^32)。 系统在激活的主分区：计算机会读取激活分区的第一个扇区，激活分区叫作卷引导记录（VBR），此时会加载操作系统。 系统在逻辑分区：分区表只有四项，因此规定了其中一个区可以定义成扩展分区，在该分区中又有多个逻辑分区。先读取第一个扇区扩展引导记录EBR，里面也包含一张64字节的分区表，分区表分为两项，描述第一个逻辑分区和描述第二个逻辑分区，这样可以完成无限个分区连续。如果要启动这个分区上的系统，需要事先安装好启动管理器，如GRUB，这意味着第二部分代码启动了，在此选择启动系统。]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTTP运作]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E6%B5%85%E8%B0%88http%E8%BF%90%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[HTTP超文本传输协议该协议主要应用于应用层，用于传输两个计算机之间的文件。主要是Web服务器和客户端。 HTTP定义了一个GET方法，如果客户端想要数据，就发送HTTP GET请求，并列出文件名。如果Web决定回应，即返回码200，表示OK和响应内容。404即找不到文件。 网页上的文件称为对象，如文本、图形、动画、音视频等。想要获取这些数据，必须得到第一个文件，才能通过访文件内包含的URL获取更多，即先进入别人的网站才能获取资源。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈TCP与UDP]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E6%B5%85%E8%B0%88tcp%E4%B8%8Eudp%2F</url>
    <content type="text"><![CDATA[两者优势既然TCP和UDP同时存在于传输层，那么各自都有不可取代的优势。首先，两都都可以根据端口号正确选择对应的应用程序（多路复用）。TCP提供的是可靠性连接，带有错误恢复，有序数据传输和数据分段，避免拥塞。而UDP报头数据比TCP少，在传输过程中开销少，并且不会像TCP一样进行避免拥塞，而减慢传输效率。 TCP报头 源端口 目标端口 序列号 确认数 偏移量 保留 代码位 窗口 校验和 紧急标志 第行4字节，共20字节，TCP字段（L4PDU、数据段） 多路复用计算机会运行很多软件，同时会发送很多数据，而接收回来的数据TCP和UDP多路复用让计算机知道将数据交给哪个应用。是基于socket实现的，而socket由3部分组成：IP地址、端口号、传输协议，这样的组合可以完成唯一定位。客户方发送时，端口动态分配1024以后，服务端口号必须已知，侦听连接客户端请求。 TCP三次握手TCP连接指的是两个套接字之间的连接。通过 客户向服务发送SYN。服务向客户发送SYN,ACK。客户向服务发送ACK。完成连接。由于IP地址记录在IP报头，所以TCP报头只记录端口号即可。 SYN：同步化序列号。ACK：指目前接收的确认值，附带滑动窗口大小。 终止连接：ACK,FIN。ACK，ACK,FIN。ACK。第二步骤发送的第一条ACK为告知客户，已经收到，防止多次发送。统称为面向连接。而UDP则无连接。 面向连接：需要在传输数据之前交换消息或需要在两个端点间预先设立关联协议 无连接：不需要交换消息或不需要在终端之间预先设定关联的协议 TCP错误确认客户向服务发送数据 1000字节，序列号0 1000字节，序列号1000 1000字节，序列号2000 1000字节，序列号3000如果服务端回复无数据，确认值4000，那么客户就发送下一组。如果服务回复无数据，确认值2000，表明接收了2000字节，所以发送序列号为2000的那组，以完成数据错误恢复。错误时，客户会等待，并不会发送下一组，启动一个计时器。 滑动窗口（Slice Window）TCP使用窗口概念实现了流量控制。应用在待解决和待确认状态的数据。是接收主机告知发送主机可以接收多少数据，然后发送主机根据实际进行加减速发送。而接收主机是根据是否丢数据段或者网络堵塞现象来进行判断。 UDP为应用程序提供服务，使它们能够交换消息。提供无连接，不使用窗口技术，不对数据排序，也不把大数据分成小数据。但是实现了数据传输和多路复用。所以开销低。但是需要容忍数据丢失，或者有恢复丢失数据的程序机制。 UDP报头 源端口 目标端口 长度 校验和 每行4字节，共8字节]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[㳀谈域名解析与地址解析]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E3%B3%80%E8%B0%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[域名解析DNS因IP地址为数字，这是不能接受的，因此产生域名，将域名和IP绑定在一起。 将主机名发送到DNS服务器，服务器解析后，返回对应的IP地址，然后再发送对应的数据包。 IP地址分布在多个DNS服务器上，通过协同工作，彼此转发查询获取IP地址信息。 使用UDP的IP数据包发送。 地址解析协议ARP主机和路由间是不知道互相的MAC地址的，但是数据链路转发时需要知道MAC地址。所以产生ARP。 概念：是LAN上任何主机或路由动态获取同一LAN上另一台IP主机或路由器MAC地址的方法。定义了一个包含ARP请求的协议和ARP回复，列出源IP地址和相匹配的MAC地址。主机会记录ARP结果，存在ARP缓存或ARP表中。 统一资源定位符URL用户使用Web服务时，可以输入一个URL去确定一个想要获取的Web网页。 http://www.bugnull.com/index.html 其中http是方案（协议） www.bugnull.com 是授权机构（服务器的名称） index.html是路径（Web页面）]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[㳀淡路由转发]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E3%B3%80%E6%B7%A1%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[路由转发逻辑检查数据链路FCS，确定帧没有错误；删除帧中旧的数据链路报头和报尾，留下IP数据包。将IP数据包的目的IP地址与路由表比较，找到与目标地址相匹配的路由。将IP数据包封装进新的输出接口的数据链路报头和报尾，转发。直到数据包到达最终目的地。 路由器在匹配目的IP时，会考虑网络号所在的地址组，网络号和子网号代表一组以相同前缀开头的地址。 MAC地址是通过数据链路进行传输，传输到该MAC的网口上，网口复制该信息，然后检验FCS，查找目的IP与路由表，并将下一跳的MAC写入，转发。 路由选择协议的目的动态地获知到网络中所有子网的路由，并加入到路由表中，只保存最佳路由，及时检查路由表的有效性失效就删除，若删除了一条路由，若发现新途径，则添加。尽快找替代失效的路由，花费的时间称收敛时间。防止环路。 每一台路由都为直接与其连接的各个子网在其路由表中添加一条路由。都把自己所存的表告知相邻的路由。从相邻路由获知新路由后，路由选择协议将在路由表中添加一条路由，该路由器获知的来源通常就是下一跳的相邻路由器。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈IPv4寻址]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E6%B5%85%E8%B0%88ipv4%E5%AF%BB%E5%9D%80%2F</url>
    <content type="text"><![CDATA[前沿IP定义了网络层地址，然后路由根据它来识别与TCP/IP网络连接的任何主机或路由器接口。TCP/IP将IP地址编制成地址组，位于同一地址组里的IP地址使用的物理网络是相同的。路由器根据该地址组可以将每个IP网络或IP子网的整体列成一个路由表，而不是每个单个IP地址一个表项。 寻址的规则设备必须有一个IP地址，由32位数字组成。能够收发IP数据包的设备都称为IP主机。 IP地址分组原理TCP/IP把IP地址编成一系列连续地址组的最初的详细说明称为IP网络。同一网络中的所有地址的第一部分数值都是相同的。（同一地址组里的所有IP地址不能被路由器分隔；被路由器分融的IP地址必须属于不同的地址组） A、B、C类IP网络号IP地址前8位即十进制第一个数字，1~126为A类，B类以128~191，C类192~223，前三类都为单播地址。224~239定D类多播地址，可以将数据包发送给多台主机。 A类网络：以1-126开头，每个网络可以存在256 256 256-2个主机。全0（网络号）全1（广播地址，因此减去2） B类网络：以128-191开头，并且与第二位十进制组合，每个网络可以存在256*256-2个主机 C类网络：以192-223开头，道孚县与第二第三位十进制组成，可以包含254个主机 IP子网划分子网划分定义了细分IPv4地址空间的方法，可以将单独的IP网络进一步细分 成许多较小的组。类似的如果使用一个B类网络对一个LAN进行配置，将LAN中每个路由上都配上B类网络的子网，如150.1.1.0，可以节省非常多的IP地址，当然也可以用多个B类网络进行配置~~~~ IPv4路由选择如果目的IP地址与源主机在同一个子网内，直接把数据包发送给目的主机；否则，把数据包发送给源主机默认网关。 IPv4报头 版本 报头长度 DS字段 数据包长度 标识 标志位 分段偏移 生存周期 协议 报头校验和 源IP地址 目的IP地址 总共20字节 每一行4字节]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈以太网]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E6%B5%85%E8%B0%88%E4%BB%A5%E5%A4%AA%E7%BD%91%2F</url>
    <content type="text"><![CDATA[以太网概念：一系列的LAN协议和标准，定义了最常见的有线LAN技术类型中的物理层和数据链路层。由美国电气和电子工程师协会IEEE制定，并以数字802.3作为起始部分进行命名。 以太网的类型根据速率和电缆类型分为10BASE-T、100BASE-T、1000BASE-LX、1000BASE-T、10GBASE-T（速率单位为Mbps） 以太网链路两个以太网节点间的所有物理电缆。 直连与交叉：因为规定RJ45是通过12引角发送36引脚接收，45发送78接收；常用的电缆为UTP（非屏蔽双绞线）。为了方便，集线器和交换机做成36引脚发送，可以不使用路线直接相连。 常用以太网帧 字段 字段长度 描述 前导码 7 同步 开妈帧分隔符 1 表示下一个字节开始将是目的MAC 目的MAC 6 标识该帧的预订接收方 源MAC 6 标识该帧的发送方 类型 2 定义了帧中所含协议类型：IPv4 IPv6等 数据和填充 46-1500 存储高层数据。不足46需要自动填充 帧检验序列 4 为接收方网卡提供判断帧完整的方法 以太网寻址以太网地址称为MAC（介质访问控制），是一个12位十六进制数。大多数MAC标识一个单独的网卡或其它以太网口，称为单播以太网地址。由IEEE和制造商确保MAC的不重复性。广播地址：标识LAN中所有设备的地址。多播地址：在以太网中，多播地址表示以太网LAN中当前所有设备的子集。 全双工和半双工全双工指可以边发送，边接收以太网帧。半双工指接收以太网帧时，不能同时发送。使用半双工是由于LAN集线器，因为集线器在同一时间接收多个信号，电信号就会发生冲突，以至于无法识别，属于物理层硬件。 半双工机制：CSMA/CD（载波侦听多路访问/冲突检测）有一设备发送帧时，同一集线器内所有设备会同时接收该帧，所以不会再发送，但是还是会出现同时发出的情况，所以这里，同时发送设备都取消，随机一个等待时间，再发送，直到发出去为止。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈TCP/IP与OSI网络模型结构]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E6%B5%85%E8%B0%88tcp-ip%E4%B8%8Eosi%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[TCP/IP网络模型TCP/IP模型按层分可以分为五层（最初的模型只有四层，将链路层拆分为数据链路层和物理层）。每一层都包含与该功能分类相关的协议和标准。 四层（应用层，传输层，互联网层，链路层） 五层（应用层，传输层，网络层，数据链路层，物理层） 应用层为运行在计算机上的应用软件提供服务。常用协议：HTTP超文本传输协议，POP3邮局协议3，SMTP简单邮件传输协议 传输层为应用层提供服务。常用协议：TCP传输控制协议，UDP用户数据报协议 网络层最重要的是寻址和路由选择。协议：IP互联网协议。 寻址：每台TCP/IP主机都需要有一个独一无二的地址，以便被识别；将地址分组。 路由选择：利用IP协议，将IP数据包传输到另一个设备的服务。 链路层定义了通过物理网络来传递数据所需的协议和硬件。链路指两个设备间的物理连接或链路，并通过协议来控制。路层会根据网络层的要求，完成具体发送数据包的工作。常用协议：PPP点到点协议、以太网、HDLC高级数据链路控制 数据名称应用层产生数据在传输层增加报头则产生数据段，网络层增加IP报头内则产生数据包，数据链路层增加报头和报尾产帧。 OSI网络模型OSI模型分为七层，与TCP/IP比较类似。 七层（应用层，表示层，会话层，传输层，网络层，数据链路层，物理层）每层的数据名称根据层号来分，以物理层为第一层，所以网络层的数据名称为L3PDU 第三层协议数据单元。 应用层提供应用程序与网络之间的接口。 表示层协商数据格式。 会话层提供多个双向消息分组到一个工作流的方法。 其它几层功能与TCP/IP类似。 分层协议的优点降低复杂性，将概念细分成多个小部分，达到解耦。标准化接口。互用性，只要遵守标准开发的产品，都可以在同一个网络中工作。模块化。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[演示四]]></title>
    <url>%2Funcategorized%2F%E6%BC%94%E7%A4%BA%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[演示三]]></title>
    <url>%2Funcategorized%2F%E6%BC%94%E7%A4%BA%E4%B8%89%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[演示二]]></title>
    <url>%2Funcategorized%2F%E6%BC%94%E7%A4%BA%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[二进制文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[演示一]]></title>
    <url>%2Funcategorized%2F%E6%BC%94%E7%A4%BA%E4%B8%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[QT的衣服--样式表]]></title>
    <url>%2FQT%2Fqt%E7%9A%84%E8%A1%A3%E6%9C%8D-%E6%A0%B7%E5%BC%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[之前一直想找本书，介绍各个控件的样式表与子部件，发现并没有，只能通过官方网站的介绍（甩网址三连）： 样式表的作用 样式表参考 样式表例子 一、设定样式表1231.通过UI设置“改变样式表”,将对应的样式表写进去2.通过代码设置，控件使用setStyleSheet(QString)3.通过文件，读取文本，将文本使用setStyleSheet(QString)写入qApp中 二、指定对象设置样式表123456789101112131415类中有多个按钮，但是需要设置成不同的样子QPushbutton btn1,btn2,btn3;1.btn1.setStyleSheet("");btn2.setStyleSheet("");btn3.setStyleSheet("");2.btn1.setObjectName("btn1");btn2.setObjectName("btn2");btn3.setObjectName("btn3");this.setStyleSheet("QPushbutton#btn1&#123;&#125;QPushbutton#btn2&#123;&#125;QPushbutton#btn3&#123;&#125;");类#类名::子部件:伪状态&#123;&#125; 应该是这个形式了还有一个更复杂的，修改QTabWidget的QTabBar点击下去的属性QTabWidget#tabWidget QTabBar::tab:selected&#123;&#125; 样式表学习可以通过CSS，因为有时候有点迷，找前端的妹子问一下，就可以了~~~两者相似度估计达80% 因为每个控件都有自己独特的样式表，列举不完，而且也比较菜~~~~经验自己总结总结，本人也会总结，看情况再更新这个吧。打个赌，哈哈。2019-03-02 16:38-58]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路径的集合QPainterPath]]></title>
    <url>%2FQT%2F%E8%B7%AF%E5%BE%84%E7%9A%84%E9%9B%86%E5%90%88qpainterpath%2F</url>
    <content type="text"><![CDATA[经常把这个跟QPainter结合使用，比较方便~~~ 12345678QPainterPath是一个集合，比如我要画个矩形，不通过addRect方法，使用lineTo，它会保存当前点，如QPainterPath path;path.moveTo(10,10);path.lineTo(20,10);path.lineTo(20,20);path.lineTo(10,20);path.lineTo(10,10);以上一个点为终于，不需要设置，如果从来 可以调用void closeSubpath(); 一、API介绍 函数名 意义 void closeSubpath(); 将当前点设回（0，0） void moveTo(const QPointF &amp;p); 将当前点移动到某点 inline void moveTo(qreal x, qreal y); void lineTo(const QPointF &amp;p); 从当前点画直线到某点 inline void lineTo(qreal x, qreal y); void arcMoveTo(const QRectF &amp;rect, qreal angle); 移动到某点，计算方式为以某矩形为外接矩形的angle角度处 inline void arcMoveTo(qreal x, qreal y, qreal w, qreal h, qreal angle); void arcTo(const QRectF &amp;rect, qreal startAngle, qreal arcLength); 从当前点画圆弧 inline void arcTo(qreal x, qreal y, qreal w, qreal h, qreal startAngle, qreal arcLength); void cubicTo(const QPointF &amp;ctrlPt1, const QPointF &amp;ctrlPt2, const QPointF &amp;endPt); 三次样条曲线，c1和c2为控制点 inline void cubicTo(qreal ctrlPt1x, qreal ctrlPt1y, qreal ctrlPt2x, qreal ctrlPt2y,qreal endPtx, qreal endPty); void quadTo(const QPointF &amp;ctrlPt, const QPointF &amp;endPt); 二次样条曲线， c为控制点 inline void quadTo(qreal ctrlPtx, qreal ctrlPty, qreal endPtx, qreal endPty); QPointF currentPosition() const; 当前位置 void addRect(const QRectF &amp;rect); 插入一个矩形 inline void addRect(qreal x, qreal y, qreal w, qreal h); void addEllipse(const QRectF &amp;rect); 插入一个圆 inline void addEllipse(qreal x, qreal y, qreal w, qreal h); inline void addEllipse(const QPointF &amp;center, qreal rx, qreal ry); void addPolygon(const QPolygonF &amp;polygon); 插入一个多边形 void addText(const QPointF &amp;point, const QFont &amp;f, const QString &amp;text); 插入文字 inline void addText(qreal x, qreal y, const QFont &amp;f, const QString &amp;text); void addPath(const QPainterPath &amp;path); 添加一个路径 void addRegion(const QRegion &amp;region); //Adds the given region to the path by adding each rectangle in the region as a separate closed subpath. void addRoundedRect(const QRectF &amp;rect, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize); 添加圆角矩形 inline void addRoundedRect(qreal x, qreal y, qreal w, qreal h,qreal xRadius, qreal yRadius,Qt::SizeMode mode = Qt::AbsoluteSize); void addRoundRect(const QRectF &amp;rect, int xRnd, int yRnd); inline void addRoundRect(qreal x, qreal y, qreal w, qreal h,int xRnd, int yRnd); inline void addRoundRect(const QRectF &amp;rect, int roundness); inline void addRoundRect(qreal x, qreal y, qreal w, qreal h,int roundness); void connectPath(const QPainterPath &amp;path); 以当前结束点为起点 添加path bool contains(const QPointF &amp;pt) const; 是否包含该点 bool contains(const QRectF &amp;rect) const; 是否包含该矩形 bool intersects(const QRectF &amp;rect) const; 是否与之相交 void translate(qreal dx, qreal dy); 平移 inline void translate(const QPointF &amp;offset); QPainterPath translated(qreal dx, qreal dy) const Q_REQUIRED_RESULT; inline QPainterPath translated(const QPointF &amp;offset) const Q_REQUIRED_RESULT; QRectF boundingRect() const; 返回外接矩形 QRectF controlPointRect() const; 比boundingRect快 是它的超集 Qt::FillRule fillRule() const; void setFillRule(Qt::FillRule fillRule); bool isEmpty() const; QPainterPath toReversed() const Q_REQUIRED_RESULT; 返回一个反向路径 QList toSubpathPolygons(const QMatrix &amp;matrix = QMatrix()) const; 返回路径吧 底下几个都有点像 QList toFillPolygons(const QMatrix &amp;matrix = QMatrix()) const; QPolygonF toFillPolygon(const QMatrix &amp;matrix = QMatrix()) const; QList toSubpathPolygons(const QTransform &amp;matrix) const; QList toFillPolygons(const QTransform &amp;matrix) const; QPolygonF toFillPolygon(const QTransform &amp;matrix) const; int elementCount() const; QPainterPath::Element elementAt(int i) const; void setElementPositionAt(int i, qreal x, qreal y); qreal length() const; qreal percentAtLength(qreal t) const; QPointF pointAtPercent(qreal t) const; qreal angleAtPercent(qreal t) const; qreal slopeAtPercent(qreal t) const; bool intersects(const QPainterPath &amp;p) const; bool contains(const QPainterPath &amp;p) const; QPainterPath united(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; QPainterPath intersected(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; QPainterPath subtracted(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; QPainterPath subtractedInverted(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; 二、从QPainterPath中获取所有数据并绘制出来（包括文字轮廓，文字轮廓也可以用FreeType~~~~）1234567891011121314QPainterPath path;path.addRect(30,30,30,30);path.addText(100,100,QFont("宋体",80),"135赟");QList&lt;QPolygonF&gt; list=path.toSubpathPolygons();for(int i=0;i&lt;list.size();i++)&#123; QPolygonF polygonF=list[i]; //p.drawPolygon(polygonF); //方法一 for(int j=1;j&lt;polygonF.size();j++)&#123; p.drawLine(polygonF.at(j-1),polygonF.at(j)); //可以获取到各个点 &#125;&#125;]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神奇的QPainter]]></title>
    <url>%2FQT%2F%E7%A5%9E%E5%A5%87%E7%9A%84qpainter%2F</url>
    <content type="text"><![CDATA[前沿很多很好看的控件，都不是通过样式表设定样式出现的，而是通过自绘控件或者QStyle或者代理，这几种方式，都会有QPainter的出现！对于一个widget，只能有一个激活的QPainter进行绘制，会打架的！设定有两种方式，一种是构造函数，一种是begin。 QT没有采用二维笛卡尔坐标，以屏幕左上角为原点，向右为X+，向下为Y+。可以使用setWindow实现， 一、API 函数名 意义 QPainter(); explicit QPainter(QPaintDevice *); 构造并且指定绘制的控件 QPaintDevice *device() const; 返回指定的控件 bool begin(QPaintDevice *); 在该控件绘制 bool end(); 结束绘制 bool isActive() const; 是否绘制 void initFrom(const QPaintDevice *device); 以device初始化pen font background const QFont &amp;font() const; 绘制字体时的字体 void setFont(const QFont &amp;f); 指定一个字体 void setPen(const QColor &amp;color); 几种设定画笔的方式 void setPen(const QPen &amp;pen); void setPen(Qt::PenStyle style); const QPen &amp;pen() const; void setBrush(const QBrush &amp;brush); 设定QBrush 用于指定填充颜色 void setBrush(Qt::BrushStyle style); 不需要时可以 setBrush(Qt::NoBrush) const QBrush &amp;brush() const; void setBackgroundMode(Qt::BGMode mode); 设定透明或者不透明模式 没用过 0_0 Qt::BGMode backgroundMode() const; QPoint brushOrigin() const; 用意不明 设定填充的起点 inline void setBrushOrigin(int x, int y); inline void setBrushOrigin(const QPoint &amp;); void setBrushOrigin(const QPointF &amp;); void setBackground(const QBrush &amp;bg); 设定背景色 const QBrush &amp;background() const; qreal opacity() const; 设定不透明度 void setOpacity(qreal opacity); QRegion clipRegion() const; 设定一个区域，只能在该区域绘图 QRegion可以用来求面积相交的部分 QPainterPath clipPath() const; void setClipRect(const QRectF &amp;, Qt::ClipOperation op = Qt::ReplaceClip); void setClipRect(const QRect &amp;, Qt::ClipOperation op = Qt::ReplaceClip); inline void setClipRect(int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip); void setClipRegion(const QRegion &amp;, Qt::ClipOperation op = Qt::ReplaceClip); void setClipPath(const QPainterPath &amp;path, Qt::ClipOperation op = Qt::ReplaceClip); void setClipping(bool enable); bool hasClipping() const; QRectF clipBoundingRect() const; void save(); 大有用处！保存和恢复pen brush 变换（rotate,translate,scale,shear） void restore();(World Coordinates)==&gt;(Window Coordinates)==&gt;(Device Coordinates) 世界坐标（逻辑坐标） 世界变换 窗口坐标 窗口视图变换 设备坐标 | || void setTransform(const QTransform &amp;transform, bool combine = false); | 修改世界变换 替换了setWorldMatrix || const QTransform &amp;transform() const; | || const QTransform &amp;deviceTransform() const; | || void resetTransform(); | || void setWorldTransform(const QTransform &amp;matrix, bool combine = false); | || const QTransform &amp;worldTransform() const; | || void scale(qreal sx, qreal sy); | 缩放 || void shear(qreal sh, qreal sv); | 剪切 || void rotate(qreal a); | 旋转 || void translate(const QPointF &amp;offset); | 平移 || inline void translate(const QPoint &amp;offset); | || inline void translate(qreal dx, qreal dy); | || QRect window() const; | 修改窗口绘图坐标 设定绘图区域范围是多少 如 0,0 100,100 右下角就是100，100 || void setWindow(const QRect &amp;window); | || inline void setWindow(int x, int y, int w, int h); | || QRect viewport() const; | 修改视图绘图坐标 设定绘图区域范围 如 0,0 100,100 那么只在这个矩形内画图，并且100，100这个点对应的范围是 window的右下角 || void setViewport(const QRect &amp;viewport); | || inline void setViewport(int x, int y, int w, int h); | || void setViewTransformEnabled(bool enable); | || bool viewTransformEnabled() const; | || void scale(qreal sx, qreal sy); | 缩放 || void shear(qreal sh, qreal sv); | 扭曲 || void rotate(qreal a); | 旋转 | QPainter内置的一些图形，如果有更多的需求，配合QPainterPath实现 函数名 意义 void strokePath(const QPainterPath &amp;path, const QPen &amp;pen); 绘制path的轮廓 void fillPath(const QPainterPath &amp;path, const QBrush &amp;brush); 绘制path的填充区域 void drawPath(const QPainterPath &amp;path); 绘制path drawPoint 画一个点 drawPoints 画几个点 drawLine 画一条线 drawLines 画几条线 drawRect 画一个矩形 drawRects 画几个矩形 drawEllipse 画正圆或者椭圆 drawPolyline 画多段线 drawPolygon 画多边形 drawConvexPolygon 画凸多边形 drawArc 画圆弧，参数只能传整数，若画90度，角度参数传90*16 drawPie 画饼图，参数只能传整数，若画90度，角度参数传90*16 drawChord 画弦图 drawRoundedRect 画圆角矩阵，百份比 drawRoundRect 画圆角矩阵，度数 drawPicture 画.pic图片 drawPixmap 画位图 若是QBitmap则是使用pen的颜色绘制 QPixmap则使用原图 drawPixmapFragments 同时绘制多个pixmax或者子图 带优化 drawImage 画QImage 二、简单使用1234567891011//实现父类虚函数void paintEvent(QPaintEvent *e)&#123; //一 QPainter painter(this); //二 QPainter painter; painter.begin(this); painter.end();&#125; 三、QT坐标转笛卡尔坐标（setWindow，setViewport）1234567891011因为QT的QPainter坐标是以左上角为原点，与迪卡尔坐标不一样，所以我当时做的操作是x=_x;y=(-_y)+height(); y轴先与x轴对称，然后平衡一个屏幕的高度，完成转换笛卡尔坐标操作 当然这也有好处，全部东西都由自己控制二、void setWindow(const QRect &amp;window);void setViewport(const QRect &amp;viewport);最近才发现这两个函数，这样解释一下，setWindow有四个参数x,y,w,h，前两个参数是设定图像左上角的坐标，右角坐标为 x+w,y+h 用这个函数可以直接实现笛卡尔坐标系（左下角为原点）setWindow(0,height(),width(),-height()); 这个意思体会体会setViewport 就是设定绘画的区域 目前没有找到哪里合适用 四、类中子控件绘制123456789101112131415161718192021子控件是QWidget的派生类： 在类中重写void paintEvent(QPaintEvent *e);进行相应的绘制就行子控件不是QWidget的派生类，但是想在类中绘制，可以使用拦截事件： QWidget *paintWidget=new QWidget(); paintWidget-&gt;installEventFilter(this); 接着重载事件过滤事件 bool eventFilter(QObject *o, QEvent *e)&#123; if(o==paintWidget)&#123; if(e-&gt;type()==QEvent::Paint)&#123; mPainterWidget(paintWidget); return true; &#125; &#125; return QWidget::eventFilter(o,e); &#125; void mPainterWidget(QWidget *w)&#123; QPainter painter(w); //draw somthing &#125; 五、画一个带角度的椭圆12345678910当初好奇，想画一个带角度的椭圆，发现图形画圆的drawEllipse 没有带角度的参数，只有一个外接矩形后面又发现QPainter自带一个角度旋转（顺时针） 舒服void translate(const QPointF &amp;offset);void rotate(qreal a);步骤：painter.translate(x,y); 因为角度旋转是以原点旋转，所以先将坐标点平移到椭圆中心painter.rotate(15); 旋转角度painter.drawEllipse(x-w/2,y-h/2,w,h);painter.resetTransform(); 恢复原来]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT布局个人总结]]></title>
    <url>%2FQT%2Fqt%E5%B8%83%E5%B1%80%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[很久很久以前，刚接触QT，发现UI拖控件真爽，做个计算器什么的，一下子就搭出来了！实现起来也很得心应手，后面做的界面越来越复杂后，特别是别人跟你提意见，需要修改的时候，绝望！打破布局各种不友好。开始使用代码布局，代码new控件，修改的时候也比较好修改，而且可以实现动态布局！感觉缺点就是样式表没有UI这么友好，实时体现。 一、布局类123456789101112QLayoutItem QLayout(和QObject) QBoxLayout QHBoxLayout 水平布局 QVBoxLayout 垂直布局 QGridLayout 栅栏布局 QFormLayout 表单布局 QGraphicsLayout QStackedLayout 堆布局 QSpacerItem 空白占位（UI上的弹簧） QWidgetItem QWidgetItemV2 为什么个人不喜欢用QGridLayout呢？因为QGridLayout很容易被控制改变实际比例，导致出现和预设的比例不同。排问题好麻烦，推荐在行或者列使用相同的控件时使用。（有可能是我太菜了，使用不来） QLayout 函数名 意义 QWidget *parentWidget() const; 返回布局依赖控件 void setContentsMargins(int left, int top, int right, int bottom); 布局的左上右下边距 void setContentsMargins(const QMargins &amp;margins); void getContentsMargins(int left, int top, int right, int bottom) const; QMargins contentsMargins() const; QRect contentsRect() const; void addWidget(QWidget *w); 添加控件 virtual void addItem(QLayoutItem *) = 0; void removeWidget(QWidget *w); 移除控件，不生效！下面会讲怎么从布局中去掉控件 void removeItem(QLayoutItem *); void setEnabled(bool); bool isEnabled() const; void setMargin(int); void setSpacing(int); virtual QLayoutItem *itemAt(int index) const = 0; virtual QLayoutItem *takeAt(int index) = 0; virtual int indexOf(QWidget *) const; virtual int count() const = 0; QBoxLayout 函数名 意义 void addSpacing(int size); 添加指定大小的占位 void addStretch(int stretch = 0); 添加指定比例的占位 void addSpacerItem(QSpacerItem *spacerItem); 添加一个弹簧 void addWidget(QWidget *, int stretch = 0, Qt::Alignment alignment = 0); 添加一个布局 void addLayout(QLayout *layout, int stretch = 0); 添加一个布局 void addStrut(int);//Limits the perpendicular dimension of the box (e.g. height if the box is LeftToRight) to a minimum of size. Other constraints may increase the limit. void addItem(QLayoutItem *) Q_DECL_OVERRIDE; 继承自QLayoutItem 纯虚函数还有对应的insert插入操作 void setSpacing(int spacing); 设定控件之间的距离 bool setStretchFactor(QWidget *w, int stretch); 更改该控件的比例 bool setStretchFactor(QLayout *l, int stretch); 更改该布局的比例 void setStretch(int index, int stretch); 更改第index项的比例 QGridLayout 函数名 意义 void setHorizontalSpacing(int spacing); 控件间距 int horizontalSpacing() const; void setVerticalSpacing(int spacing); int verticalSpacing() const; void setSpacing(int spacing); int spacing() const; void setRowStretch(int row, int stretch); 行列比例 void setColumnStretch(int column, int stretch); int rowStretch(int row) const; int columnStretch(int column) const; int columnCount() const; 行列数量 int rowCount() const; inline void addWidget(QWidget *w) { QLayout::addWidget(w); } 插入控件 void addWidget(QWidget *, int row, int column, Qt::Alignment = 0); void addWidget(QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0); void addLayout(QLayout *, int row, int column, Qt::Alignment = 0); void addLayout(QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0); QFormLayout没用过，类似一个QHBoxLayout，固定一个QLabel和一个等待插入的控件。 QGraphicsLayout没用过，给Graphics View使用。 QStackedLayout跟QStackedWidget一样，方式不一样，QStackedLayout是多个Layout QStackedWidget是多个Widget QSpacerItem弹簧 1234567QSpacerItem(int w, int h, QSizePolicy::Policy hData = QSizePolicy::Minimum, QSizePolicy::Policy vData = QSizePolicy::Minimum) : width(w), height(h), sizeP(hData, vData) &#123; &#125; void changeSize(int w, int h, QSizePolicy::Policy hData = QSizePolicy::Minimum, QSizePolicy::Policy vData = QSizePolicy::Minimum); QWidgetItem没用过 Normally, you don’t need to use this class directly. Qt’s built-in layout managers provide the following functions for manipulating widgets in layouts 二、布局遍历1234for(int i=0;i&lt;mlayout-&gt;count();i++)&#123; QLabel *lab=qobject_cast&lt;QLabel*&gt;(mlayout.itemAt(i)-&gt;widget()); qDebug()&lt;&lt;lab-&gt;text();&#125; 三、清除布局1234while(mlayout-&gt;count())&#123; mlayout-&gt;itemAt(0)-&gt;widget()-&gt;setParent(nullptr); //将父类设空既可 下面一句保留 //mlayout-&gt;removeWidget(mlayout-&gt;itemAt(0)-&gt;widget());&#125; 四、动态布局动态布局借用清除布局，将layout里面的widget全部清空，然后重新添加需要的widget，视觉上面可以看到是界面可以动态变换 123clearLayout(mlayout);mlayout-&gt;addWidget(subWidget1,1);mlayout-&gt;addwidget(subWidget2,2); 五、注意设置布局前，控件应该设定好大小策略，限定大小的变化 1234567891011 void QWidget::setSizePolicy(QSizePolicy::Policy hor, QSizePolicy::Policy ver);void setSizePolicy(QSizePolicy);enum Policy &#123; Fixed = 0, Minimum = GrowFlag, Maximum = ShrinkFlag, Preferred = GrowFlag | ShrinkFlag, MinimumExpanding = GrowFlag | ExpandFlag, Expanding = GrowFlag | ShrinkFlag | ExpandFlag, Ignored = ShrinkFlag | GrowFlag | IgnoreFlag &#125;;]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置文件与注册表]]></title>
    <url>%2FQT%2F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一、QSettings​ QT中，对.ini文件和注册表都是使用同一个类，就是QSettings类。使用简单，但是不知道是设置问题还是啥，会有点小问题，下面我会指出。 ​ API中介绍，创建QSettings时，必须需要指定公司或者组织、应用名称。注册表使用的，读取INI不需要设置。（you must pass the name of your company or organization as well as the name of your application.） 1QSettings settings("MySoft", "Star Runner"); 1）简单介绍 函数名 作用 QSettings(const QString &amp; fileName, Format format, QObject * parent = 0)； /FormatQSettings::NativeFormat 0 在windows平台，用于读取注册表，OSX和IOS 读CFPreferences，Unix读INIQSettings::IniFormat 1 Store the settings in INI files.QSettings::InvalidFormat 16 Special value returned by registerFormat(). / | 构造函数 || QStringList allKeys() const; | 返回所有的键 如group/key || void beginGroup(const QString &amp; prefix); | 直接读取prefix组 || void QSettings::endGroup();/settings.beginGroup(“mainwindow”);settings.setValue(“size”, win-&gt;size());settings.setValue(“fullScreen”, win-&gt;isFullScreen());settings.endGroup();settings.beginGroup(“outputpanel”);settings.setValue(“visible”, panel-&gt;isVisible());settings.endGroup(); / | 返回上一级 || QStringList QSettings::childGroups() const; | 返回所有的group || QStringList QSettings::childKeys() const; | 返回当前级别的key || bool QSettings::contains(const QString &amp; key) const; | 是否包含key || void QSettings::remove(const QString &amp; key); | 删除本项及子项 || void QSettings::setIniCodec(QTextCodec codec); | 设置编码 || void QSettings::setIniCodec(const char codecName); | || [static] void QSettings::setPath(Format format, Scope scope, const QString &amp; path);QSettings::UserScope 0 特定用户范围.QSettings::SystemScope 1 本机所有用户. | 设置文件路径 || void QSettings::setValue(const QString &amp; key, const QVariant &amp; value); | 写入值 || QVariant QSettings::value(const QString &amp; key, const QVariant &amp; defaultValue = QVariant()) const; | 取值 | 2）读写配置文件12345QSetting qset("./my.ini"，QSettings::IniFormat);qset.setValue("group/key","nice");qDebug()&lt;&lt;qset.value("group/key"); //可以取到nice//对于中文utf8的文档 需要增加一句qset.setIniCodec("UTF8"); //GBK UNICODE GB2312 3）读写注册表12345QSetting REGRead("MySoft", "Star Runner"); //会在注册表中建了一个MySoft，底下会有个Star Runner的文件夹 下面的操作会在 Star Runner中进行//写REGRead.setValue("",""); //读REGRead.value(""); 二、API1）读写配置文件12345678910111213141516171819202122232425262728293031323334//读写系统配置文件GetProfileInt(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);GetProfileString(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize);WriteProfileString(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString);GetProfileSection(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize);WriteProfileSection(LPCWSTR lpAppName, LPCWSTR lpString);//读写自定义配置文件GetPrivateProfileInt(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);GetPrivateProfileString(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);WritePrivateProfileString(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);GetPrivateProfileSection(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);WritePrivateProfileSection(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName);GetPrivateProfileSectionNames(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);GetPrivateProfileStruct(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);WritePrivateProfileStruct(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);//例子//写WritePrivateProfileString( reinterpret_cast&lt;const wchar_t *&gt;(group.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(key.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(error.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(filepath.utf16()));//读wchar_t buf[64];GetPrivateProfileString( reinterpret_cast&lt;const wchar_t *&gt;(group.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(key.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(error.utf16()), buf,sizeof(buf)-1, reinterpret_cast&lt;const wchar_t *&gt;(filepath.utf16()));QString::fromWCharArray(buf); 2）读写注册表​ 只捉几个介绍！ 12345678910111213141516171819202122232425RegCreateKeyEx(HKEY hKey,LPCWSTR lpSubKey,DWORD Reserved,LPWSTR lpClass,DWORD dwOptions,REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,PHKEY phkResult,LPDWORD lpdwDisposition);RegCreateKey(HKEY hKey,LPCWSTR lpSubKey,PHKEY phkResult);/*创建键值*/RegDeleteKeyEx(HKEY hKey,LPCWSTR lpSubKey,REGSAM samDesired,DWORD Reserved);RegDeleteKey(HKEY hKey,LPCWSTR lpSubKey);/*删除键值*/RegOpenKeyEx(HKEY hKey,LPCWSTR lpSubKey,DWORD ulOptions,REGSAM samDesired,PHKEY phkResult);RegOpenKey(HKEY hKey,LPCWSTR lpSubKey,PHKEY phkResult);/*打开键值*/RegQueryValueEx(HKEY hKey,LPCWSTR lpValueName,LPDWORD lpReserved,LPDWORD lpType,LPBYTE lpData,LPDWORD lpcbData);RegQueryValue(HKEY hKey,LPCWSTR lpSubKey,LPWSTR lpData,PLONG lpcbData);/*获取键值*/RegSetValueEx(HKEY hKey,LPCWSTR lpValueName,DWORD Reserved,DWORD dwType,CONST BYTE *lpData,DWORD cbData);RegSetValue(HKEY hKey,LPCWSTR lpSubKey,DWORD dwType,LPCWSTR lpData,DWORD cbData);/*修改键值*/]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QString与QStringList]]></title>
    <url>%2FQT%2Fqstring%E4%B8%8Eqstringlist%2F</url>
    <content type="text"><![CDATA[对于我而言，这两者用的频率真的非常高了。 一、QString​ 根据api顺序，把自己现在的经验写下来。 函数名 意义 QString &amp; append(const QString &amp; str); 追加一个串到尾部，有多个重载 QString arg(const QString &amp; a, int fieldWidth = 0, QChar fillChar = QLatin1Char( ‘ ‘ )) const; 使用a替换%1 最少占用fieldWidth字符，不足用fillChar替换 fieldWidth为正，右对齐。反之，左对齐 QString QString::arg(const QString &amp; a1, const QString &amp; a2) const; QString str;str = “%1 %2”;str.arg(“%1f”, “Hello”); // returns “%1f Hello”str.arg(“%1f”).arg(“Hello”); // returns “Hellof %2” | || int QString::compare(const QString &amp; s1, const QString &amp; s2, Qt::CaseSensitivity cs = Qt::CaseSensitive); int x = QString::compare(“aUtO”, “AuTo”, Qt::CaseInsensitive); // x == 0int y = QString::compare(“auto”, “Car”, Qt::CaseSensitive); // y &gt; 0int z = QString::compare(“auto”, “Car”, Qt::CaseInsensitive); // z &lt; 0 | 比较两个串 || bool QString::contains(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; QString str = “Peter Pan”;str.contains(“peter”, Qt::CaseInsensitive); // returns true | 是否包含str || int QString::count(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; | 包含str多少次 || QChar QString::data(); | 将QString转成QChar字符串 || bool QString::startsWith(const QString &amp; s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; | 是否以s开始 || bool QString::endsWith(const QString &amp; s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; | 是否以s结束 || QString &amp; QString::fill(QChar ch, int size = -1); | 使用连续size个ch填充 || [static] QString QString::fromLatin1(const char str, int size = -1); | 从char 转入 || [static] QString QString::fromLocal8Bit(const char str, int size = -1); | 从8字节长度char 转入 || [static] QString QString::fromRawData(const QChar unicode, int size); | 从unicode转入 || [static] QString QString::fromStdString(const std::string &amp; str); | 从标准string转入 || [static] QString QString::fromStdU16String(const std::u16string &amp; str); | 从标准16字长的string转入 || [static] QString QString::fromStdWString(const std::wstring &amp; str); | 从标准宽字节转入 || [static] QString QString::fromUtf8(const char str, int size = -1); | 从utf8字串转入 || [static] QString QString::fromUtf16(const ushort unicode, int size = -1); | 从unicode字串转入 || [static] QString QString::fromWCharArray(const wchar_t * string, int size = -1); | 从宽字串转入 || int QString::indexOf(const QString &amp; str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; | 从from位置开始 str出现的位置 没有返回-1 || QString &amp; QString::insert(int position, const QString &amp; str); | 从position位置插入str || bool QString::isEmpty() const; QString().isEmpty(); // returns trueQString(“”).isEmpty(); // returns trueQString(“x”).isEmpty(); // returns falseQString(“abc”).isEmpty(); // returns false | || bool QString::isNull() const; QString().isNull(); // returns trueQString(“”).isNull(); // returns falseQString(“abc”).isNull(); // returns false | || QString QString::left(int n) const; | 保留左边起n个 || QString QString::right(int n) const; | 保留右边起n个 || QString QString::mid(int position, int n = -1) const; | 保留position位置起，连续n个 || [static] QString QString::number(long n, int base = 10); | 将n转成串 || | || QString &amp; QString::prepend(const QString &amp; str); QString x = “ship”;QString y = “air”;x.prepend(y);// x == “airship” | 将str做为前缀 || QString &amp; QString::remove(int position, int n); | 从Position删除连续n个 || QString QString::repeated(int times) const; | 串重复times次 || QString &amp; QString::replace(int position, int n, const QString &amp; after);//不止下面两种QString x = “Say yes!”;QString y = “no”;x.replace(4, 3, y);// x == “Say no!”或者QString str = “colour behaviour flavour neighbour”;str.replace(QString(“ou”), QString(“o”));// str == “color behavior flavor neighbor” | || QString QString::section(QChar sep, int start, int end = -1, SectionFlags flags = SectionDefault) const;QString str;QString csv = “forename,middlename,surname,phone”;QString path = “/usr/local/bin/myapp”; // First field is emptyQString::SectionFlag flag = QString::SectionSkipEmpty;str = csv.section(‘,’, 2, 2); // str == “surname”str = path.section(‘/‘, 3, 4); // str == “bin/myapp”str = path.section(‘/‘, 3, 3, flag); // str == “myapp” | 以sep切开，也可以以串切开 || QString QString::simplified() const;QString str = “ lots\t of\nwhitespace\r\n “;str = str.simplified();// str == “lots of whitespace”; | 去除整串的占位符 || QStringList QString::split(const QString &amp; sep, SplitBehavior behavior = KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;SplitBehavior:QString::KeepEmptyParts 0 If a field is empty, keep it in the result.QString::SkipEmptyParts 1 If a field is empty, don’t include it in the result.str = “This time, a normal English sentence.”;list = str.split(QRegExp(“\W+”), QString::SkipEmptyParts);// list: [ “This”, “time”, “a”, “normal”, “English”, “sentence” ] | 切割 || QByteArray QString::toLatin1() const; | || QByteArray QString::toLocal8Bit() const; | || std::string QString::toStdString() const | || QString QString::toLower() const; | 转成小写 || QString QString::toUpper() const; | 转成大写 || QString QString::trimmed() const; | 去掉首尾占位 || void QString::truncate(int position);QString str = “Vladivostok”;str.truncate(4);// str == “Vlad” | 与left有点类似 保留前position个 || const QChar QString::unicode() const; | 字面意思 || const ushort QString::utf16() const; | | 12345678910111213[static] QString QString::number(double n, char format = 'g', int precision = 6);/*format:e format as [-]9.9e[+|-]999E format as [-]9.9E[+|-]999f format as [-]9.9g use e or f format, whichever is the most conciseG use E or f format, whichever is the most conciselong a = 63;QString s = QString::number(a, 16); // s == "3f"QString t = QString::number(a, 16).toUpper(); // t == "3F"*/ 12345678QString与string的转换，经实验，string与QString使用API互相转换，中文会乱码string2QString&#123; qstr=QString::fromLocal8Bit(str.data());&#125;QString2string&#123; str=string(qstr.toLocal8Bit());&#125; 二、QStringList​ 其实就是QString的数组 函数名 意义 bool QStringList::contains(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; 是否包含str QStringList QStringList::filter(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; QStringList list;list &lt;&lt; “Bill Murray” &lt;&lt; “John Doe” &lt;&lt; “Bill Clinton”;QStringList result;result = list.filter(“Bill”);// result: [“Bill Murray”, “Bill Clinton”] | 过虑出包含str的串 || int QStringList::indexOf(const QRegExp &amp; rx, int from = 0) const; | 匹配 || QStringList &amp; QStringList::replaceInStrings(const QString &amp; before, const QString &amp; after, Qt::CaseSensitivity cs = Qt::CaseSensitive);QStringList list;list &lt;&lt; “alpha” &lt;&lt; “beta” &lt;&lt; “gamma” &lt;&lt; “epsilon”;list.replaceInStrings(“a”, “o”);// list == [“olpho”, “beto”, “gommo”, “epsilon”] | 替换 || void QStringList::sort(Qt::CaseSensitivity cs = Qt::CaseSensitive); | 排序 |]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包罗万象的QVariant]]></title>
    <url>%2FQT%2F%E5%8C%85%E7%BD%97%E4%B8%87%E8%B1%A1%E7%9A%84qvariant%2F</url>
    <content type="text"><![CDATA[一、概念该类常用于数据库中！类似联合数据类型。 它可以包含QT中各种数据类型，包括一些类。摘抄自QT5.5的文档 二、使用1234567891011121314QVariant QVariant::fromValue(const T &amp; value); //会返回一个QVariant 否则与setValue一样void QVariant::setValue(const T &amp; value);//设定一个值T QVariant::value() const;//返回一个值bool QVariant::canConvert(int targetTypeId) const； //如果支持该类型，返回真bool QVariant::convert(int targetTypeId); //将该类型转成targetTypeId 如果不支持，类型会变，而且值会变成0//其中T为一所介绍的类型//例子QVariant qvar;qvar.setValue("bugnull.com");qDebug()&lt;&lt;qvar.toString();qDebug()&lt;&lt;QVariant::fromValue("bugnull.cn");qDebug()&lt;&lt;qvar.value&lt;QString&gt;();qDebug()&lt;&lt;qvar.canConvert&lt;QString&gt;();qDebug()&lt;&lt;qvar.convert&lt;QString&gt;();]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT添加外部库]]></title>
    <url>%2FQT%2Fqt%E6%B7%BB%E5%8A%A0%E5%A4%96%E9%83%A8%E5%BA%93%2F</url>
    <content type="text"><![CDATA[QT的库虽然已经非常的多，但是还是还是满足不了需求。如音视频库FFMpeg和图纸解析dxflib opendwg等。。。。省略一万字。 一、PRO文件修改​ 增加 123INCLUDEPATH+= 头文件目录LIBS += -L（.lib或者.a的目录） -l（.lib或者.a的名字 不带后缀）#推荐使用 $$PWD/ 表示pro文件当前路径 路径带空格了，可以使用""包括，但是不要把PWD/也包在内！ 常规操作，如果特别的库，看介绍吧。下课！！]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT库使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLibrary使用动态库]]></title>
    <url>%2FQT%2Fqlibrary%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[我使用这种方法一般是因为没有.h .a(.lib)文件的支持下，只能使用QLibrary进行手动提取。 一、常用函数12345bool load()；//加载 需要指定了文件名，跟文件的open一样bool unload()；//卸载void setFileName(const QString &amp; fileName)； //设置库名QFunctionPointer resolve(const char * symbol)； //函数名QString errorString() const； //错误信息 二、使用例子1234567891011121314显示调用QLibrary myLib("mylib");typedef void (*MyPrototype)();MyPrototype myFunction = (MyPrototype) myLib.resolve("mysymbol");if (myFunction) myFunction();隐式调用typedef void (*MyPrototype)();MyPrototype myFunction = (MyPrototype) QLibrary::resolve("mylib", "mysymbol");if (myFunction) myFunction();//上面typedef void (*fun)()为指定一个指针fun为指向反回值为void没有参数的函数指针 三、加载类​ 如果调用函数方法，可以通过上面去加载！类呢？类是由编译期就完成的了！无法实时去索引。经搜索，还真发现了可以完成的例子。 ​ 他利用虚表的特性，在运行时可以动态索引。使用一个接口类，对外进行公开，添加创建对象函数，返回类型为接口类型。 12345678910111213141516171819202122232425262728293031class TestInterface&#123;public: virtual ~TestInterface() &#123; &#125; virtual int getValues() = 0;&#125;class TESTDLL_LIBSHARED_EXPORT TestDLL_lib : public TestInterface&#123;public: TestDLL_lib(); virtual ~TestDLL_lib(); int a; int b; int c; int getValues() override; // MSVC may not support "override"&#125;; // return pointer to interface!// TestDLL_lib can and should be completely hidden from the applicationextern "C" TESTDLL_LIBSHARED_EXPORT TestInterface *create_TestDLL_lib()&#123; return new TestDLL_lib();&#125;//https://stackoverflow.com/questions/26234327/qlibrary-import-a-class]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[extern "C"与_cplusplus]]></title>
    <url>%2FC%2Fextern-c-%E4%B8%8E-cplusplus%2F</url>
    <content type="text"><![CDATA[一、extern”C”​ 百度百科讲得很清楚 ，就是说，c++编译器虽然支持c，但是由于函数重载的存在，编译的时候会把参数也加到编译中，而c却不支持。所以使用该符号，表明使用c的方式去编译这些文件。 extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 二、extern​ extern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义，另外，extern也可用来进行链接指定。我觉得它是个导出声明符号，达到代码段共享的作用。 ​ 当时我有点不明白，它和static静态全局有什么区别？extern是真全局变量，可以在多个地方进行extern int a这样的声明，仅仅是声明，只可以在一个地方进行定义。只要声明了之后，就可以共享这个变量a。而static为只申请一次，然后一直存在，作用域内的地方可以一直使用它，而且值也不变，不会跟函数结束而被释放。同名会被作用域小的替代。 三、_cplusplus​ 它是个宏定义，表明当前是c++环境。结合使用，效果更佳 12345678&gt; #ifdef __cplusplus /* 如果采用了C++，如下代码使用C编译器 */&gt; extern &quot;C&quot;&#123;/* 如果没有采用C++，顺序预编译 */&gt; #endif&gt; /* 采用C编译器编译的C语言代码段 */&gt; #ifdef __cplusplus /* 结束使用C编译器 */&gt; &#125;&gt; #endif&gt;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Cpp基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT静态库与使用]]></title>
    <url>%2FQT%2Fqt%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用静态库解决了我之前的共享库那篇文章下面那个问题！ 一、新建工程1. 新建Library\C++工程 2.选择静态链接库，设定路径 3.选择对应的模块，也可以在pro里面增加 二、工程介绍1.本工程没有main函数，可以归类为库。2.pro文件介绍需要debug版本的，手动增加，多了一条CONFIG+=staticlib 这里得知，告知编译器将编译出静态库 12345CONFIG+=debug_and_releaseCONFIG(debug,debug|release)&#123; unix:TARGET=$$join(TARGET,,,_debug) else:TARGET=$$join(TARGET,,,d)&#125; 3.主类或函数​ 可以看出，该类与普通类定义完全一样 5.编译完成​ 在windows平台下，会成生一个.a文件（我使用的是Mingw5.5.1，MSVC会生成.lib） 三、库的使用1.新建一个Application项目​ 右击工程，弹出，添加库，选择.a文件，设置见下图2 2. pro文件会发生变化​ INCLUDEPATH表示头文件的路径 ​ DEPENDPATH表示编译时依赖文件的路径 ​ 最好把 .h .a 放到与该工程下（该方法直接发布exe即可） 3.使用​ 包含.h头文件即可以正常使用函数或者类。]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT库使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多域名指向GithubPage]]></title>
    <url>%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%2F%E5%A4%9A%E5%9F%9F%E5%90%8D%E6%8C%87%E5%90%91githubpage%2F</url>
    <content type="text"><![CDATA[域名1 bugnull.com 域名2 bugnull.cn 一、购买域名​ 如果没有域名都是白瞎！！这两个域名都是通过阿里云购买的，加起来80多块一年。淘到两个好域名，开心。 二、访问*.github.io​ 确保自己的 *.github.io可以访问。 1. 设置第一个域名​ 打开github的仓库，选择自己的github.io，点击设置，拉到下面的GithubPage，修改下面为下图2，因为Github更新的比较快，大家看情况设置。 2.域名解析​ 在Github仓库上，增加一个CNAME的文件，里面的内容为，例如我的，就填bugnull.com，仅此而已，连www也不需要，正是因为CNAME只支持一个域名，所以才有我东找西找的结果。 ​ 添加CNAME和A分别对应github.io和 github.io对应的ip地址 ​ 如果不知道对应的ip地址 使用cmd ping一下就可以看到了 ​ 如果准备做多个域名，在这里，顺便把其它的域名也加上A字段，填上个IP即可 3.第一个域名设置完成​ 此时等个几分钟，就可以使用第一个域名访问了 4.设置第二个或者更多个域名​ 写本文的目的从这里才开始，因为前面那几个网上多的是！ ​ 原理，Github上面每一个仓库都可以设置一个域名！利用这个特性，进行域名转跳！ 5.创建一个新的仓库​ 因为一个帐号只能有一个github.io仓库，所以这个仓库随便建，同样新建的仓库，设置。 6.添加文件​ 在新建的仓库新加404.html里面的内容为，你们的域名填写主域名！ ​ 再新建一个CNAME文件，里面的内容为你的副域名。到这里就设置完了，原理是GithubPage的仓库可独立域名和利用404报错页面进行转跳的。有点神奇吧！ 三、大概流程​ 在GithubPage上，设置域名，仓库上增加CNAME，云解析填上对应的解析。 ​ 多域名，利用404转跳，和Github仓库的强大作用。]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT共享库与使用]]></title>
    <url>%2FQT%2Fqt%E5%85%B1%E4%BA%AB%E5%BA%93%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[之前因为一些原因，需要将一些widget派生类封装成dll，给其它项目使用。研究了一下，首先，该widget派生类需要与使用类尽量没有关联。（当明有一个共用类，保存各种全局变量，里面有一个变量，与语言选择相关的，共享类也包含了该头文件，可是并没有获取到全局变量的值） 一、新建工程1. 新建Library\C++工程 2.选择共享库，设定路径 3.选择对应的模块，也可以在pro里面增加 二、工程介绍1.本工程没有main函数，可以归类为库。2.pro文件介绍​ 需要debug版本的，手动增加 12345CONFIG+=debug_and_releaseCONFIG(debug,debug|release)&#123; unix:TARGET=$$join(TARGET,,,_debug) else:TARGET=$$join(TARGET,,,d)&#125; 3.*_global.h介绍​ 下图1为_global.h的内容，下图2为实际Q_DECL_EXPORT和Q_DECL_IMPORT**的宏定义 4.主类或函数​ 定义前加上PUBLICSHARED_EXPORT即可，然后做自己想做的控件。 1234567PUBLICSHARED_EXPORT int max(int x,int y); //尽量不要使用这些c++或者qt库中带有的函数名，万不得已经在使用前加:表明命名空间类定义class PUBLICSHARED_EXPORT Public&#123;public: Public();&#125;; 5.编译完成​ 在windows平台下，会成生一个.a文件和一个.dll（我使用的是Mingw5.5.1，MSVC会生成.lib和.dll） 三、库的使用1.新建一个Application项目​ 右击工程，添加库，选择内部库，在库文件中选择.a或者.lib。看图说话- - 2. pro文件会发生变化​ INCLUDEPATH表示头文件的路径 ​ DEPENDPATH表示编译时依赖文件的路径 ​ 最好把 .h *_global.h .a .dll 放到与该工程下（该方法发布的时候需要把dll一起发布） ​ 3.使用​ 包含.h头文件即可以正常使用函数或者类。 4.注意​ 有一个全局变量Language表示当前界面显示的语言，由程序开启后第一时间读取配置文件，供全局使用。使用了上面的方法，生成共享库的时候在头文件也包含了该类。结果在使用的时候经调试发现，两者的Language为两个互不关联的变量。即数据不共享，通过信号槽或者函数调用可以达到共享。]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT库使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT工程编译流程]]></title>
    <url>%2FQT%2Fqt%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本章为简单介绍，qmake里面有大学问。 一、qmale 第一步是运行qmake，根据当前的项目工程，生成pro，然后运行qmake生成MakeFile文件（有时候，增加资源文件或者删除后，运行会警告缺失文件，执行一次qmake即可） 命令 qmake project.pro 生成pro 然后 qmake 生成MakeFile 二、构建 构建我理解为是编译，第二次执行只编译变化了的部分，一个一个生成.o和目标文件，最终生成exe 命令 mingw32-make、moc、uic、rcc moc.exe -o mclass.h moc_mclass.cpp 编译继承qt的类 uic.exe -o mclass.ui ui_mclass.h 将ui编译生成类 rcc.exe -o -no-compress my.qrc my.cpp 编译资源文件 重新构建 将所有部分重新编译 三、清除 只留下exe，其它文件都删掉(MakeFile会留下) 四、运行 根据已经存在的MakeFile进行编译，然后打开exe，如果MakeFile不存在才会重新执行qmake。（估计是这样才会导致我之前说的那个问题） （之前查了一下资料，发现QT Create运行程序和在资源管理器上双击打开程序的区别。QT Create上运行使用的库是当前设置好，准备编译该工程的库。而双击运行会去环境变量中找，导致两者使用的库不一致，所以有可能其中一方运行不起来而另外一方可以运行。）]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集与字符编码]]></title>
    <url>%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[主要是总结，资料来源是网络，底部会把链接挂上。 一、名词解释 字符集 ：字符编码就是一个系统支持的所有抽象字符的集合，字符是各种文字和符号的总称。 字符编码 ：将符号转换为计算机可以接受的数字系统的规则，是符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。 编码 ：按照某种字符编码将字符存储在计算机中 解码 ：将存储在计算机中的二进制数解析出来 二、编码集 ASCII 美国最早推出，由一个字节表示，共128个，编码范围是0-127 ISO 由西欧国家对ASCII的扩展，增加到256个字符，ISO8859 GB2312 中国推出，完整保留ASCII，兼容约7000简体字、数学符号、罗马希腊字母、日本假名等。小于127的字符与ASCII对应，两个大于127的结合起来表示一个汉字。高位在0xA1到0xF7，低位在0xA1到0xFE，其中更包括ASCII就有的字符，但是这里为“全角”，小于127的称为“半角”。该编码称为GB2312 。 GBK 当时GB2312这并没有包括完整的中文，简体都没包括完整，繁体就更别说了。在这个前提下出现GBK 编码，把低位的0xA1不从0开始，这里就将繁体等字符加进来了，范围为0x8140至0xFEFE。向下与 GB 2312 编码兼容，向上支持 ISO，与 Unicode 组织的 Unicode 编码完全兼容。GB13000等同于ISO10646 GB18030 兼容GB2312，基本兼容GBK，支持GB13000及Unicode的全部统一汉字。编码与utf8相同，采用可变长度的编码，GB18030-2000为强制要求支持的版本，GB18030-2005为增加多种少数民族文字编码。 三、Unicode编码集与UTF8、UTF16、UTF32​ 单独总结Unicode，表示该编码的重要性。在计算机领域中，Unicode编码是业界的一种标准。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 ​ Unicode是字符集，UTF32、UTF16、UTF8是三种字符编码方案 。 Unicode字符集可以简写为UCS（Unicode Character Set），0x0000~0X00ff与ISO 8859-1保持一致 Unicode可以逻辑分为17平面（Plane），每个平面拥有65536（ 共1114112）个代码点，虽然目前只有少数平面被使用。 平面0 (0000–FFFF): 基本多文种平面（Basic Multilingual Plane, BMP）. 平面1 (10000–1FFFF): 多文种补充平面（SupplementaryMultilingual Plane, SMP）. 平面2 (20000–2FFFF): 表意文字补充平面（SupplementaryIdeographic Plane, SIP）. 平面3 (30000–3FFFF): 表意文字第三平面（TertiaryIdeographic Plane, TIP）. 平面4 to 13 (40000–DFFFF)尚未使用 平面14 (E0000–EFFFF): 特别用途补充平面（SupplementarySpecial-purpose Plane, SSP） 平面15 (F0000–FFFFF)保留作为私人使用区（PrivateUse Area, PUA） 平面16 (100000–10FFFF)，保留作为私人使用区（PrivateUse Area, PUA） 原文：https://blog.csdn.net/harrywater123/article/details/50738079 UTF8 是一种针对Unicode的可变长度字符编码，又称万国码， 用1到6个字节编码Unicode字符。 规则：如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的字节数，其余各字节均以10开头。 1.第一种是一个字节的编码：即128个ascii字符（只需要一个字节） 格式：0xxxxxxx 2^7 - 1 = 127 = 7F = (0111-1111) 编码方式Unicoe范围由(U+0000 至 U+007F) 2.第二种是两个字节的编码：即带有符号的拉丁文，希腊文，西里尔字母，亚美尼亚语，希伯来文，阿拉伯文等，则需要两个字节编码(Unicode 范围由U+0080至U+07FF) 格式：110xxxxx 10xxxxxx (0080)16 = (128)10 (07FF) 16 = (2047)10 = 2^11-1; 3.第三种是三字节的编码，即其他多文种平面(BMP)中的字符（这包括了大部分的汉字）（范围为: U+0800 至 U+FFFF） 格式：1110xxxx 10xxxxxx 10xxxxxx U+0800 = 2048； U+FFFF = 65535 = 2^16 -1； 1110xxxx 10xxxxxx 10xxxxxx 4.第四种是4-6字节编码。 U+1 0000至U+1 FFFFF：使用四字节 U+20 0000 至U+3FF FFFF：使用五字节 U+400 0000至U+7FFF FFFF UTF-8就是以8位为单元对UCS进行编码。从UCS-2到UTF-8的编码方式如下： UCS-2编码(16进制) 范围 UTF-8 字节流(二进制) 0000 - 007F 0 - 127 0xxxxxxx 0080 - 07FF 128-2047 110xxxxx 10xxxxxx 0800 - FFFF 2048-65535 1110xxxx 10xxxxxx 10xxxxxx 例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 目前计算机一般使用 2 个字节（16 位）来存放一个序号（DBCS,DoubleByte Character System），因此，这种方式存放的字符也被称作宽字节字符。比如，字符串”中文123” 在 Windows2000 下，内存中实际存放的是 5 个字符，一共10个字节；若在gb2312编码中，共计五个字符，7个字节。 原文：https://blog.csdn.net/harrywater123/article/details/50738079 优点，可变长度编码，对于常用的ASCII字符，只需要用一位编码即可，多字节的字符使用频率很低，节省了存储空间。 缺点，无法判断UTF8的字节数，较多 10xxxxxx 网络传输会产生错误。 UTF16 将0–65535范围内的字符编码成2个字节，空间利用率比UTF32高两倍 如果字符编码U小于0x10000，也就是十进制的0到65535之内，则直接使用两字节表示； 如果字符编码U大于0x10000，由于UNICODE编码范围最大为0x10FFFF，从0x10000到0x10FFFF之间 共有0xFFFFF个编码，也就是需要20个bit就可以标示这些编码。用U’表示从0-0xFFFFF之间的值，将其前 10 bit作为高位和16 bit的数值0xD800进行 逻辑or 操作，将后10 bit作为低位和0xDC00做 逻辑or 操作，这样组成的 4个byte就构成了U的编码。 UTF32 使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。可以在常数时间内定位字符。 四、BOM​ Unicode编码标准中用于标识文件是采用哪种格式的编码。 ​ BOM —— Byte Order Mark，中文名译作“字节顺序标记” ​ UTF8不需要表明字节顺序，但是可以用BOM来表明编码方式。字符 “Zero Width No-Break Space” 的 UTF-8 编码是 EF BB BF。所以如果接收者收到以 EF BB BF 开头的字节流，就知道这是 UTF-8编码了。Windows 就是使用 BOM 来标记文本文件的编码方式的。 ​ 在保存一个以编utf8码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。在保存一个以utf8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。 编码 表示 (十六进制) 表示 (十进制) utf8 EF BB BF 239 187 191 utf16 大端 FE FF 254 255 utf16 小端 FF FE 255 254 utf32 大端 00 00 FE FF 0 0 254 255 utf32 小端 FF FE 00 00 255 254 0 0 iso8859-1 ​ 最早的编码是iso8859-1，和ascii编码相似。但为了方便表示各种各样的语言，逐渐出现了很多编码。iso8859-1属于单字节编码，最多能表示的字符范围是0-255，应用于英文系列。比如，字母a的编码为0x61=97。很明显，iso8859-1表示的字符范围很窄，无法表示中文字符。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用iso8859-1编码来表示。而且在很多协议上，默认使用该编码。比如，虽然”中文”两个字不存在iso8859-1编码，以gb2312编码为例，应该是”d6d0 cec4”两个字符，使用iso8859-1编码的时候则将它拆开为4个字节来表示：”d6 d0 ce c4”（事实上，在进行存储的时候，也是以字节为单位处理的）。而如果是UTF编码，则是6个字节”e4 b8 ad e6 96 87”。很明显，这种表示还需要以另一种编码为基础。 汉字编码: * GB2312字集是简体字集，全称为GB2312(80)字集，共包括国标简体汉字6763个。 * BIG5字集是台湾繁体字集，共包括国标繁体汉字13053个。 * GBK字集是简繁字集，包括了GB字集、BIG5字集和一些符号，共包括21003个字符。 * GB18030是国家制定的一个强制性大字集标准，全称为GB18030-2000，它的推出使汉字集有了一个“大一统”的标准。 UCS:通用字符集(Universal Character Set，UCS)是由ISO制定的ISO 10646(或称ISO/IEC 10646)标准所定义的字符编码方式，采用4字节编码。UCS包含了已知语言的所有字符。除了拉丁语、希腊语、斯拉夫语、希伯来语、阿拉伯语、亚美尼亚语、格鲁吉亚语，还包括中文、日文、韩文这样的象形文字，UCS还包括大量的图形、印刷、数学、科学符号。​ * UCS-2: 与unicode的2byte编码基本一样。​ * UCS-4: 4byte编码, 目前是在UCS-2前加上2个全零的byte。 MIME： 通用因特网邮件扩充协议，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。 因为在因特网上邮件发送协议SMTP存在几个缺点，主要是不能发送可执行文件和其他的二进制文件，只限于传送7位的ASCII码，因此MIME协议起初用于解决该问题，即是在传送二进制数据时先通过MIME转换成SMTP可传送的ACSII码，接收时再通过MIME还原成原始的二进制码。为此SMTP也响应增加了MIME-version、content-type等5个新的首部。 其中首部Content-transfer-encoding的值有5种—-“7bit”、”8bit”、”binary”、”quoted-printable”和”base64”—-其中”7bit”是缺省值，即不用转化的ASCII字符。真正常用是“quoted-printable”和”base64”两种，用以指明编码转换的方式。 MIME_type类型语法： media-type=type/subtype​ 媒体类型(type)与子类型(subtype)组成了MIME，它们之间使用反斜杠/分割，其中type可取值为：application audio example image message model multipart text video，subtype是某种类型的唯一标识符，比如：css gif xml等。常见的MIME类型： 超文本标记语言文本 .html,.html text/html普通文本 .txt text/plainRTF文本 .rtf application/rtfGIF图形 .gif image/gifJPEG图形 .ipeg,.jpg image/jpegau声音文件 .au audio/basicMIDI音乐文件 mid,.midi audio/midi,audio/x-midiRealAudio音乐文件 .ra,.ram audio/x-pn-realaudioMPEG文件 .mpg,.mpeg video/mpegAVI文件 .avi video/x-msvideoGZIP文件 .gz application/x-gzipTAR文件 .tar application/x-tar quoted-printable： 主要用于ACSII文本中夹杂少量非ASCII码字符的情况，不适合于转换纯二进制文件。它规定将每一个8位的字节，转换为3个字符。第一个字符是”=”号，这是固定不变的。 后面二个字符是二个十六进制数，分别代表了这个字节前四位和后四位的数值。举例来说，ASCII码中”换页键”（form feed）是12，二进制形式是00001100，写成十六进制就是0C，因此它的编码值为”=0C”。”=”号的ASCII值是61，二进制形式是00111101，因为它的编码值是”=3D”。除了可打印的ASCII码以外，所有其他字符都必须用这种方式进行转换。 所有可打印的ASCII码字符（十进制值从33到126）都保持原样不变，”=”（十进制值61）除外。 base64： ​ 所谓Base64，就是说选出64个字符—-小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“（再加上作为垫字的”=”，实际上是65个字符）—-作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。具体来说，转换方式可以分为四步： 第一步，将每三个字节作为一组，一共是24个二进制位。 第二步，将这24个二进制位分为四组，每个组有6个二进制位。 第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节。 第四步，根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值。 如果字节数不足三，则这样处理： a）二个字节的情况：将这二个字节的一共16个二进制位，按照上面的规则，转成三组，最后一组除了前面加两个0以外，后面也要加两个0。这样得到一个三位的Base64编码，再在末尾补上一个”=”号。比如，”Ma”这个字符串是两个字节，可以转化成三组00010011、00010110、00010000以后，对应Base64值分别为T、W、E，再补上一个”=”号，因此”Ma”的Base64编码就是TWE=。 b）一个字节的情况：将这一个字节的8个二进制位，按照上面的规则转成二组，最后一组除了前面加二个0以外，后面再加4个0。这样得到一个二位的Base64编码，再在末尾补上两个”=”号。比如，”M”这个字母是一个字节，可以转化为二组00010011、00010000，对应的Base64值分别为T、Q，再补上二个”=”号，因此”M”的Base64编码就是TQ==。 参考与引用： 十分钟搞清字符集和字符编码 浅谈编码集 字符集和字符编码（Charset &amp; Encoding）]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QTCP与断线重连]]></title>
    <url>%2FQT%2Fqtcp%E4%B8%8E%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E%2F</url>
    <content type="text"><![CDATA[先简单介绍一下QTcpSocket上面常用的几个信号与函数 信号名 触发条件 connected() 连接成功时 disconnected() 断开连接时 error(QAbstractSocket::SocketError socketError) 产生错误时，附带错误码 hostFound() 调用connectToHost，并且找到主机后发出，还没连接上 proxyAuthenticationRequired(const QNetworkProxy &amp; proxy, QAuthenticator * authenticator) This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection. stateChanged(QAbstractSocket::SocketState socketState) 连接状态发生改变时，会发出，附带当前状态的状态码 常用函数 简介 connectToHost 连接 disconnectFromHost 断开连接，会等待数据发送完毕 abort 立即断开，丢弃数据 state 查看当前socket的状态 error 查看当前socket的错误 close 关闭包括（I/O设备，连接，socket，重置各种数据） waitForConnected 阻塞，等待连接，连接成功发出true，超时发出false waitForReadyRead 阻塞，等待数据和readyRead信号，超时反回false waitForBytesWritten 阻塞，至少写入一个字节和发出byteswrite信号后才发出true，超时发出false waitForDisconnected 阻塞，等待断开，断开成功发出true，超时发出false read 读取，可以每次读取一定量的数据 readLine 读取一行数据 readAll 读取缓冲区所有数据 write 写入数据 断线重连机制原理​ 下面两种方法原理其实都一样，检查socket的状态，如果是断开，开启重新连接机制，连接成功，关掉机制。 一、使用定时器 基于QTcpSocket的派生类，信号和槽在构造函数中连接 在定时器的timeout信号触发时，对应的槽函数处理为 12345if( 判断当前socket的状态，没有连接上 )&#123; socket连接&#125;else &#123; 定时器stop&#125; 在socket的disconnected信号发出时，对应的槽函数处理为 123abort();disconnectFromHost();定时器启动 缺点是与当前线程占相同的资源，优点个人感觉实现起来非常简单。 二、使用线程 基于QThread的派生类，信号和槽，socket创建，需要在调用线程start前创建好 在线程的run方法中，处理如下， 12345678910while(threadRun)&#123; if( socket没有连接上 )&#123; connectToHost; waitForConnected(); 连接并产生阻塞，退出当前线程 &#125; if( socket没有连接上 )&#123; continue; &#125; waitForReadyRead(); 来到这里表示socket连接成功，产生阻塞，等待数据到来&#125; 因为socket的处理是在新的线程中运行，接收到数据需要发送到主线程中，readyRead对应的槽函数处理为 1234while( bytesAvailable()&gt;0 )&#123; byteArray=readAll(); emit signalReadyRead(byteArray);&#125;]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT信号槽]]></title>
    <url>%2FQT%2Fqt%E4%BF%A1%E5%8F%B7%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[个人使用过的信号槽的连接方式有三种，需要产生信号的类需要在类定义中加入Q_OBJECT，并且重新执行qmake 1.QT4信号槽12345678910111213141516171819202122connect(sender,SIGNAL(),receiver,SLOT());分别为发送信号的类，对应的信号，接收信号的类，处理信号的槽关于SIGNAL和SLOT，其实是qt的两个宏定义Q_CORE_EXPORT const char *qFlagLocation(const char *method);#ifndef QT_NO_META_MACROS#ifndef QT_NO_DEBUG# define QLOCATION "\0" __FILE__ ":" QT_STRINGIFY(__LINE__)# ifndef QT_NO_KEYWORDS# define METHOD(a) qFlagLocation("0"#a QLOCATION)# endif# define SLOT(a) qFlagLocation("1"#a QLOCATION)# define SIGNAL(a) qFlagLocation("2"#a QLOCATION)#else# ifndef QT_NO_KEYWORDS# define METHOD(a) "0"#a# endif# define SLOT(a) "1"#a# define SIGNAL(a) "2"#a#endif 2.QT5信号槽1234connect(sender,&amp;senderClassName::functionName,receiver,&amp;receiverClassName::function);因为会进行错误检查，而qt4不会，从上面可以得知，qt4信号槽的参数只是字符串。但是对于信号重载的处理比较麻烦，qt4只需要在signals里面使用()括上参数即可，而qt5需要进行强制转换。static_cast&lt;void (className::*)(parameter)&gt;(&amp;className::functionName) 3.信号与Lamda表达式结合1234567891011connect(sender,&amp;senderClassName::functionName,[=]( //parameter )&#123; //slove &#125;);[] 捕捉列表 [] 不捕获任何值 [var1,var2...] 在函数里，捕获var1,var2的值 [&amp;var1,&amp;var2...] 捕获var1,var2的引用对象 [=] 捕获所有外部变量的值 [&amp;] 捕获所有外部变量的引用() 参数 mutable 可以修改捕捉值，但是值本身不会发生改变&#123;&#125; 处理 4.隐藏的第五个参数 Constant Value Description Qt::AutoConnection 0 (默认)如果发送和接收都在同一个线程，使用Qt::DirectConnection，否则使用Qt::QueuedConnection。类型是在信号发送时才确定的 Qt::DirectConnection 1 收到信号后，马上即行 Qt::QueuedConnection 2 保存在一个队列中，当接收事件循环启动时，执行槽函数 Qt::BlockingQueuedConnection 3 与Qt::QueuedConnection类似，但是运行槽函数时，会阻塞信号线程。发送与接收不可以在同一线程，会造成死锁 Qt::UniqueConnection 0x80 可以使用OR实现多种参数连接，但是如果已经存在相同的connect时，会失败。 注意，使用连接时，需要考虑之前是否有连接，因为重新连接了相同的信号与槽，发出一个信号后，会多次触发槽函数，非常浪费资源！！ 补充介绍disconnec的使用 12345disconnect(sender,信号，receiver,槽);其中，信号、receiver、槽都可以为0(0表示任意所有) sender不能为0例1、sender多个不同的信号与receiver的一个槽绑定，参数可以这样写，（sender,0,receiver,槽）例2、sender多个信号与receiver的多个槽绑定了，（sender,0,receiver,0）例3、sender多个信号与多个receiver的多个槽绑定了，（sender,0,0,0）]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型转换]]></title>
    <url>%2FC%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在使用这一段时间中，数据类型太多了，很多都需要转换。本章为总结。 C++强制转换有四种1234static_cast&lt;&gt;()dynamic_cast&lt;&gt;()const_cast&lt;&gt;()reinterpret_cast&lt;&gt;() static_cast 基本数据的转换、空指针与指针之间的转换 目前使用于信号槽函数强制转换，基于QT5的新特性，在使用connect时，第二第四个参数产生的为&amp;className::functionName，如果函数被重载了，QT无法判断需要使用哪个信号，即使你的槽函数设置对应的参数，这里需要对第二个参数进行强制转换，如下。 static_cast&lt;void (className::*)(parameter)&gt;(&amp;className::functionName)这样可以将函数进行强制转换，解决信号定位的问题。 dynamic_cast&lt;&gt;() 类的下行转换，由基数向派生类转换 目前没有使用过 const_cast&lt;&gt;() 去掉const或者volatile属性 12const char *cstr="rts";char *str=const_cast&lt;char *&gt;(cstr); reinterpret_cast&lt;&gt;() 主要将数据从一种类型转换为另一种类型，二进制的形式重新解释 在使用windows api的时候，需要使用宽字符wcahr_t，而qt里面没有原这样的类型，但是qstring有转换成宽字符的函数，操作如下 12QString str;reinterpret_cast&lt;const wchar_t *&gt;(str.utf16()); 百度百科介绍，static_cast进行类的转换，会进行实际的偏移，而reinterpret_cast不会 qobject_cast(QObject *object) 该转换只适用于继承自object的派生类，且类中带有Q_OBJECT宏声明。 用于将一个QObject对象转换为对应的派生类，如果类型不符合，则转换为0； sender为槽对象，默认是QObject类型 在这里，如果有多个不同的信号对应同一个槽，可以根据该转换来判断传递对象的类型，像这里，如果sender是QLabel则会转换成功，否则为空 1qobject_cast&lt;QLabel *&gt;(sender())； qgraphicsitem_cast qvariant_cast]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Cpp基础</tag>
        <tag>QT基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo建站小结]]></title>
    <url>%2F%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE%2Fhexo%E5%BB%BA%E7%AB%99%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[搭建工作下载安装 node.js 和 git 默认安装即可安装成功后，右击系统菜单键会多出两项 在系统盘上，找个地方，如D:/github/ 进入到文件夹，右击，点击Git Bash Here 安装Hexo12345678npm install hexo-cli -ghexo init blogcd blognpm install node-sass@4.14.1npm installnpm install hexo-renderer-pug --savenpm install hexo-renderer-sass --savehexo server 意思分别为 安装hexo hexo在blog文件夹初始化，不需要手动创建 (blog可以改变，只是一个文件夹名字) 进入blog文件夹 安装依赖扩展插件 开启服务，此时在浏览器输入http://localhost:4000/ 或者 http://127.0.0.1:4000 可以看到相关页面（ctrl+c退出） 1可以使用nvm管理nodejs的版本，按目前还说，最好使用v12版本的 Hexo常用命令123456hexo generate (hexo g) 编译生成hexo server (hexo s) 启动服务hexo deploy (hexo d) 上传hexo new page &quot;p&quot; 生成一个p页面 hexo new &quot;p&quot; 生成一个标题为p的新文章hexo clean 清除编译生成 Hexo还有很多插件，如果下面使用过程中发现问题，可以百度查找，安装对应的插件创建一个Github代码仓库 如果没有帐号，需要注册一个 点击在网页右上角，选择新建仓库 仓库的Repository name为仓库名，格式有规定，如果你注册的github帐户名为orz，那么这里就要填orz.github.io，其它设置看介绍，创建仓库 添加SSH数据提交这里选择SSH，下面是SSH安装与Github绑定SSH安装1234567ls ~/.ssh检查是否安装了ssh，如果有id_rsa.pub，跳过下面步骤ssh-keygen -t rsa -C &quot;邮箱地址&quot;安装的时候，连续点击三次回车，分别是跳过文件夹和把密码设置为空pwd ~/.ssh查看ssh的安装路径 绑定 找到ssh/id_rsa.pub，打开，复制全部内容 打开github网站，选择SSH and GPG keys New SSH Key标题随便写，将复制的内容写到Key里面，添加 验证是否连通 输入 ssh -T git@github.com如果看到你在github注册的帐号名，即表示成功 初始化设置打开D:/github/blog/_config.yml 1234deploy: type: git repo: branch: master rope的值参考下图 点击Clone or download弹出的链接 写入到_config.yml的rope 注意和：有一个空格，不能少 主题设置从网上查找Hexo主题，下载放到D:/github/blog/themes里面。打开D:/github/blog/_config.yml将theme：改为刚刚下载的主题文件夹名。其余设置需要参考主题的介绍 纸上得来终觉㳀，绝知此事要躬行]]></content>
      <categories>
        <category>无处安放</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
