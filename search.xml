<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[QT的衣服--样式表]]></title>
    <url>%2F2019%2F03%2F01%2FQT%E7%9A%84%E8%A1%A3%E6%9C%8D-%E6%A0%B7%E5%BC%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[之前一直想找本书，介绍各个控件的样式表与子部件，发现并没有，只能通过官方网站的介绍（甩网址三连）： 样式表的作用 样式表参考 样式表例子 一、设定样式表1231.通过UI设置“改变样式表”,将对应的样式表写进去2.通过代码设置，控件使用setStyleSheet(QString)3.通过文件，读取文本，将文本使用setStyleSheet(QString)写入qApp中 二、指定对象设置样式表123456789101112131415类中有多个按钮，但是需要设置成不同的样子QPushbutton btn1,btn2,btn3;1.btn1.setStyleSheet("");btn2.setStyleSheet("");btn3.setStyleSheet("");2.btn1.setObjectName("btn1");btn2.setObjectName("btn2");btn3.setObjectName("btn3");this.setStyleSheet("QPushbutton#btn1&#123;&#125;QPushbutton#btn2&#123;&#125;QPushbutton#btn3&#123;&#125;");类#类名::子部件:伪状态&#123;&#125; 应该是这个形式了还有一个更复杂的，修改QTabWidget的QTabBar点击下去的属性QTabWidget#tabWidget QTabBar::tab:selected&#123;&#125; 样式表学习可以通过CSS，因为有时候有点迷，找前端的妹子问一下，就可以了~~~两者相似度估计达80% 因为每个控件都有自己独特的样式表，列举不完，而且也比较菜~~~~经验自己总结总结，本人也会总结，看情况再更新这个吧。打个赌，哈哈。2019-03-02 16:38-58]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路径的集合QPainterPath]]></title>
    <url>%2F2019%2F02%2F26%2F%E8%B7%AF%E5%BE%84%E7%9A%84%E9%9B%86%E5%90%88QPainterPath%2F</url>
    <content type="text"><![CDATA[经常把这个跟QPainter结合使用，比较方便12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485QPainterPath是一个集合，比如我要画个矩形，不通过addRect方法，使用lineTo，它会保存当前点，如```c++QPainterPath path;path.moveTo(10,10);path.lineTo(20,10);path.lineTo(20,20);path.lineTo(10,20);path.lineTo(10,10);以上一个点为终于，不需要设置，如果从来 可以调用void closeSubpath();```### 一、API介绍```c++ void closeSubpath(); //将当前点设回（0，0） void moveTo(const QPointF &amp;p); //将当前点移动到某点 inline void moveTo(qreal x, qreal y); void lineTo(const QPointF &amp;p); //从当前点画直线到某点 inline void lineTo(qreal x, qreal y); void arcMoveTo(const QRectF &amp;rect, qreal angle); //移动到某点，计算方式为以某矩形为外接矩形的angle角度处 inline void arcMoveTo(qreal x, qreal y, qreal w, qreal h, qreal angle); void arcTo(const QRectF &amp;rect, qreal startAngle, qreal arcLength); //从当前点画圆弧 inline void arcTo(qreal x, qreal y, qreal w, qreal h, qreal startAngle, qreal arcLength); void cubicTo(const QPointF &amp;ctrlPt1, const QPointF &amp;ctrlPt2, const QPointF &amp;endPt); //三次样条曲线，c1和c2为控制点 inline void cubicTo(qreal ctrlPt1x, qreal ctrlPt1y, qreal ctrlPt2x, qreal ctrlPt2y, qreal endPtx, qreal endPty); void quadTo(const QPointF &amp;ctrlPt, const QPointF &amp;endPt); //二次样条曲线， c为控制点 inline void quadTo(qreal ctrlPtx, qreal ctrlPty, qreal endPtx, qreal endPty); QPointF currentPosition() const; //当前位置 void addRect(const QRectF &amp;rect); //插入一个矩形 inline void addRect(qreal x, qreal y, qreal w, qreal h); void addEllipse(const QRectF &amp;rect); //插入一个圆 inline void addEllipse(qreal x, qreal y, qreal w, qreal h); inline void addEllipse(const QPointF &amp;center, qreal rx, qreal ry); void addPolygon(const QPolygonF &amp;polygon); //插入一个多边形 void addText(const QPointF &amp;point, const QFont &amp;f, const QString &amp;text); //插入文字 inline void addText(qreal x, qreal y, const QFont &amp;f, const QString &amp;text); void addPath(const QPainterPath &amp;path); //添加一个路径 void addRegion(const QRegion &amp;region); //Adds the given region to the path by adding each rectangle in the region as a separate closed subpath. void addRoundedRect(const QRectF &amp;rect, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize); //添加圆角矩形 inline void addRoundedRect(qreal x, qreal y, qreal w, qreal h, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize); void addRoundRect(const QRectF &amp;rect, int xRnd, int yRnd); inline void addRoundRect(qreal x, qreal y, qreal w, qreal h, int xRnd, int yRnd); inline void addRoundRect(const QRectF &amp;rect, int roundness); inline void addRoundRect(qreal x, qreal y, qreal w, qreal h, int roundness); void connectPath(const QPainterPath &amp;path); //以当前结束点为起点 添加path bool contains(const QPointF &amp;pt) const; //是否包含该点 bool contains(const QRectF &amp;rect) const; //是否包含该矩形 bool intersects(const QRectF &amp;rect) const; //是否与之相交 void translate(qreal dx, qreal dy); //平移 inline void translate(const QPointF &amp;offset); QPainterPath translated(qreal dx, qreal dy) const Q_REQUIRED_RESULT; inline QPainterPath translated(const QPointF &amp;offset) const Q_REQUIRED_RESULT; QRectF boundingRect() const; //返回外接矩形 QRectF controlPointRect() const; //比boundingRect快 是它的超集 Qt::FillRule fillRule() const; void setFillRule(Qt::FillRule fillRule); bool isEmpty() const; QPainterPath toReversed() const Q_REQUIRED_RESULT; //返回一个反向路径 QList&lt;QPolygonF&gt; toSubpathPolygons(const QMatrix &amp;matrix = QMatrix()) const;//返回路径吧 底下几个都有点像 QList&lt;QPolygonF&gt; toFillPolygons(const QMatrix &amp;matrix = QMatrix()) const; QPolygonF toFillPolygon(const QMatrix &amp;matrix = QMatrix()) const; QList&lt;QPolygonF&gt; toSubpathPolygons(const QTransform &amp;matrix) const; QList&lt;QPolygonF&gt; toFillPolygons(const QTransform &amp;matrix) const; QPolygonF toFillPolygon(const QTransform &amp;matrix) const; int elementCount() const; QPainterPath::Element elementAt(int i) const; void setElementPositionAt(int i, qreal x, qreal y); qreal length() const; qreal percentAtLength(qreal t) const; QPointF pointAtPercent(qreal t) const; qreal angleAtPercent(qreal t) const; qreal slopeAtPercent(qreal t) const; bool intersects(const QPainterPath &amp;p) const; bool contains(const QPainterPath &amp;p) const; QPainterPath united(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; QPainterPath intersected(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; QPainterPath subtracted(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; QPainterPath subtractedInverted(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; 123456789101112131415161718### 二、从QPainterPath中获取所有数据并绘制出来（包括文字轮廓，文字轮廓也可以用FreeType~~~~）```c++ QPainterPath path; path.addRect(30,30,30,30); path.addText(100,100,QFont(&quot;宋体&quot;,80),&quot;135赟&quot;); QList&lt;QPolygonF&gt; list=path.toSubpathPolygons(); for(int i=0;i&lt;list.size();i++)&#123; QPolygonF polygonF=list[i]; //p.drawPolygon(polygonF); //方法一 for(int j=1;j&lt;polygonF.size();j++)&#123; p.drawLine(polygonF.at(j-1),polygonF.at(j)); //可以获取到各个点 &#125; &#125;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神奇的QPainter]]></title>
    <url>%2F2019%2F02%2F22%2FQPainter%E7%A5%9E%E5%A5%87%E7%9A%84%E7%94%BB%E7%AC%94%2F</url>
    <content type="text"><![CDATA[前沿很多很好看的控件，都不是通过样式表设定样式出现的，而是通过自绘控件或者QStyle或者代理，这几种方式，都会有QPainter的出现！对于一个widget，只能有一个激活的QPainter进行绘制，会打架的！设定有两种方式，一种是构造函数，一种是begin。 QT没有采用二维笛卡尔坐标，以屏幕左上角为原点，向右为X+，向下为Y+。可以使用setWindow实现， 一、API12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879QPainter(); explicit QPainter(QPaintDevice *); //构造并且指定绘制的控件 QPaintDevice *device() const; //返回指定的控件 bool begin(QPaintDevice *); //在该控件绘制 bool end(); //结束绘制 bool isActive() const; //是否绘制void initFrom(const QPaintDevice *device); //以device初始化pen font backgroundconst QFont &amp;font() const; //绘制字体时的字体 void setFont(const QFont &amp;f); //指定一个字体 void setPen(const QColor &amp;color); //几种设定画笔的方式 void setPen(const QPen &amp;pen); void setPen(Qt::PenStyle style); const QPen &amp;pen() const; void setBrush(const QBrush &amp;brush); //设定QBrush 用于指定填充颜色 void setBrush(Qt::BrushStyle style); //不需要时可以 setBrush(Qt::NoBrush) const QBrush &amp;brush() const; void setBackgroundMode(Qt::BGMode mode); //设定透明或者不透明模式 没用过 0_0 Qt::BGMode backgroundMode() const; QPoint brushOrigin() const; //用意不明 设定填充的起点 inline void setBrushOrigin(int x, int y); inline void setBrushOrigin(const QPoint &amp;); void setBrushOrigin(const QPointF &amp;); void setBackground(const QBrush &amp;bg); //设定背景色 const QBrush &amp;background() const; qreal opacity() const; //设定不透明度 void setOpacity(qreal opacity); QRegion clipRegion() const; //设定一个区域，只能在该区域绘图 QRegion可以用来求面积相交的部分 QPainterPath clipPath() const; void setClipRect(const QRectF &amp;, Qt::ClipOperation op = Qt::ReplaceClip); void setClipRect(const QRect &amp;, Qt::ClipOperation op = Qt::ReplaceClip); inline void setClipRect(int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip); void setClipRegion(const QRegion &amp;, Qt::ClipOperation op = Qt::ReplaceClip); void setClipPath(const QPainterPath &amp;path, Qt::ClipOperation op = Qt::ReplaceClip); void setClipping(bool enable); bool hasClipping() const; QRectF clipBoundingRect() const; void save(); //大有用处！保存和恢复pen brush 变换（rotate,translate,scale,shear） void restore();(World Coordinates)==&gt;(Window Coordinates)==&gt;(Device Coordinates) 世界坐标（逻辑坐标） 世界变换 窗口坐标 窗口视图变换 设备坐标 void setTransform(const QTransform &amp;transform, bool combine = false); //修改世界变换 替换了setWorldMatrix const QTransform &amp;transform() const; const QTransform &amp;deviceTransform() const; void resetTransform(); void setWorldTransform(const QTransform &amp;matrix, bool combine = false); const QTransform &amp;worldTransform() const; void scale(qreal sx, qreal sy); //缩放 void shear(qreal sh, qreal sv); //剪切 void rotate(qreal a); //旋转 void translate(const QPointF &amp;offset); //平移 inline void translate(const QPoint &amp;offset); inline void translate(qreal dx, qreal dy); QRect window() const; //修改窗口绘图坐标 设定绘图区域范围是多少 如 0,0 100,100 右下角就是100，100 void setWindow(const QRect &amp;window); inline void setWindow(int x, int y, int w, int h);QRect viewport() const; //修改视图绘图坐标 设定绘图区域范围 如 0,0 100,100 那么只在这个矩形内画图，并且100，100这个点对应的范围是 window的右下角 void setViewport(const QRect &amp;viewport); inline void setViewport(int x, int y, int w, int h); void setViewTransformEnabled(bool enable); bool viewTransformEnabled() const; void scale(qreal sx, qreal sy); //缩放 void shear(qreal sh, qreal sv); //扭曲 void rotate(qreal a); //旋转 QPainter内置的一些图形，如果有更多的需求，配合QPainterPath实现 123456789101112131415161718192021222324 void strokePath(const QPainterPath &amp;path, const QPen &amp;pen); //绘制path的轮廓 void fillPath(const QPainterPath &amp;path, const QBrush &amp;brush); //绘制path的填充区域 void drawPath(const QPainterPath &amp;path); //绘制path函数都有多个重载，只写出大概的意思 drawPoint 画一个点 drawPoints 画几个点 drawLine 画一条线 drawLines 画几条线 drawRect 画一个矩形 drawRects 画几个矩形 drawEllipse 画正圆或者椭圆 drawPolyline 画多段线 drawPolygon 画多边形 drawConvexPolygon 画凸多边形 drawArc 画圆弧，参数只能传整数，若画90度，角度参数传90*16 drawPie 画饼图，参数只能传整数，若画90度，角度参数传90*16 drawChord 画弦图， drawRoundedRect 画圆角矩阵，百份比 drawRoundRect 画圆角矩阵，度数 drawPicture 画.pic图片 drawPixmap 画位图 若是QBitmap则是使用pen的颜色绘制 QPixmap则使用原图 drawPixmapFragments 同时绘制多个pixmax或者子图 带优化 drawImage 画QImage 二、简单使用1234567891011//实现父类虚函数void paintEvent(QPaintEvent *e)&#123; //一 QPainter painter(this); //二 QPainter painter; painter.begin(this); painter.end();&#125; 三、QT坐标转笛卡尔坐标（setWindow，setViewport）1234567891011因为QT的QPainter坐标是以左上角为原点，与迪卡尔坐标不一样，所以我当时做的操作是x=_x;y=(-_y)+height(); y轴先与x轴对称，然后平衡一个屏幕的高度，完成转换笛卡尔坐标操作 当然这也有好处，全部东西都由自己控制二、void setWindow(const QRect &amp;window);void setViewport(const QRect &amp;viewport);最近才发现这两个函数，这样解释一下，setWindow有四个参数x,y,w,h，前两个参数是设定图像左上角的坐标，右角坐标为 x+w,y+h 用这个函数可以直接实现笛卡尔坐标系（左下角为原点）setWindow(0,height(),width(),-height()); 这个意思体会体会setViewport 就是设定绘画的区域 目前没有找到哪里合适用 四、类中子控件绘制123456789101112131415161718192021子控件是QWidget的派生类： 在类中重写void paintEvent(QPaintEvent *e);进行相应的绘制就行子控件不是QWidget的派生类，但是想在类中绘制，可以使用拦截事件： QWidget *paintWidget=new QWidget(); paintWidget-&gt;installEventFilter(this); 接着重载事件过滤事件 bool eventFilter(QObject *o, QEvent *e)&#123; if(o==paintWidget)&#123; if(e-&gt;type()==QEvent::Paint)&#123; mPainterWidget(paintWidget); return true; &#125; &#125; return QWidget::eventFilter(o,e); &#125; void mPainterWidget(QWidget *w)&#123; QPainter painter(w); //draw somthing &#125; 五、画一个带角度的椭圆12345678910当初好奇，想画一个带角度的椭圆，发现图形画圆的drawEllipse 没有带角度的参数，只有一个外接矩形后面又发现QPainter自带一个角度旋转（顺时针） 舒服void translate(const QPointF &amp;offset);void rotate(qreal a);步骤：painter.translate(x,y); 因为角度旋转是以原点旋转，所以先将坐标点平移到椭圆中心painter.rotate(15); 旋转角度painter.drawEllipse(x-w/2,y-h/2,w,h);painter.resetTransform(); 恢复原来]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT布局个人总结]]></title>
    <url>%2F2019%2F01%2F31%2FQT%E5%B8%83%E5%B1%80%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[很久很久以前，刚接触QT，发现UI拖控件真爽，做个计算器什么的，一下子就搭出来了！实现起来也很得心应手，后面做的界面越来越复杂后，特别是别人跟你提意见，需要修改的时候，绝望！打破布局各种不友好。开始使用代码布局，代码new控件，修改的时候也比较好修改，而且可以实现动态布局！感觉缺点就是样式表没有UI这么友好，实时体现。 一、布局类123456789101112QLayoutItem QLayout(和QObject) QBoxLayout QHBoxLayout 水平布局 QVBoxLayout 垂直布局 QGridLayout 栅栏布局 QFormLayout 表单布局 QGraphicsLayout QStackedLayout 堆布局 QSpacerItem 空白占位（UI上的弹簧） QWidgetItem QWidgetItemV2 为什么个人不喜欢用QGridLayout呢？因为QGridLayout很容易被控制改变实际比例，导致出现和预设的比例不同。排问题好麻烦，推荐在行或者列使用相同的控件时使用。（有可能是我太菜了，使用不来） QLayout1234567891011121314151617181920212223QWidget *parentWidget() const; //返回布局依赖控件void setContentsMargins(int left, int top, int right, int bottom); //布局的左上右下边距 void setContentsMargins(const QMargins &amp;margins); void getContentsMargins(int *left, int *top, int *right, int *bottom) const; QMargins contentsMargins() const; QRect contentsRect() const; void addWidget(QWidget *w); //添加控件 virtual void addItem(QLayoutItem *) = 0; void removeWidget(QWidget *w); //移除控件，不生效！下面会讲怎么从布局中去掉控件 void removeItem(QLayoutItem *); void setEnabled(bool); bool isEnabled() const; void setMargin(int); void setSpacing(int); virtual QLayoutItem *itemAt(int index) const = 0; virtual QLayoutItem *takeAt(int index) = 0; virtual int indexOf(QWidget *) const; virtual int count() const = 0; QBoxLayout123456789101112 void addSpacing(int size); //添加指定大小的占位 void addStretch(int stretch = 0); //添加指定比例的占位 void addSpacerItem(QSpacerItem *spacerItem); //添加一个弹簧 void addWidget(QWidget *, int stretch = 0, Qt::Alignment alignment = 0); //添加一个布局 void addLayout(QLayout *layout, int stretch = 0); //添加一个布局 void addStrut(int); //Limits the perpendicular dimension of the box (e.g. height if the box is LeftToRight) to a minimum of size. Other constraints may increase the limit. void addItem(QLayoutItem *) Q_DECL_OVERRIDE; //继承自QLayoutItem 纯虚函数还有对应的insert插入操作 void setSpacing(int spacing); //设定控件之间的距离 bool setStretchFactor(QWidget *w, int stretch); //更改该控件的比例 bool setStretchFactor(QLayout *l, int stretch); //更改该布局的比例 void setStretch(int index, int stretch); //更改第index项的比例 QGridLayout1234567891011121314151617181920void setHorizontalSpacing(int spacing); //控件间距 int horizontalSpacing() const; void setVerticalSpacing(int spacing); int verticalSpacing() const; void setSpacing(int spacing); int spacing() const; void setRowStretch(int row, int stretch); //行列比例 void setColumnStretch(int column, int stretch); int rowStretch(int row) const; int columnStretch(int column) const; int columnCount() const; //行列数量 int rowCount() const; inline void addWidget(QWidget *w) &#123; QLayout::addWidget(w); &#125; //插入控件 void addWidget(QWidget *, int row, int column, Qt::Alignment = 0); void addWidget(QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0); void addLayout(QLayout *, int row, int column, Qt::Alignment = 0); void addLayout(QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0); QFormLayout没用过，类似一个QHBoxLayout，固定一个QLabel和一个等待插入的控件。 QGraphicsLayout没用过，给Graphics View使用。 QStackedLayout跟QStackedWidget一样，方式不一样，QStackedLayout是多个Layout QStackedWidget是多个Widget QSpacerItem弹簧 1234567QSpacerItem(int w, int h, QSizePolicy::Policy hData = QSizePolicy::Minimum, QSizePolicy::Policy vData = QSizePolicy::Minimum) : width(w), height(h), sizeP(hData, vData) &#123; &#125; void changeSize(int w, int h, QSizePolicy::Policy hData = QSizePolicy::Minimum, QSizePolicy::Policy vData = QSizePolicy::Minimum); QWidgetItem没用过 Normally, you don’t need to use this class directly. Qt’s built-in layout managers provide the following functions for manipulating widgets in layouts 二、布局遍历1234for(int i=0;i&lt;mlayout-&gt;count();i++)&#123; QLabel *lab=qobject_cast&lt;QLabel*&gt;(mlayout.itemAt(i)-&gt;widget()); qDebug()&lt;&lt;lab-&gt;text();&#125; 三、清除布局1234while(mlayout-&gt;count())&#123; mlayout-&gt;itemAt(0)-&gt;widget()-&gt;setParent(nullptr); //将父类设空既可 下面一句保留 //mlayout-&gt;removeWidget(mlayout-&gt;itemAt(0)-&gt;widget());&#125; 四、动态布局动态布局借用清除布局，将layout里面的widget全部清空，然后重新添加需要的widget，视觉上面可以看到是界面可以动态变换 123clearLayout(mlayout);mlayout-&gt;addWidget(subWidget1,1);mlayout-&gt;addwidget(subWidget2,2); 五、注意设置布局前，控件应该设定好大小策略，限定大小的变化 1234567891011 void QWidget::setSizePolicy(QSizePolicy::Policy hor, QSizePolicy::Policy ver);void setSizePolicy(QSizePolicy);enum Policy &#123; Fixed = 0, Minimum = GrowFlag, Maximum = ShrinkFlag, Preferred = GrowFlag | ShrinkFlag, MinimumExpanding = GrowFlag | ExpandFlag, Expanding = GrowFlag | ShrinkFlag | ExpandFlag, Ignored = ShrinkFlag | GrowFlag | IgnoreFlag &#125;;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置文件与注册表]]></title>
    <url>%2F2019%2F01%2F27%2F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一、QSettings​ QT中，对.ini文件和注册表都是使用同一个类，就是QSettings类。使用简单，但是不知道是设置问题还是啥，会有点小问题，下面我会指出。 ​ API中介绍，创建QSettings时，必须需要指定公司或者组织、应用名称。注册表使用的，读取INI不需要设置。（you must pass the name of your company or organization as well as the name of your application.） 1QSettings settings("MySoft", "Star Runner"); 1）简单介绍123456789101112131415161718192021222324252627282930313233QSettings(const QString &amp; fileName, Format format, QObject * parent = 0)；/*FormatQSettings::NativeFormat 0 在windows平台，用于读取注册表，OSX和IOS 读CFPreferences，Unix读INIQSettings::IniFormat 1 Store the settings in INI files.QSettings::InvalidFormat 16 Special value returned by registerFormat().*/QStringList allKeys() const; //返回所有的键 如group/keyvoid beginGroup(const QString &amp; prefix); //直接读取prefix组void QSettings::endGroup(); //返回上一级/*settings.beginGroup("mainwindow");settings.setValue("size", win-&gt;size());settings.setValue("fullScreen", win-&gt;isFullScreen());settings.endGroup();settings.beginGroup("outputpanel");settings.setValue("visible", panel-&gt;isVisible());settings.endGroup();*/QStringList QSettings::childGroups() const; //返回所有的groupQStringList QSettings::childKeys() const; //返回当前级别的keybool QSettings::contains(const QString &amp; key) const; //是否包含keyvoid QSettings::remove(const QString &amp; key); //删除本项及子项void QSettings::setIniCodec(QTextCodec * codec); //设置编码void QSettings::setIniCodec(const char * codecName);[static] void QSettings::setPath(Format format, Scope scope, const QString &amp; path); //设置文件路径/*QSettings::UserScope 0 特定用户范围.QSettings::SystemScope 1 本机所有用户.*/void QSettings::setValue(const QString &amp; key, const QVariant &amp; value); //写入值QVariant QSettings::value(const QString &amp; key, const QVariant &amp; defaultValue = QVariant()) const; //取值 2）读写配置文件12345QSetting qset("./my.ini"，QSettings::IniFormat);qset.setValue("group/key","nice");qDebug()&lt;&lt;qset.value("group/key"); //可以取到nice//对于中文utf8的文档 需要增加一句qset.setIniCodec("UTF8"); //GBK UNICODE GB2312 3）读写注册表12345QSetting REGRead("MySoft", "Star Runner"); //会在注册表中建了一个MySoft，底下会有个Star Runner的文件夹 下面的操作会在 Star Runner中进行//写REGRead.setValue("",""); //读REGRead.value(""); 二、API1）读写配置文件12345678910111213141516171819202122232425262728293031323334//读写系统配置文件GetProfileInt(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);GetProfileString(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize);WriteProfileString(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString);GetProfileSection(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize);WriteProfileSection(LPCWSTR lpAppName, LPCWSTR lpString);//读写自定义配置文件GetPrivateProfileInt(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);GetPrivateProfileString(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);WritePrivateProfileString(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);GetPrivateProfileSection(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);WritePrivateProfileSection(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName);GetPrivateProfileSectionNames(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);GetPrivateProfileStruct(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);WritePrivateProfileStruct(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);//例子//写WritePrivateProfileString( reinterpret_cast&lt;const wchar_t *&gt;(group.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(key.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(error.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(filepath.utf16()));//读wchar_t buf[64];GetPrivateProfileString( reinterpret_cast&lt;const wchar_t *&gt;(group.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(key.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(error.utf16()), buf,sizeof(buf)-1, reinterpret_cast&lt;const wchar_t *&gt;(filepath.utf16()));QString::fromWCharArray(buf); 2）读写注册表​ 只捉几个介绍！ 12345678910111213141516171819202122232425RegCreateKeyEx(HKEY hKey,LPCWSTR lpSubKey,DWORD Reserved,LPWSTR lpClass,DWORD dwOptions,REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,PHKEY phkResult,LPDWORD lpdwDisposition);RegCreateKey(HKEY hKey,LPCWSTR lpSubKey,PHKEY phkResult);/*创建键值*/RegDeleteKeyEx(HKEY hKey,LPCWSTR lpSubKey,REGSAM samDesired,DWORD Reserved);RegDeleteKey(HKEY hKey,LPCWSTR lpSubKey);/*删除键值*/RegOpenKeyEx(HKEY hKey,LPCWSTR lpSubKey,DWORD ulOptions,REGSAM samDesired,PHKEY phkResult);RegOpenKey(HKEY hKey,LPCWSTR lpSubKey,PHKEY phkResult);/*打开键值*/RegQueryValueEx(HKEY hKey,LPCWSTR lpValueName,LPDWORD lpReserved,LPDWORD lpType,LPBYTE lpData,LPDWORD lpcbData);RegQueryValue(HKEY hKey,LPCWSTR lpSubKey,LPWSTR lpData,PLONG lpcbData);/*获取键值*/RegSetValueEx(HKEY hKey,LPCWSTR lpValueName,DWORD Reserved,DWORD dwType,CONST BYTE *lpData,DWORD cbData);RegSetValue(HKEY hKey,LPCWSTR lpSubKey,DWORD dwType,LPCWSTR lpData,DWORD cbData);/*修改键值*/]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QString与QStringList]]></title>
    <url>%2F2019%2F01%2F26%2FQString%E4%B8%8EQStringList%2F</url>
    <content type="text"><![CDATA[对于我而言，这两者用的频率真的非常高了。 一、QString​ 根据api顺序，把自己现在的经验写下来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128QString &amp; append(const QString &amp; str); //追加一个串到尾部，有多个重载QString arg(const QString &amp; a, int fieldWidth = 0, QChar fillChar = QLatin1Char( ' ' )) const; //使用a替换%1 最少占用fieldWidth字符，不足用fillChar替换 fieldWidth为正，右对齐。反之，左对齐QString QString::arg(const QString &amp; a1, const QString &amp; a2) const;/*QString str;str = "%1 %2";str.arg("%1f", "Hello"); // returns "%1f Hello"str.arg("%1f").arg("Hello"); // returns "Hellof %2"*/int QString::compare(const QString &amp; s1, const QString &amp; s2, Qt::CaseSensitivity cs = Qt::CaseSensitive);//比较两个串/*int x = QString::compare("aUtO", "AuTo", Qt::CaseInsensitive); // x == 0int y = QString::compare("auto", "Car", Qt::CaseSensitive); // y &gt; 0int z = QString::compare("auto", "Car", Qt::CaseInsensitive); // z &lt; 0*/bool QString::contains(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; //是否包含str/*QString str = "Peter Pan";str.contains("peter", Qt::CaseInsensitive); // returns true*/int QString::count(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; //包含str多少次QChar * QString::data(); //将QString转成QChar字符串bool QString::startsWith(const QString &amp; s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; //是否以s开始bool QString::endsWith(const QString &amp; s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; //是否以s结束 QString &amp; QString::fill(QChar ch, int size = -1); //使用连续size个ch填充[static] QString QString::fromLatin1(const char * str, int size = -1); //从char *转入[static] QString QString::fromLocal8Bit(const char * str, int size = -1);//从8字节长度char *转入[static] QString QString::fromRawData(const QChar * unicode, int size);//从unicode转入[static] QString QString::fromStdString(const std::string &amp; str);//从标准string转入[static] QString QString::fromStdU16String(const std::u16string &amp; str);//从标准16字长的string转入[static] QString QString::fromStdWString(const std::wstring &amp; str);//从标准宽字节转入[static] QString QString::fromUtf8(const char * str, int size = -1);//从utf8字串转入[static] QString QString::fromUtf16(const ushort * unicode, int size = -1);//从unicode字串转入[static] QString QString::fromWCharArray(const wchar_t * string, int size = -1);//从宽字串转入int QString::indexOf(const QString &amp; str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; //从from位置开始 str出现的位置 没有返回-1QString &amp; QString::insert(int position, const QString &amp; str); //从position位置插入strbool QString::isEmpty() const;/*QString().isEmpty(); // returns trueQString("").isEmpty(); // returns trueQString("x").isEmpty(); // returns falseQString("abc").isEmpty(); // returns false*/bool QString::isNull() const;/*QString().isNull(); // returns trueQString("").isNull(); // returns falseQString("abc").isNull(); // returns false*/QString QString::left(int n) const; //保留左边起n个QString QString::right(int n) const; //保留右边起n个QString QString::mid(int position, int n = -1) const; //保留position位置起，连续n个[static] QString QString::number(long n, int base = 10); //将n转成串[static] QString QString::number(double n, char format = 'g', int precision = 6);/*format:e format as [-]9.9e[+|-]999E format as [-]9.9E[+|-]999f format as [-]9.9g use e or f format, whichever is the most conciseG use E or f format, whichever is the most conciselong a = 63;QString s = QString::number(a, 16); // s == "3f"QString t = QString::number(a, 16).toUpper(); // t == "3F"*/QString &amp; QString::prepend(const QString &amp; str); //将str做为前缀/*QString x = "ship";QString y = "air";x.prepend(y);// x == "airship"*/QString &amp; QString::remove(int position, int n); //从Position删除连续n个QString QString::repeated(int times) const; //串重复times次QString &amp; QString::replace(int position, int n, const QString &amp; after);//不止下面两种/*QString x = "Say yes!";QString y = "no";x.replace(4, 3, y);// x == "Say no!"或者QString str = "colour behaviour flavour neighbour";str.replace(QString("ou"), QString("o"));// str == "color behavior flavor neighbor"*/QString QString::section(QChar sep, int start, int end = -1, SectionFlags flags = SectionDefault) const; //以sep切开，也可以以串切开/*QString str;QString csv = "forename,middlename,surname,phone";QString path = "/usr/local/bin/myapp"; // First field is emptyQString::SectionFlag flag = QString::SectionSkipEmpty;str = csv.section(',', 2, 2); // str == "surname"str = path.section('/', 3, 4); // str == "bin/myapp"str = path.section('/', 3, 3, flag); // str == "myapp"*/QString QString::simplified() const;//去除整串的占位符/*QString str = " lots\t of\nwhitespace\r\n ";str = str.simplified();// str == "lots of whitespace";*/QStringList QString::split(const QString &amp; sep, SplitBehavior behavior = KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;//切割/*SplitBehavior:QString::KeepEmptyParts 0 If a field is empty, keep it in the result.QString::SkipEmptyParts 1 If a field is empty, don't include it in the result.str = "This time, a normal English sentence.";list = str.split(QRegExp("\\W+"), QString::SkipEmptyParts);// list: [ "This", "time", "a", "normal", "English", "sentence" ]*/QByteArray QString::toLatin1() const;QByteArray QString::toLocal8Bit() const;std::string QString::toStdString() constQString QString::toLower() const;//转成大写QString QString::toUpper() const;//转成小写QString QString::trimmed() const;//去掉首尾占位void QString::truncate(int position);//与left有点类似 保留前position个/*QString str = "Vladivostok";str.truncate(4);// str == "Vlad"*/const QChar * QString::unicode() const;//字面意思const ushort * QString::utf16() const; 12345678QString与string的转换，经实验，string与QString使用API互相转换，中文会乱码string2QString&#123; qstr=QString::fromLocal8Bit(str.data());&#125;QString2string&#123; str=string(qstr.toLocal8Bit());&#125; 二、QStringList​ 其实就是QString的数组 12345678910111213141516171819bool QStringList::contains(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; //是否包含strQStringList QStringList::filter(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; //过虑出包含str的串/* QStringList list; list &lt;&lt; "Bill Murray" &lt;&lt; "John Doe" &lt;&lt; "Bill Clinton"; QStringList result; result = list.filter("Bill"); // result: ["Bill Murray", "Bill Clinton"]*/int QStringList::indexOf(const QRegExp &amp; rx, int from = 0) const; //匹配QStringList &amp; QStringList::replaceInStrings(const QString &amp; before, const QString &amp; after, Qt::CaseSensitivity cs = Qt::CaseSensitive); //替换/* QStringList list; list &lt;&lt; "alpha" &lt;&lt; "beta" &lt;&lt; "gamma" &lt;&lt; "epsilon"; list.replaceInStrings("a", "o"); // list == ["olpho", "beto", "gommo", "epsilon"]*/void QStringList::sort(Qt::CaseSensitivity cs = Qt::CaseSensitive); //排序]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包罗万象的QVariant]]></title>
    <url>%2F2019%2F01%2F26%2F%E5%8C%85%E7%BD%97%E4%B8%87%E8%B1%A1%E7%9A%84QVariant%2F</url>
    <content type="text"><![CDATA[一、概念该类常用于数据库中！类似联合数据类型。 它可以包含QT中各种数据类型，包括一些类。摘抄自QT5.5的文档 二、使用1234567891011121314QVariant QVariant::fromValue(const T &amp; value); //会返回一个QVariant 否则与setValue一样void QVariant::setValue(const T &amp; value);//设定一个值T QVariant::value() const;//返回一个值bool QVariant::canConvert(int targetTypeId) const； //如果支持该类型，返回真bool QVariant::convert(int targetTypeId); //将该类型转成targetTypeId 如果不支持，类型会变，而且值会变成0//其中T为一所介绍的类型//例子QVariant qvar;qvar.setValue("bugnull.com");qDebug()&lt;&lt;qvar.toString();qDebug()&lt;&lt;QVariant::fromValue("bugnull.cn");qDebug()&lt;&lt;qvar.value&lt;QString&gt;();qDebug()&lt;&lt;qvar.canConvert&lt;QString&gt;();qDebug()&lt;&lt;qvar.convert&lt;QString&gt;();]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT添加外部库]]></title>
    <url>%2F2019%2F01%2F26%2FQT%E6%B7%BB%E5%8A%A0%E5%A4%96%E9%83%A8%E5%BA%93%2F</url>
    <content type="text"><![CDATA[QT的库虽然已经非常的多，但是还是还是满足不了需求。如音视频库FFMpeg和图纸解析dxflib opendwg等。。。。省略一万字。 一、PRO文件修改​ 增加 123INCLUDEPATH+= 头文件目录LIBS += -L（.lib或者.a的目录） -l（.lib或者.a的名字 不带后缀）#推荐使用 $$PWD/ 表示pro文件当前路径 路径带空格了，可以使用""包括，但是不要把PWD/也包在内！ 常规操作，如果特别的库，看介绍吧。下课！！]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLibrary使用动态库]]></title>
    <url>%2F2019%2F01%2F26%2FQLibrary%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[我使用这种方法一般是因为没有.h .a(.lib)文件的支持下，只能使用QLibrary进行手动提取。 一、常用函数12345bool load()；//加载 需要指定了文件名，跟文件的open一样bool unload()；//卸载void setFileName(const QString &amp; fileName)； //设置库名QFunctionPointer resolve(const char * symbol)； //函数名QString errorString() const； //错误信息 二、使用例子1234567891011121314显示调用QLibrary myLib("mylib");typedef void (*MyPrototype)();MyPrototype myFunction = (MyPrototype) myLib.resolve("mysymbol");if (myFunction) myFunction();隐式调用typedef void (*MyPrototype)();MyPrototype myFunction = (MyPrototype) QLibrary::resolve("mylib", "mysymbol");if (myFunction) myFunction();//上面typedef void (*fun)()为指定一个指针fun为指向反回值为void没有参数的函数指针 三、加载类​ 如果调用函数方法，可以通过上面去加载！类呢？类是由编译期就完成的了！无法实时去索引。经搜索，还真发现了可以完成的例子。 ​ 他利用虚表的特性，在运行时可以动态索引。使用一个接口类，对外进行公开，添加创建对象函数，返回类型为接口类型。 12345678910111213141516171819202122232425262728293031class TestInterface&#123;public: virtual ~TestInterface() &#123; &#125; virtual int getValues() = 0;&#125;class TESTDLL_LIBSHARED_EXPORT TestDLL_lib : public TestInterface&#123;public: TestDLL_lib(); virtual ~TestDLL_lib(); int a; int b; int c; int getValues() override; // MSVC may not support "override"&#125;; // return pointer to interface!// TestDLL_lib can and should be completely hidden from the applicationextern "C" TESTDLL_LIBSHARED_EXPORT TestInterface *create_TestDLL_lib()&#123; return new TestDLL_lib();&#125;//https://stackoverflow.com/questions/26234327/qlibrary-import-a-class]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[extern "C"与_cplusplus]]></title>
    <url>%2F2019%2F01%2F26%2Fextern-C%E4%B8%8E-cplusplus%2F</url>
    <content type="text"><![CDATA[一、extern”C”​ 百度百科讲得很清楚 ，就是说，c++编译器虽然支持c，但是由于函数重载的存在，编译的时候会把参数也加到编译中，而c却不支持。所以使用该符号，表明使用c的方式去编译这些文件。 extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 二、extern​ extern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义，另外，extern也可用来进行链接指定。我觉得它是个导出声明符号，达到代码段共享的作用。 ​ 当时我有点不明白，它和static静态全局有什么区别？extern是真全局变量，可以在多个地方进行extern int a这样的声明，仅仅是声明，只可以在一个地方进行定义。只要声明了之后，就可以共享这个变量a。而static为只申请一次，然后一直存在，作用域内的地方可以一直使用它，而且值也不变，不会跟函数结束而被释放。同名会被作用域小的替代。 三、_cplusplus​ 它是个宏定义，表明当前是c++环境。结合使用，效果更佳 12345678&gt; #ifdef __cplusplus /* 如果采用了C++，如下代码使用C编译器 */&gt; extern &quot;C&quot;&#123;/* 如果没有采用C++，顺序预编译 */&gt; #endif&gt; /* 采用C编译器编译的C语言代码段 */&gt; #ifdef __cplusplus /* 结束使用C编译器 */&gt; &#125;&gt; #endif&gt;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT静态库与使用]]></title>
    <url>%2F2019%2F01%2F25%2FQT%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用静态库解决了我之前的共享库那篇文章下面那个问题！ 一、新建工程1. 新建Library\C++工程 2.选择共享库，设定路径 3.选择对应的模块，也可以在pro里面增加 二、工程介绍1.本工程没有main函数，可以归类为库。2.pro文件介绍需要debug版本的，手动增加，多了一条CONFIG+=staticlib 这里得知，告知编译器将编译出静态库 12345CONFIG+=debug_and_releaseCONFIG(debug,debug|release)&#123; unix:TARGET=$$join(TARGET,,,_debug) else:TARGET=$$join(TARGET,,,d)&#125; 3.主类或函数​ 可以看出，该类与普通类定义完全一样 5.编译完成​ 在windows平台下，会成生一个.a文件（我使用的是Mingw5.5.1，MSVC会生成.lib） 三、库的使用1.新建一个Application项目​ 右击工程，弹出，添加库，选择.a文件，设置见下图2 2. pro文件会发生变化​ INCLUDEPATH表示头文件的路径 ​ DEPENDPATH表示编译时依赖文件的路径 ​ 最好把 .h .a 放到与该工程下（该方法直接发布exe即可） 3.使用​ 包含.h头文件即可以正常使用函数或者类。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多域名指向GithubPage]]></title>
    <url>%2F2019%2F01%2F23%2F%E5%A4%9A%E5%9F%9F%E5%90%8D%E6%8C%87%E5%90%91GithubPage%2F</url>
    <content type="text"><![CDATA[域名1 bugnull.com 域名2 bugnull.cn 一、购买域名​ 如果没有域名都是白瞎！！这两个域名都是通过阿里云购买的，加起来80多块一年。淘到两个好域名，开心。 二、访问*.github.io​ 确保自己的 *.github.io可以访问。 1. 设置第一个域名​ 打开github的仓库，选择自己的github.io，点击设置，拉到下面的GithubPage，修改下面为下图2，因为Github更新的比较快，大家看情况设置。 2.域名解析​ 在Github仓库上，增加一个CNAME的文件，里面的内容为，例如我的，就填bugnull.com，仅此而已，连www也不需要，正是因为CNAME只支持一个域名，所以才有我东找西找的结果。 ​ 添加CNAME和A分别对应github.io和 github.io对应的ip地址 ​ 如果不知道对应的ip地址 使用cmd ping一下就可以看到了 ​ 如果准备做多个域名，在这里，顺便把其它的域名也加上A字段，填上个IP即可 3.第一个域名设置完成​ 此时等个几分钟，就可以使用第一个域名访问了 4.设置第二个或者更多个域名​ 写本文的目的从这里才开始，因为前面那几个网上多的是！ ​ 原理，Github上面每一个仓库都可以设置一个域名！利用这个特性，进行域名转跳！ 5.创建一个新的仓库​ 因为一个帐号只能有一个github.io仓库，所以这个仓库随便建，同样新建的仓库，设置。 6.添加文件​ 在新建的仓库新加404.html里面的内容为，你们的域名填写主域名！ ​ 再新建一个CNAME文件，里面的内容为你的副域名。到这里就设置完了，原理是GithubPage的仓库可独立域名和利用404报错页面进行转跳的。有点神奇吧！ 三、大概流程​ 在GithubPage上，设置域名，仓库上增加CNAME，云解析填上对应的解析。 ​ 多域名，利用404转跳，和Github仓库的强大作用。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT共享库与使用]]></title>
    <url>%2F2019%2F01%2F21%2FQT%E5%85%B1%E4%BA%AB%E5%BA%93%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[之前因为一些原因，需要将一些widget派生类封装成dll，给其它项目使用。研究了一下，首先，该widget派生类需要与使用类尽量没有关联。（当明有一个共用类，保存各种全局变量，里面有一个变量，与语言选择相关的，共享类也包含了该头文件，可是并没有获取到全局变量的值） 一、新建工程1. 新建Library\C++工程 2.选择共享库，设定路径 3.选择对应的模块，也可以在pro里面增加 二、工程介绍1.本工程没有main函数，可以归类为库。2.pro文件介绍​ 需要debug版本的，手动增加 12345CONFIG+=debug_and_releaseCONFIG(debug,debug|release)&#123; unix:TARGET=$$join(TARGET,,,_debug) else:TARGET=$$join(TARGET,,,d)&#125; 3.*_global.h介绍​ 下图1为_global.h的内容，下图2为实际Q_DECL_EXPORT和Q_DECL_IMPORT**的宏定义 4.主类或函数​ 定义前加上PUBLICSHARED_EXPORT即可，然后做自己想做的控件。 1234567PUBLICSHARED_EXPORT int max(int x,int y); //尽量不要使用这些c++或者qt库中带有的函数名，万不得已经在使用前加:表明命名空间类定义class PUBLICSHARED_EXPORT Public&#123;public: Public();&#125;; 5.编译完成​ 在windows平台下，会成生一个.a文件和一个.dll（我使用的是Mingw5.5.1，MSVC会生成.lib和.dll） 三、库的使用1.新建一个Application项目​ 右击工程，添加库，选择内部库，在库文件中选择.a或者.lib。看图说话- - 2. pro文件会发生变化​ INCLUDEPATH表示头文件的路径 ​ DEPENDPATH表示编译时依赖文件的路径 ​ 最好把 .h *_global.h .a .dll 放到与该工程下（该方法发布的时候需要把dll一起发布） ​ 3.使用​ 包含.h头文件即可以正常使用函数或者类。 4.注意​ 有一个全局变量Language表示当前界面显示的语言，由程序开启后第一时间读取配置文件，供全局使用。使用了上面的方法，生成共享库的时候在头文件也包含了该类。结果在使用的时候经调试发现，两者的Language为两个互不关联的变量。即数据不共享，通过信号槽或者函数调用可以达到共享。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT工程编译流程]]></title>
    <url>%2F2019%2F01%2F20%2FQT%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本章为简单介绍，qmake里面有大学问。 一、qmale 第一步是运行qmake，根据当前的项目工程，生成pro，然后运行qmake生成MakeFile文件（有时候，增加资源文件或者删除后，运行会警告缺失文件，执行一次qmake即可） 命令 qmake project.pro 生成pro 然后 qmake 生成MakeFile 二、构建 构建我理解为是编译，第二次执行只编译变化了的部分，一个一个生成.o和目标文件，最终生成exe 命令 mingw32-make、moc、uic、rcc moc.exe -o mclass.h moc_mclass.cpp 编译继承qt的类 uic.exe -o mclass.ui ui_mclass.h 将ui编译生成类 rcc.exe -o -no-compress my.qrc my.cpp 编译资源文件 重新构建 将所有部分重新编译 三、清除 只留下exe，其它文件都删掉(MakeFile会留下) 四、运行 根据已经存在的MakeFile进行编译，然后打开exe，如果MakeFile不存在才会重新执行qmake。（估计是这样才会导致我之前说的那个问题） （之前查了一下资料，发现QT Create运行程序和在资源管理器上双击打开程序的区别。QT Create上运行使用的库是当前设置好，准备编译该工程的库。而双击运行会去环境变量中找，导致两者使用的库不一致，所以有可能其中一方运行不起来而另外一方可以运行。）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集与字符编码]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[主要是总结，资料来源是网络，底部会把链接挂上。 一、名词解释 字符集 ：字符编码就是一个系统支持的所有抽象字符的集合，字符是各种文字和符号的总称。 字符编码 ：将符号转换为计算机可以接受的数字系统的规则，是符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。 编码 ：按照某种字符编码将字符存储在计算机中 解码 ：将存储在计算机中的二进制数解析出来 二、编码集 ASCII 美国最早推出，由一个字节表示，共128个，编码范围是0-127 ISO 由西欧国家对ASCII的扩展，增加到256个字符，ISO8859 GB2312 中国推出，完整保留ASCII，兼容约7000简体字、数学符号、罗马希腊字母、日本假名等。小于127的字符与ASCII对应，两个大于127的结合起来表示一个汉字。高位在0xA1到0xF7，低位在0xA1到0xFE，其中更包括ASCII就有的字符，但是这里为“全角”，小于127的称为“半角”。该编码称为GB2312 。 GBK 当时GB2312这并没有包括完整的中文，简体都没包括完整，繁体就更别说了。在这个前提下出现GBK 编码，把低位的0xA1不从0开始，这里就将繁体等字符加进来了，范围为0x8140至0xFEFE。向下与 GB 2312 编码兼容，向上支持 ISO，与 Unicode 组织的 Unicode 编码完全兼容。GB13000等同于ISO10646 GB18030 兼容GB2312，基本兼容GBK，支持GB13000及Unicode的全部统一汉字。编码与utf8相同，采用可变长度的编码，GB18030-2000为强制要求支持的版本，GB18030-2005为增加多种少数民族文字编码。 三、Unicode编码集与UTF8、UTF16、UTF32​ 单独总结Unicode，表示该编码的重要性。在计算机领域中，Unicode编码是业界的一种标准。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 ​ Unicode是字符集，UTF32、UTF16、UTF8是三种字符编码方案 。 Unicode字符集可以简写为UCS（Unicode Character Set），0x0000~0X00ff与ISO 8859-1保持一致 Unicode可以逻辑分为17平面（Plane），每个平面拥有65536（ 共1114112）个代码点，虽然目前只有少数平面被使用。 平面0 (0000–FFFF): 基本多文种平面（Basic Multilingual Plane, BMP）. 平面1 (10000–1FFFF): 多文种补充平面（SupplementaryMultilingual Plane, SMP）. 平面2 (20000–2FFFF): 表意文字补充平面（SupplementaryIdeographic Plane, SIP）. 平面3 (30000–3FFFF): 表意文字第三平面（TertiaryIdeographic Plane, TIP）. 平面4 to 13 (40000–DFFFF)尚未使用 平面14 (E0000–EFFFF): 特别用途补充平面（SupplementarySpecial-purpose Plane, SSP） 平面15 (F0000–FFFFF)保留作为私人使用区（PrivateUse Area, PUA） 平面16 (100000–10FFFF)，保留作为私人使用区（PrivateUse Area, PUA） 原文：https://blog.csdn.net/harrywater123/article/details/50738079 UTF8 是一种针对Unicode的可变长度字符编码，又称万国码， 用1到6个字节编码Unicode字符。 规则：如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的字节数，其余各字节均以10开头。 1.第一种是一个字节的编码：即128个ascii字符（只需要一个字节） 格式：0xxxxxxx 2^7 - 1 = 127 = 7F = (0111-1111) 编码方式Unicoe范围由(U+0000 至 U+007F) 2.第二种是两个字节的编码：即带有符号的拉丁文，希腊文，西里尔字母，亚美尼亚语，希伯来文，阿拉伯文等，则需要两个字节编码(Unicode 范围由U+0080至U+07FF) 格式：110xxxxx 10xxxxxx (0080)16 = (128)10 (07FF) 16 = (2047)10 = 2^11-1; 3.第三种是三字节的编码，即其他多文种平面(BMP)中的字符（这包括了大部分的汉字）（范围为: U+0800 至 U+FFFF） 格式：1110xxxx 10xxxxxx 10xxxxxx U+0800 = 2048； U+FFFF = 65535 = 2^16 -1； 1110xxxx 10xxxxxx 10xxxxxx 4.第四种是4-6字节编码。 U+1 0000至U+1 FFFFF：使用四字节 U+20 0000 至U+3FF FFFF：使用五字节 U+400 0000至U+7FFF FFFF UTF-8就是以8位为单元对UCS进行编码。从UCS-2到UTF-8的编码方式如下： UCS-2编码(16进制) 范围 UTF-8 字节流(二进制) 0000 - 007F 0 - 127 0xxxxxxx 0080 - 07FF 128-2047 110xxxxx 10xxxxxx 0800 - FFFF 2048-65535 1110xxxx 10xxxxxx 10xxxxxx 例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 目前计算机一般使用 2 个字节（16 位）来存放一个序号（DBCS,DoubleByte Character System），因此，这种方式存放的字符也被称作宽字节字符。比如，字符串”中文123” 在 Windows2000 下，内存中实际存放的是 5 个字符，一共10个字节；若在gb2312编码中，共计五个字符，7个字节。 原文：https://blog.csdn.net/harrywater123/article/details/50738079 优点，可变长度编码，对于常用的ASCII字符，只需要用一位编码即可，多字节的字符使用频率很低，节省了存储空间。 缺点，无法判断UTF8的字节数，较多 10xxxxxx 网络传输会产生错误。 UTF16 将0–65535范围内的字符编码成2个字节，空间利用率比UTF32高两倍 如果字符编码U小于0x10000，也就是十进制的0到65535之内，则直接使用两字节表示； 如果字符编码U大于0x10000，由于UNICODE编码范围最大为0x10FFFF，从0x10000到0x10FFFF之间 共有0xFFFFF个编码，也就是需要20个bit就可以标示这些编码。用U’表示从0-0xFFFFF之间的值，将其前 10 bit作为高位和16 bit的数值0xD800进行 逻辑or 操作，将后10 bit作为低位和0xDC00做 逻辑or 操作，这样组成的 4个byte就构成了U的编码。 UTF32 使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。可以在常数时间内定位字符。 四、BOM​ Unicode编码标准中用于标识文件是采用哪种格式的编码。 ​ BOM —— Byte Order Mark，中文名译作“字节顺序标记” ​ UTF8不需要表明字节顺序，但是可以用BOM来表明编码方式。字符 “Zero Width No-Break Space” 的 UTF-8 编码是 EF BB BF。所以如果接收者收到以 EF BB BF 开头的字节流，就知道这是 UTF-8编码了。Windows 就是使用 BOM 来标记文本文件的编码方式的。 ​ 在保存一个以编utf8码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。在保存一个以utf8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。 编码 表示 (十六进制) 表示 (十进制) utf8 EF BB BF 239 187 191 utf16 大端 FE FF 254 255 utf16 小端 FF FE 255 254 utf32 大端 00 00 FE FF 0 0 254 255 utf32 小端 FF FE 00 00 255 254 0 0 iso8859-1 ​ 最早的编码是iso8859-1，和ascii编码相似。但为了方便表示各种各样的语言，逐渐出现了很多编码。iso8859-1属于单字节编码，最多能表示的字符范围是0-255，应用于英文系列。比如，字母a的编码为0x61=97。很明显，iso8859-1表示的字符范围很窄，无法表示中文字符。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用iso8859-1编码来表示。而且在很多协议上，默认使用该编码。比如，虽然”中文”两个字不存在iso8859-1编码，以gb2312编码为例，应该是”d6d0 cec4”两个字符，使用iso8859-1编码的时候则将它拆开为4个字节来表示：”d6 d0 ce c4”（事实上，在进行存储的时候，也是以字节为单位处理的）。而如果是UTF编码，则是6个字节”e4 b8 ad e6 96 87”。很明显，这种表示还需要以另一种编码为基础。 汉字编码: * GB2312字集是简体字集，全称为GB2312(80)字集，共包括国标简体汉字6763个。 * BIG5字集是台湾繁体字集，共包括国标繁体汉字13053个。 * GBK字集是简繁字集，包括了GB字集、BIG5字集和一些符号，共包括21003个字符。 * GB18030是国家制定的一个强制性大字集标准，全称为GB18030-2000，它的推出使汉字集有了一个“大一统”的标准。 UCS:通用字符集(Universal Character Set，UCS)是由ISO制定的ISO 10646(或称ISO/IEC 10646)标准所定义的字符编码方式，采用4字节编码。UCS包含了已知语言的所有字符。除了拉丁语、希腊语、斯拉夫语、希伯来语、阿拉伯语、亚美尼亚语、格鲁吉亚语，还包括中文、日文、韩文这样的象形文字，UCS还包括大量的图形、印刷、数学、科学符号。​ * UCS-2: 与unicode的2byte编码基本一样。​ * UCS-4: 4byte编码, 目前是在UCS-2前加上2个全零的byte。 MIME： 通用因特网邮件扩充协议，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。 因为在因特网上邮件发送协议SMTP存在几个缺点，主要是不能发送可执行文件和其他的二进制文件，只限于传送7位的ASCII码，因此MIME协议起初用于解决该问题，即是在传送二进制数据时先通过MIME转换成SMTP可传送的ACSII码，接收时再通过MIME还原成原始的二进制码。为此SMTP也响应增加了MIME-version、content-type等5个新的首部。 其中首部Content-transfer-encoding的值有5种—-“7bit”、”8bit”、”binary”、”quoted-printable”和”base64”—-其中”7bit”是缺省值，即不用转化的ASCII字符。真正常用是“quoted-printable”和”base64”两种，用以指明编码转换的方式。 MIME_type类型语法： media-type=type/subtype​ 媒体类型(type)与子类型(subtype)组成了MIME，它们之间使用反斜杠/分割，其中type可取值为：application audio example image message model multipart text video，subtype是某种类型的唯一标识符，比如：css gif xml等。常见的MIME类型： 超文本标记语言文本 .html,.html text/html普通文本 .txt text/plainRTF文本 .rtf application/rtfGIF图形 .gif image/gifJPEG图形 .ipeg,.jpg image/jpegau声音文件 .au audio/basicMIDI音乐文件 mid,.midi audio/midi,audio/x-midiRealAudio音乐文件 .ra,.ram audio/x-pn-realaudioMPEG文件 .mpg,.mpeg video/mpegAVI文件 .avi video/x-msvideoGZIP文件 .gz application/x-gzipTAR文件 .tar application/x-tar quoted-printable： 主要用于ACSII文本中夹杂少量非ASCII码字符的情况，不适合于转换纯二进制文件。它规定将每一个8位的字节，转换为3个字符。第一个字符是”=”号，这是固定不变的。 后面二个字符是二个十六进制数，分别代表了这个字节前四位和后四位的数值。举例来说，ASCII码中”换页键”（form feed）是12，二进制形式是00001100，写成十六进制就是0C，因此它的编码值为”=0C”。”=”号的ASCII值是61，二进制形式是00111101，因为它的编码值是”=3D”。除了可打印的ASCII码以外，所有其他字符都必须用这种方式进行转换。 所有可打印的ASCII码字符（十进制值从33到126）都保持原样不变，”=”（十进制值61）除外。 base64： ​ 所谓Base64，就是说选出64个字符—-小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“（再加上作为垫字的”=”，实际上是65个字符）—-作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。具体来说，转换方式可以分为四步： 第一步，将每三个字节作为一组，一共是24个二进制位。 第二步，将这24个二进制位分为四组，每个组有6个二进制位。 第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节。 第四步，根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值。 如果字节数不足三，则这样处理： a）二个字节的情况：将这二个字节的一共16个二进制位，按照上面的规则，转成三组，最后一组除了前面加两个0以外，后面也要加两个0。这样得到一个三位的Base64编码，再在末尾补上一个”=”号。比如，”Ma”这个字符串是两个字节，可以转化成三组00010011、00010110、00010000以后，对应Base64值分别为T、W、E，再补上一个”=”号，因此”Ma”的Base64编码就是TWE=。 b）一个字节的情况：将这一个字节的8个二进制位，按照上面的规则转成二组，最后一组除了前面加二个0以外，后面再加4个0。这样得到一个二位的Base64编码，再在末尾补上两个”=”号。比如，”M”这个字母是一个字节，可以转化为二组00010011、00010000，对应的Base64值分别为T、Q，再补上二个”=”号，因此”M”的Base64编码就是TQ==。 参考与引用： 十分钟搞清字符集和字符编码 浅谈编码集 字符集和字符编码（Charset &amp; Encoding）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QTCP与断线重连]]></title>
    <url>%2F2019%2F01%2F16%2FQTCP%E4%B8%8E%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E%2F</url>
    <content type="text"><![CDATA[先简单介绍一下QTcpSocket上面常用的几个信号与函数 信号名 触发条件 connected() 连接成功时 disconnected() 断开连接时 error(QAbstractSocket::SocketError socketError) 产生错误时，附带错误码 hostFound() 调用connectToHost，并且找到主机后发出，还没连接上 proxyAuthenticationRequired(const QNetworkProxy &amp; proxy, QAuthenticator * authenticator) This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection. stateChanged(QAbstractSocket::SocketState socketState) 连接状态发生改变时，会发出，附带当前状态的状态码 常用函数 简介 connectToHost 连接 disconnectFromHost 断开连接，会等待数据发送完毕 abort 立即断开，丢弃数据 state 查看当前socket的状态 error 查看当前socket的错误 close 关闭包括（I/O设备，连接，socket，重置各种数据） waitForConnected 阻塞，等待连接，连接成功发出true，超时发出false waitForReadyRead 阻塞，等待数据和readyRead信号，超时反回false waitForBytesWritten 阻塞，至少写入一个字节和发出byteswrite信号后才发出true，超时发出false waitForDisconnected 阻塞，等待断开，断开成功发出true，超时发出false read 读取，可以每次读取一定量的数据 readLine 读取一行数据 readAll 读取缓冲区所有数据 write 写入数据 断线重连机制原理​ 下面两种方法原理其实都一样，检查socket的状态，如果是断开，开启重新连接机制，连接成功，关掉机制。 一、使用定时器 基于QTcpSocket的派生类，信号和槽在构造函数中连接 在定时器的timeout信号触发时，对应的槽函数处理为 12345if( 判断当前socket的状态，没有连接上 )&#123; socket连接&#125;else &#123; 定时器stop&#125; 在socket的disconnected信号发出时，对应的槽函数处理为 123abort();disconnectFromHost();定时器启动 缺点是与当前线程占相同的资源，优点个人感觉实现起来非常简单。 二、使用线程 基于QThread的派生类，信号和槽，socket创建，需要在调用线程start前创建好 在线程的run方法中，处理如下， 12345678910while(threadRun)&#123; if( socket没有连接上 )&#123; connectToHost; waitForConnected(); 连接并产生阻塞，退出当前线程 &#125; if( socket没有连接上 )&#123; continue; &#125; waitForReadyRead(); 来到这里表示socket连接成功，产生阻塞，等待数据到来&#125; 因为socket的处理是在新的线程中运行，接收到数据需要发送到主线程中，readyRead对应的槽函数处理为 1234while( bytesAvailable()&gt;0 )&#123; byteArray=readAll(); emit signalReadyRead(byteArray);&#125;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT信号槽]]></title>
    <url>%2F2019%2F01%2F15%2FQT%E4%BF%A1%E5%8F%B7%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[个人使用过的信号槽的连接方式有三种，需要产生信号的类需要在类定义中加入Q_OBJECT，并且重新执行qmake 1.QT4信号槽12345678910111213141516171819202122connect(sender,SIGNAL(),receiver,SLOT());分别为发送信号的类，对应的信号，接收信号的类，处理信号的槽关于SIGNAL和SLOT，其实是qt的两个宏定义Q_CORE_EXPORT const char *qFlagLocation(const char *method);#ifndef QT_NO_META_MACROS#ifndef QT_NO_DEBUG# define QLOCATION "\0" __FILE__ ":" QT_STRINGIFY(__LINE__)# ifndef QT_NO_KEYWORDS# define METHOD(a) qFlagLocation("0"#a QLOCATION)# endif# define SLOT(a) qFlagLocation("1"#a QLOCATION)# define SIGNAL(a) qFlagLocation("2"#a QLOCATION)#else# ifndef QT_NO_KEYWORDS# define METHOD(a) "0"#a# endif# define SLOT(a) "1"#a# define SIGNAL(a) "2"#a#endif 2.QT5信号槽1234connect(sender,&amp;senderClassName::functionName,receiver,&amp;receiverClassName::function);因为会进行错误检查，而qt4不会，从上面可以得知，qt4信号槽的参数只是字符串。但是对于信号重载的处理比较麻烦，qt4只需要在signals里面使用()括上参数即可，而qt5需要进行强制转换。static_cast&lt;void (className::*)(parameter)&gt;(&amp;className::functionName) 3.信号与Lamda表达式结合1234567891011connect(sender,&amp;senderClassName::functionName,[=]( //parameter )&#123; //slove &#125;);[] 捕捉列表 [] 不捕获任何值 [var1,var2...] 在函数里，捕获var1,var2的值 [&amp;var1,&amp;var2...] 捕获var1,var2的引用对象 [=] 捕获所有外部变量的值 [&amp;] 捕获所有外部变量的引用() 参数 mutable 可以修改捕捉值，但是值本身不会发生改变&#123;&#125; 处理 4.隐藏的第五个参数 Constant Value Description Qt::AutoConnection 0 (默认)如果发送和接收都在同一个线程，使用Qt::DirectConnection，否则使用Qt::QueuedConnection。类型是在信号发送时才确定的 Qt::DirectConnection 1 收到信号后，马上即行 Qt::QueuedConnection 2 保存在一个队列中，当接收事件循环启动时，执行槽函数 Qt::BlockingQueuedConnection 3 与Qt::QueuedConnection类似，但是运行槽函数时，会阻塞信号线程。发送与接收不可以在同一线程，会造成死锁 Qt::UniqueConnection 0x80 可以使用OR实现多种参数连接，但是如果已经存在相同的connect时，会失败。 注意，使用连接时，需要考虑之前是否有连接，因为重新连接了相同的信号与槽，发出一个信号后，会多次触发槽函数，非常浪费资源！！ 补充介绍disconnec的使用 12345disconnect(sender,信号，receiver,槽);其中，信号、receiver、槽都可以为0(0表示任意所有) sender不能为0例1、sender多个不同的信号与receiver的一个槽绑定，参数可以这样写，（sender,0,receiver,槽）例2、sender多个信号与receiver的多个槽绑定了，（sender,0,receiver,0）例3、sender多个信号与多个receiver的多个槽绑定了，（sender,0,0,0）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型转换]]></title>
    <url>%2F2019%2F01%2F15%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在使用这一段时间中，数据类型太多了，很多都需要转换。本章为总结。 C++强制转换有四种1234static_cast&lt;&gt;()dynamic_cast&lt;&gt;()const_cast&lt;&gt;()reinterpret_cast&lt;&gt;() static_cast 基本数据的转换、空指针与指针之间的转换 目前使用于信号槽函数强制转换，基于QT5的新特性，在使用connect时，第二第四个参数产生的为&amp;className::functionName，如果函数被重载了，QT无法判断需要使用哪个信号，即使你的槽函数设置对应的参数，这里需要对第二个参数进行强制转换，如下。 static_cast&lt;void (className::*)(parameter)&gt;(&amp;className::functionName)这样可以将函数进行强制转换，解决信号定位的问题。 dynamic_cast&lt;&gt;() 类的下行转换，由基数向派生类转换 目前没有使用过 const_cast&lt;&gt;() 去掉const或者volatile属性 12const char *cstr="rts";char *str=const_cast&lt;char *&gt;(cstr); reinterpret_cast&lt;&gt;() 主要将数据从一种类型转换为另一种类型，二进制的形式重新解释 在使用windows api的时候，需要使用宽字符wcahr_t，而qt里面没有原这样的类型，但是qstring有转换成宽字符的函数，操作如下 12QString str;reinterpret_cast&lt;const wchar_t *&gt;(str.utf16()); 百度百科介绍，static_cast进行类的转换，会进行实际的偏移，而reinterpret_cast不会 qobject_cast(QObject *object) 该转换只适用于继承自object的派生类，且类中带有Q_OBJECT宏声明。 用于将一个QObject对象转换为对应的派生类，如果类型不符合，则转换为0； sender为槽对象，默认是QObject类型 在这里，如果有多个不同的信号对应同一个槽，可以根据该转换来判断传递对象的类型，像这里，如果sender是QLabel则会转换成功，否则为空 1qobject_cast&lt;QLabel *&gt;(sender())；]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo建站小结]]></title>
    <url>%2F2019%2F01%2F06%2FHexo%E5%BB%BA%E7%AB%99%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[搭建工作下载安装 node.js 和 git 默认安装即可安装成功后，右击系统菜单键会多出两项 在系统盘上，找个地方，如D:/github/ 进入到文件夹，右击，点击Git Bash Here 安装Hexo12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 意思分别为 安装hexo hexo在blog文件夹初始化，不需要手动创建 (blog可以改变，只是一个文件夹名字) 进入blog文件夹 安装扩展插件 开启服务，此时在浏览器输入http://localhost:4000/ 或者 http://127.0.0.1:4000 可以看到相关页面（ctrl+c退出） Hexo常用命令123456hexo generate (hexo g) 编译生成hexo server (hexo s) 启动服务hexo deploy (hexo d) 上传hexo new page &quot;p&quot; 生成一个p页面 hexo new &quot;p&quot; 生成一个标题为p的新文章hexo clean 清除编译生成 Hexo还有很多插件，如果下面使用过程中发现问题，可以百度查找，安装对应的插件创建一个Github代码仓库 如果没有帐号，需要注册一个 点击在网页右上角，选择新建仓库 仓库的Repository name为仓库名，格式有规定，如果你注册的github帐户名为orz，那么这里就要填orz.github.io，其它设置看介绍，创建仓库 添加SSH数据提交这里选择SSH，下面是SSH安装与Github绑定SSH安装1234567ls ~/.ssh检查是否安装了ssh，如果有id_rsa.pub，跳过下面步骤ssh-keygen -t rsa -C &quot;邮箱地址&quot;安装的时候，连续点击三次回车，分别是跳过文件夹和把密码设置为空pwd ~/.ssh查看ssh的安装路径 绑定 找到ssh/id_rsa.pub，打开，复制全部内容 打开github网站，选择SSH and GPG keys New SSH Key标题随便写，将复制的内容写到Key里面，添加 验证是否连通 输入 ssh -T git@github.com如果看到你在github注册的帐号名，即表示成功 初始化设置打开D:/github/blog/_config.yml 1234deploy: type: git repo: branch: master rope的值参考下图 点击Clone or download弹出的链接 写入到_config.yml的rope 注意和：有一个空格，不能少 主题设置从网上查找Hexo主题，下载放到D:/github/blog/themes里面。打开D:/github/blog/_config.yml将theme：改为刚刚下载的主题文件夹名。其余设置需要参考主题的介绍 纸上得来终觉㳀，绝知此事要躬行]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
