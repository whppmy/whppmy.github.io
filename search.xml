<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[17.官方示例提取帧运动矢量简析]]></title>
    <url>%2F2019%2F12%2F27%2F17-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E6%8F%90%E5%8F%96%E5%B8%A7%E8%BF%90%E5%8A%A8%E7%9F%A2%E9%87%8F%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718//extract_mvs.cavformat_open_input();//打开封装上下文avformat_find_stream_info();//读取封装上下文的流信息open_codec_context();//从ctx中找出stream codecCtx codecav_dump_format();//输出封装信息av_frame_alloc();//申请framewhile (av_read_frame(fmt_ctx, &amp;pkt) &gt;= 0) &#123;//读取一个Pkt if (pkt.stream_index == video_stream_idx) ret = decode_packet(&amp;pkt);//解码 av_packet_unref(&amp;pkt);//释放 if (ret &lt; 0) break;&#125;decode_packet(NULL);//缓存avcodec_free_context();//释放codecCtxavformat_close_input();//释放ctxav_frame_free();//释放frame 123456789101112131415161718192021222324252627282930313233343536static int open_codec_context(AVFormatContext *fmt_ctx, enum AVMediaType type)&#123; int ret; AVStream *st; AVCodecContext *dec_ctx = NULL; AVCodec *dec = NULL; AVDictionary *opts = NULL; ret = av_find_best_stream(fmt_ctx, type, -1, -1, &amp;dec, 0);//找出流index和编码器 if (ret &lt; 0) &#123; fprintf(stderr, "Could not find %s stream in input file '%s'\n", av_get_media_type_string(type), src_filename);//返回AVMediaType的描述 return ret; &#125; else &#123; int stream_idx = ret; st = fmt_ctx-&gt;streams[stream_idx]; dec_ctx = avcodec_alloc_context3(dec);//申请编码上下文 if (!dec_ctx) &#123; return AVERROR(EINVAL); &#125; ret = avcodec_parameters_to_context(dec_ctx, st-&gt;codecpar);//根据codecpar的值填充ctx内 if (ret &lt; 0) &#123; return ret; &#125; av_dict_set(&amp;opts, "flags2", "+export_mvs", 0);//修改AVDictionary参数 因都是私有 需要通过函数修改 if ((ret = avcodec_open2(dec_ctx, dec, &amp;opts)) &lt; 0) &#123;//将dec和ctx绑定 fprintf(stderr, "Failed to open %s codec\n", av_get_media_type_string(type)); return ret; &#125; video_stream_idx = stream_idx; video_stream = fmt_ctx-&gt;streams[video_stream_idx]; video_dec_ctx = dec_ctx; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static int decode_packet(const AVPacket *pkt)&#123; int ret = avcodec_send_packet(video_dec_ctx, pkt);//将压缩包交给解码器 if (ret &lt; 0) &#123; return ret; &#125; while (ret &gt;= 0) &#123; ret = avcodec_receive_frame(video_dec_ctx, frame);//从解码器中返回数据 if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) &#123;//输入错误 或者已经解码缓存中所有数据 break; &#125; else if (ret &lt; 0) &#123; return ret; &#125; if (ret &gt;= 0) &#123; int i; AVFrameSideData *sd;//保存AVFrame边缘的数据 video_frame_count++; sd = av_frame_get_side_data(frame, AV_FRAME_DATA_MOTION_VECTORS);//从frame中取出运动矢量数据 保存在sd if (sd) &#123; const AVMotionVector *mvs = (const AVMotionVector *)sd-&gt;data;//转成运动矢量 for (i = 0; i &lt; sd-&gt;size / sizeof(*mvs); i++) &#123;//mvs是AVMotionVector数组指针 mv是一个数据指针 const AVMotionVector *mv = &amp;mvs[i];//取出一组数据 printf("%d,%2d,%2d,%2d,%4d,%4d,%4d,%4d,0x%"PRIx64"\n", video_frame_count, mv-&gt;source, mv-&gt;w, mv-&gt;h, mv-&gt;src_x, mv-&gt;src_y, mv-&gt;dst_x, mv-&gt;dst_y, mv-&gt;flags); &#125; &#125; av_frame_unref(frame);//清掉frame缓存 &#125; &#125; return 0;&#125;/*struct p &#123; p(int aa,int bb):a(aa),b(bb)&#123;&#125; int a; int b;&#125;;p aa[]=&#123; p&#123; 1,2 &#125;, p&#123; 2,3 &#125;, p&#123; 3,4 &#125;&#125;;p * pa = aa;//pa即mvsfor (int i = 0; i &lt; sizeof(aa) / sizeof(*pa); i++) &#123; p *PPA = &amp;pa[i];//取出一个 &amp;pa[i]==pa+i QMessageBox::about(nullptr, "", QString("%1 %2").arg(PPA-&gt;a).arg( PPA-&gt;b));&#125; */]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16.官方示例解码音视频简析]]></title>
    <url>%2F2019%2F12%2F27%2F16-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E7%A0%81%E9%9F%B3%E8%A7%86%E9%A2%91%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334static void decode(AVCodecContext *dec_ctx, AVFrame *frame, AVPacket *pkt, const char *filename)&#123; char buf[1024]; int ret; ret = avcodec_send_packet(dec_ctx, pkt);//将ctx中的一些字段保存到解码器中 去解码pkt if (ret &lt; 0) &#123; exit(1); &#125; while (ret &gt;= 0) &#123; ret = avcodec_receive_frame(dec_ctx, frame);//返回解码后的数据到frame if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) return; else if (ret &lt; 0) &#123; exit(1); &#125; /*video printf("saving frame %3d\n", dec_ctx-&gt;frame_number); fflush(stdout); for (i = 0; i &lt; frame-&gt;height; i++) fwrite(frame-&gt;data[0] + i * frame-&gt;linesize[0], 1, frame-&gt;width, f); */ /*audio: data_size = av_get_bytes_per_sample(dec_ctx-&gt;sample_fmt);//每个样本的字节数 if (data_size &lt; 0) &#123; exit(1); &#125; for (i = 0; i &lt; frame-&gt;nb_samples; i++) for (ch = 0; ch &lt; dec_ctx-&gt;channels; ch++) fwrite(frame-&gt;data[ch] + data_size*i, 1, data_size, f); */ &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @file * audio decoding with libavcodec API example * * @example decode_audio.c */av_packet_alloc();//分配并初始化pktavcodec_find_decoder();//根据id找一个解码器codecav_parser_init();//根据编码器id返回一个解析器上下文parserctxavcodec_alloc_context3();//根据codec分配ctxavcodec_open2();//用编码器打开上下文data = inbuf;//一个数组data_size = fread(inbuf, 1, AUDIO_INBUF_SIZE, f);while (data_size &gt; 0) &#123; if (!frame) &#123; if (!(frame = av_frame_alloc())) &#123;//分配和初始化完整包 exit(1); &#125; &#125; ret = av_parser_parse2(parser, c, &amp;pkt-&gt;data, &amp;pkt-&gt;size,data, data_size, AV_NOPTS_VALUE, AV_NOPTS_VALUE, 0);//从上下文中解析一个压缩包 if (ret &lt; 0) &#123; exit(1); &#125; data += ret;//指针移动 data_size -= ret;//缓存数量减少 if (pkt-&gt;size) decode(c, frame, pkt, outfile);//解码 并写到文件中去 if (data_size &lt; AUDIO_REFILL_THRESH) &#123;//若数据少于AUDIO_REFILL_THRESH，就去文件中读取缺少的部分 直到达到AUDIO_INBUF_SIZE memmove(inbuf, data, data_size);//将inbuf内容变为由data开始 连续data_size data = inbuf; len = fread(data + data_size, 1,AUDIO_INBUF_SIZE - data_size, f); if (len &gt; 0) data_size += len; &#125;&#125;pkt-&gt;data = NULL;pkt-&gt;size = 0;decode(c, frame, pkt, outfile);//有可能文件没解析完avcodec_free_context();//关闭编码器上下文av_parser_close();//关闭解析器av_frame_free();//释放帧av_packet_free();//释放压缩包 1234567891011121314151617181920212223242526272829303132333435/** * @file * video decoding with libavcodec API example * * @example decode_video.c */av_packet_alloc();//初始化pktmemset(inbuf + INBUF_SIZE, 0, AV_INPUT_BUFFER_PADDING_SIZE);//初始化缓存数组 防止越界avcodec_find_decoder();//查找一个解码器 codecav_parser_init();//初始化parseravcodec_alloc_contex3();//初始化ctxav_frame_alloc();//初始化framewhile (!feof(f)) &#123; data_size = fread(inbuf, 1, INBUF_SIZE, f); if (!data_size) break; data = inbuf; while (data_size &gt; 0) &#123; ret = av_parser_parse2(parser, c, &amp;pkt-&gt;data, &amp;pkt-&gt;size, data, data_size, AV_NOPTS_VALUE, AV_NOPTS_VALUE, 0);//根据parser拆分一个压缩包 if (ret &lt; 0) &#123; exit(1); &#125; data += ret; data_size -= ret; if (pkt-&gt;size) decode(c, frame, pkt, outfilename); &#125;&#125;decode(c, frame, NULL, outfilename);//缓存av_parser_close();avcodec_free_context();av_frame_free();av_packet_free();]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15.官方示例AVIO读取源码简析]]></title>
    <url>%2F2019%2F12%2F27%2F15-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8BAVIO%E8%AF%BB%E5%8F%96%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1234567891011//avio_dir_cmd.cav_log_set_level();//设置日志等级avformat_network_init();//GnuTLS和OpenSSL的线程安全考虑 否则就不需要再使用avpriv_io_move();//移动或者重名avpriv_io_delete();//删除avio_open_dir();//打开目录avio_read_dir();//从目录读取一个条目avio_free_directory_entry();//关闭条目avformat_network_deinit();//有avformat_network_init必须有这个进行关闭 12345678910111213141516171819202122232425262728293031323334353637383940/** * @file * libavformat AVIOContext API example. * * Make libavformat demuxer access media content through a custom * AVIOContext read callback. * @example avio_reading.c */av_file_map();//读取文件到buffer和buffersizeavformat_alloc_context();//分配和初始化封装上下文ctxav_malloc();//申请一块空间得到ctxbuffer//bd结构体 包含buffer和buffersizeavio_alloc_context(ctxbuffer, ctxbuffersize,0, &amp;bd, &amp;read_packet, NULL, NULL);//为比特流上下文申请空间 得到avio_ctxctx-&gt;pb = avio_ctx;avformat_open_input();//打开流avformat_find_stream_info();//读文件流信息av_dump_format();//打印封装上下文avformat_close_input();//关闭封装上下文并指为NULLav_freep();//av_malloc()av_context_free();//关闭比特流上下文av_file_unmap();//av_file_map()static int read_packet(void *opaque, uint8_t *buf, int buf_size)//从opaque中读取buf_size长的数据保存在buf&#123; struct buffer_data *bd = (struct buffer_data *)opaque; buf_size = FFMIN(buf_size, bd-&gt;size); if (!buf_size) return AVERROR_EOF; printf("ptr:%p size:%zu\n", bd-&gt;ptr, bd-&gt;size); /* copy internal buffer data to buf */ memcpy(buf, bd-&gt;ptr, buf_size); bd-&gt;ptr += buf_size; bd-&gt;size -= buf_size; return buf_size;&#125;]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14.官方示例编码音视频简析]]></title>
    <url>%2F2019%2F12%2F26%2F14-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E7%BC%96%E7%A0%81%E9%9F%B3%E8%A7%86%E9%A2%91%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526encode(AVCodecContext *enc_ctx, AVFrame *frame, AVPacket *pkt,FILE *outfile)&#123; int ret; /* send the frame to the encoder */ if (frame) printf("Send frame %3"PRId64"\n", frame-&gt;pts); ret = avcodec_send_frame(enc_ctx, frame); if (ret &lt; 0) &#123; fprintf(stderr, "Error sending a frame for encoding\n"); exit(1); &#125; while (ret &gt;= 0) &#123; ret = avcodec_receive_packet(enc_ctx, pkt); if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) return; else if (ret &lt; 0) &#123; fprintf(stderr, "Error during encoding\n"); exit(1); &#125; printf("Write packet %3"PRId64" (size=%5d)\n", pkt-&gt;pts, pkt-&gt;size); fwrite(pkt-&gt;data, 1, pkt-&gt;size, outfile); av_packet_unref(pkt); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @file * audio encoding with libavcodec API example. * * @example encode_audio.c */avcodec_find_encoder();//查找一个编码器encodecavcodec_alloc_contex3();//根据编码器 申请一个编码上下文ctxctx-&gt;bit_rate;ctx-&gt;sample_fmt;//根据encodec-&gt;sample_fmts查看是否支持ctx-&gt;sample_rate;//根据encodec-&gt;supported_samplerates找一个最适合的ctx-&gt;channel_layout;//根据const uint64_t *p=encodec-&gt;channel_layouts av_get_channel_layout_nb_channels(*p)找最大的通道ctx-&gt;channels;//av_get_channel_layout_nb_channels(ctx-&gt;channel_layout)avcodec_open2();//打开编码器与上下文绑定av_packet_alloc();//分配并初始化一个pktav_frame_alloc();//分配并初始化一个frameframe-&gt;nb_samples=ctx-&gt;frame_size;frame-&gt;format=ctx-&gt;ctx-&gt;sample_fmt;frame-&gt;channel_layout=ctx-&gt;channel_layout;av_frame_get_buffer();//为frame分配buff空间av_frame_make_writable();//确定帧是可写的/ *以每秒110Hz增加频率tincr = 2 * M_PI * 110.0 / c-&gt; sample_rate; tincr2 = 2 * M_PI * 110.0 / c-&gt; sample_rate / c-&gt; sample_rate; 填充一段正弦波*/t = 0;tincr = 2 * M_PI * 440.0 / ctx-&gt;sample_rate;for (i = 0; i &lt; 200; i++) &#123; ret = av_frame_make_writable(frame); if (ret &lt; 0) exit(1); samples = (uint16_t*)frame-&gt;data[0]; for (j = 0; j &lt; c-&gt;frame_size; j++) &#123; samples[2 * j] = (int)(sin(t) * 10000); for (k = 1; k &lt; c-&gt;channels; k++) samples[2 * j + k] = samples[2 * j]; t += tincr; &#125; encode(ctx, frame, pkt, f);//avcodec_send_frame avcodec_receive_packet av_packet_unref&#125;encode(ctx, NULL, pkt, f);av_frame_free();//释放freamav_packet_free();//释放pktavcodec_free_contex();//释放编码上下文 123456789101112131415161718192021222324252627282930313233/*** @file* video encoding with libavcodec API example** @example encode_video.c*/avcodec_find_encoder_by_name();//根据名字查找编码器encodecavcodec_alloc_context3();//根据编码器 申请编码上下文ctxav_packet_alloc();//分配pktctx-&gt;bit_rate;ctx-&gt;width;ctx-&gt;height;ctx-&gt;time_base;//AVRational&#123;1,25&#125; fps25ctx-&gt;framerate;//AVRational&#123;25,1&#125;ctx-&gt;gop_size;//多久一个关键帧ctx-&gt;max_b_frames;//最多b帧ctx-&gt;pix_fmt;//帧格式if (codec-&gt;id == AV_CODEC_ID_H264) av_opt_set(ctx-&gt;priv_data, "preset", "slow", 0);/*AVOption除了可以对常用的结构体AVFormatContext、AVCodecContext等进行设置之外，还可以对它们的私有数据priv_data进行赋值。这些字段里面通常存储了各种编码器特有的结构体。如使用libx264进行编码的时候，通过AVCodecContext的priv_data字段可以对X264Context（libavcodec\libx264.c）结构体中的变量进行赋值，设置preset、profile等*/avcodec_open2();//打开编码器与上下文绑定av_frame_alloc();//初始化frameframe-&gt;format=ctx-&gt;pix_fmt;frame-&gt;width=ctx-&gt;width;frame-&gt;height=ctx-&gt;height;av_frame_get_buffer();//为frame申请内部空间av_frame_make_writable();//确定帧是可写的填满frame-&gt;data;encodec();avcodec_free_context();av_frame_free();av_packet_free();]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13.官方示例解复用和解编码.c]]></title>
    <url>%2F2019%2F12%2F25%2F13-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%92%8C%E8%A7%A3%E7%BC%96%E7%A0%81-c%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363extern "C" &#123;#include &lt;libavutil/imgutils.h&gt;#include &lt;libavutil/samplefmt.h&gt;#include &lt;libavutil/timestamp.h&gt;#include &lt;libavformat/avformat.h&gt;&#125;static AVFormatContext *fmt_ctx = NULL;static AVCodecContext *video_dec_ctx = NULL, *audio_dec_ctx;static int width, height;static enum AVPixelFormat pix_fmt;static AVStream *video_stream = NULL, *audio_stream = NULL;static const char *src_filename = NULL;static const char *video_dst_filename = NULL;static const char *audio_dst_filename = NULL;static FILE *video_dst_file = NULL;static FILE *audio_dst_file = NULL;static uint8_t *video_dst_data[4] = &#123; NULL &#125;;static int video_dst_linesize[4];static int video_dst_bufsize;static int video_stream_idx = -1, audio_stream_idx = -1;static AVFrame *frame = NULL;static AVPacket pkt;static int video_frame_count = 0;static int audio_frame_count = 0;/* Enable or disable frame reference counting. You are not supposed to support* both paths in your application but pick the one most appropriate to your* needs. Look for the use of refcount in this example to see what are the* differences of API usage between them. */static int refcount = 0;static int decode_packet(int *got_frame, int cached)&#123; int ret = 0; int decoded = pkt.size; *got_frame = 0; if (pkt.stream_index == video_stream_idx) &#123; /* decode video frame */ ret = avcodec_decode_video2(video_dec_ctx, frame, got_frame, &amp;pkt);//解码帧 已经弃用不再维护 if (ret &lt; 0) &#123; fprintf(stderr, "Error decoding video frame (%s)\n", av_err2str(ret)); return ret; &#125; if (*got_frame) &#123; if (frame-&gt;width != width || frame-&gt;height != height || frame-&gt;format != pix_fmt) &#123;//帧大小不对 /* To handle this change, one could call av_image_alloc again and * decode the following frames into another rawvideo file. */ fprintf(stderr, "Error: Width, height and pixel format have to be " "constant in a rawvideo file, but the width, height or " "pixel format of the input video changed:\n" "old: width = %d, height = %d, format = %s\n" "new: width = %d, height = %d, format = %s\n", width, height, av_get_pix_fmt_name(pix_fmt), frame-&gt;width, frame-&gt;height, av_get_pix_fmt_name(frame-&gt;format)); return -1; &#125; printf("video_frame%s n:%d coded_n:%d\n", cached ? "(cached)" : "", video_frame_count++, frame-&gt;coded_picture_number); /* copy decoded frame to destination buffer: * this is required since rawvideo expects non aligned data */ av_image_copy(video_dst_data, video_dst_linesize, (const uint8_t **)(frame-&gt;data), frame-&gt;linesize, pix_fmt, width, height);//复制帧数据到video_dst_data和video_dst_linesize 因为是rawvideo /* write to rawvideo file */ fwrite(video_dst_data[0], 1, video_dst_bufsize, video_dst_file); &#125; &#125; else if (pkt.stream_index == audio_stream_idx) &#123; /* decode audio frame */ ret = avcodec_decode_audio4(audio_dec_ctx, frame, got_frame, &amp;pkt);//解码音频 已经放弃维护 if (ret &lt; 0) &#123; fprintf(stderr, "Error decoding audio frame (%s)\n", av_err2str(ret)); return ret; &#125; /* Some audio decoders decode only part of the packet, and have to be * called again with the remainder of the packet data. * Sample: fate-suite/lossless-audio/luckynight-partial.shn * Also, some decoders might over-read the packet. */ decoded = FFMIN(ret, pkt.size);//该帧的大小 if (*got_frame) &#123; size_t unpadded_linesize = frame-&gt;nb_samples * av_get_bytes_per_sample(frame-&gt;format);//采样数*采样样本大小 printf("audio_frame%s n:%d nb_samples:%d pts:%s\n", cached ? "(cached)" : "", audio_frame_count++, frame-&gt;nb_samples, av_ts2timestr(frame-&gt;pts, &amp;audio_dec_ctx-&gt;time_base)); /* Write the raw audio data samples of the first plane. This works * fine for packed formats (e.g. AV_SAMPLE_FMT_S16). However, * most audio decoders output planar audio, which uses a separate * plane of audio samples for each channel (e.g. AV_SAMPLE_FMT_S16P). * In other words, this code will write only the first audio channel * in these cases. * You should use libswresample or libavfilter to convert the frame * to packed data. */ fwrite(frame-&gt;extended_data[0], 1, unpadded_linesize, audio_dst_file);//对于plane是可以的 planar需要使用libswresample or libavfilter进行优化 &#125; &#125; /* If we use frame reference counting, we own the data and need * to de-reference it when we don't use it anymore */ if (*got_frame &amp;&amp; refcount) av_frame_unref(frame); return decoded;&#125;static int open_codec_context(int *stream_idx, AVCodecContext **dec_ctx, AVFormatContext *fmt_ctx, enum AVMediaType type)//根据type从fmt_ctx中返回stream_idx和dec_ctx&#123; int ret, stream_index; AVStream *st; AVCodec *dec = NULL; AVDictionary *opts = NULL; ret = av_find_best_stream(fmt_ctx, type, -1, -1, NULL, 0);//根据type 查找流的下标 if (ret &lt; 0) &#123; fprintf(stderr, "Could not find %s stream in input file '%s'\n", av_get_media_type_string(type), src_filename); return ret; &#125; else &#123; stream_index = ret; st = fmt_ctx-&gt;streams[stream_index]; /* find decoder for the stream */ dec = avcodec_find_decoder(st-&gt;codecpar-&gt;codec_id);//根据流保存的编码id 找到解码器 if (!dec) &#123; fprintf(stderr, "Failed to find %s codec\n", av_get_media_type_string(type)); return AVERROR(EINVAL); &#125; /* Allocate a codec context for the decoder */ *dec_ctx = avcodec_alloc_context3(dec);//根据编解码器 为ctx分配空间和初始化 if (!*dec_ctx) &#123; fprintf(stderr, "Failed to allocate the %s codec context\n", av_get_media_type_string(type)); return AVERROR(ENOMEM); &#125; /* Copy codec parameters from input stream to output codec context */ if ((ret = avcodec_parameters_to_context(*dec_ctx, st-&gt;codecpar)) &lt; 0) &#123;//将codecpar的字段替换dec_ctx内相应的字段 fprintf(stderr, "Failed to copy %s codec parameters to decoder context\n", av_get_media_type_string(type)); return ret; &#125; /* Init the decoders, with or without reference counting */ av_dict_set(&amp;opts, "refcounted_frames", refcount ? "1" : "0", 0);//设置AVDictionary属性 if ((ret = avcodec_open2(*dec_ctx, dec, &amp;opts)) &lt; 0) &#123;//根据AVcode初始化一个编解码上下文 fprintf(stderr, "Failed to open %s codec\n", av_get_media_type_string(type)); return ret; &#125; *stream_idx = stream_index; &#125; return 0;&#125;static int get_format_from_sample_fmt(const char **fmt, enum AVSampleFormat sample_fmt)&#123; int i; struct sample_fmt_entry &#123; enum AVSampleFormat sample_fmt; const char *fmt_be, *fmt_le; &#125; sample_fmt_entries[] = &#123; &#123; AV_SAMPLE_FMT_U8, "u8", "u8" &#125;, &#123; AV_SAMPLE_FMT_S16, "s16be", "s16le" &#125;, &#123; AV_SAMPLE_FMT_S32, "s32be", "s32le" &#125;, &#123; AV_SAMPLE_FMT_FLT, "f32be", "f32le" &#125;, &#123; AV_SAMPLE_FMT_DBL, "f64be", "f64le" &#125;, &#125;; *fmt = NULL; for (i = 0; i &lt; FF_ARRAY_ELEMS(sample_fmt_entries); i++) &#123; struct sample_fmt_entry *entry = &amp;sample_fmt_entries[i]; if (sample_fmt == entry-&gt;sample_fmt) &#123; *fmt = AV_NE(entry-&gt;fmt_be, entry-&gt;fmt_le);//大小端 return 0; &#125; &#125; fprintf(stderr, "sample format %s is not supported as output format\n", av_get_sample_fmt_name(sample_fmt)); return -1;&#125;int main(int argc, char **argv)&#123; int ret = 0, got_frame; if (argc != 4 &amp;&amp; argc != 5) &#123; fprintf(stderr, "usage: %s [-refcount] input_file video_output_file audio_output_file\n" "API example program to show how to read frames from an input file.\n" "This program reads frames from a file, decodes them, and writes decoded\n" "video frames to a rawvideo file named video_output_file, and decoded\n" "audio frames to a rawaudio file named audio_output_file.\n\n" "If the -refcount option is specified, the program use the\n" "reference counting frame system which allows keeping a copy of\n" "the data for longer than one decode call.\n" "\n", argv[0]);//refcount 引用计数帧系统，但是保存副本的时间比编码长 exit(1); &#125; if (argc == 5 &amp;&amp; !strcmp(argv[1], "-refcount")) &#123; refcount = 1; argv++; &#125; src_filename = argv[1]; video_dst_filename = argv[2]; audio_dst_filename = argv[3]; /* open input file, and allocate format context */ if (avformat_open_input(&amp;fmt_ctx, src_filename, NULL, NULL) &lt; 0) &#123;//打开输入流，并且读取文件头 fmt_ctx为NULL时 不必再调用avformat_alloc_context fprintf(stderr, "Could not open source file %s\n", src_filename); exit(1); &#125; /* retrieve stream information */ if (avformat_find_stream_info(fmt_ctx, NULL) &lt; 0) &#123;//查找流信息 fprintf(stderr, "Could not find stream information\n"); exit(1); &#125; if (open_codec_context(&amp;video_stream_idx, &amp;video_dec_ctx, fmt_ctx, AVMEDIA_TYPE_VIDEO) &gt;= 0) &#123;//查找视频流 并得到编码器 video_stream = fmt_ctx-&gt;streams[video_stream_idx]; video_dst_file = fopen(video_dst_filename, "wb"); if (!video_dst_file) &#123; fprintf(stderr, "Could not open destination file %s\n", video_dst_filename); ret = 1; goto end; &#125; /* allocate image where the decoded image will be put */ width = video_dec_ctx-&gt;width; height = video_dec_ctx-&gt;height; pix_fmt = video_dec_ctx-&gt;pix_fmt; ret = av_image_alloc(video_dst_data, video_dst_linesize, width, height, pix_fmt, 1);//根据width height pix_fmt分配video_dst_data和video_dst_linesize的一张图片 if (ret &lt; 0) &#123; fprintf(stderr, "Could not allocate raw video buffer\n"); goto end; &#125; video_dst_bufsize = ret; &#125; if (open_codec_context(&amp;audio_stream_idx, &amp;audio_dec_ctx, fmt_ctx, AVMEDIA_TYPE_AUDIO) &gt;= 0) &#123;//查找音频流 并得到编码器 audio_stream = fmt_ctx-&gt;streams[audio_stream_idx]; audio_dst_file = fopen(audio_dst_filename, "wb"); if (!audio_dst_file) &#123; fprintf(stderr, "Could not open destination file %s\n", audio_dst_filename); ret = 1; goto end; &#125; &#125; /* dump input information to stderr */ av_dump_format(fmt_ctx, 0, src_filename, 0);//打印输入输出封装上下文 if (!audio_stream &amp;&amp; !video_stream) &#123; fprintf(stderr, "Could not find audio or video stream in the input, aborting\n"); ret = 1; goto end; &#125; frame = av_frame_alloc();//初始化帧 if (!frame) &#123; fprintf(stderr, "Could not allocate frame\n"); ret = AVERROR(ENOMEM); goto end; &#125; /* initialize packet, set data to NULL, let the demuxer fill it */ av_init_packet(&amp;pkt);//初始化压缩包 pkt.data = NULL; pkt.size = 0; if (video_stream) printf("Demuxing video from file '%s' into '%s'\n", src_filename, video_dst_filename); if (audio_stream) printf("Demuxing audio from file '%s' into '%s'\n", src_filename, audio_dst_filename); /* read frames from the file */ while (av_read_frame(fmt_ctx, &amp;pkt) &gt;= 0) &#123; AVPacket orig_pkt = pkt; do &#123; ret = decode_packet(&amp;got_frame, 0);//解码一帧 if (ret &lt; 0) break; pkt.data += ret;//数据指针移动 pkt.size -= ret;//数据长度减少 &#125; while (pkt.size &gt; 0); av_packet_unref(&amp;orig_pkt);//删掉缓存 &#125; /* flush cached frames */ pkt.data = NULL; pkt.size = 0; do &#123; decode_packet(&amp;got_frame, 1); &#125; while (got_frame);//清除缓存中的帧 printf("Demuxing succeeded.\n"); if (video_stream) &#123; printf("Play the output video file with the command:\n" "ffplay -f rawvideo -pix_fmt %s -video_size %dx%d %s\n", av_get_pix_fmt_name(pix_fmt), width, height, video_dst_filename); &#125; if (audio_stream) &#123; enum AVSampleFormat sfmt = audio_dec_ctx-&gt;sample_fmt; int n_channels = audio_dec_ctx-&gt;channels; const char *fmt; if (av_sample_fmt_is_planar(sfmt)) &#123; const char *packed = av_get_sample_fmt_name(sfmt); printf("Warning: the sample format the decoder produced is planar " "(%s). This example will output the first channel only.\n", packed ? packed : "?"); sfmt = av_get_packed_sample_fmt(sfmt); n_channels = 1; &#125; if ((ret = get_format_from_sample_fmt(&amp;fmt, sfmt)) &lt; 0) goto end; printf("Play the output audio file with the command:\n" "ffplay -f %s -ac %d -ar %d %s\n", fmt, n_channels, audio_dec_ctx-&gt;sample_rate, audio_dst_filename); &#125;end: avcodec_free_context(&amp;video_dec_ctx);//释放视频解码器 avcodec_free_context(&amp;audio_dec_ctx);//释放音频解码器 avformat_close_input(&amp;fmt_ctx);//释放封装上下文 if (video_dst_file) fclose(video_dst_file); if (audio_dst_file) fclose(audio_dst_file); av_frame_free(&amp;frame);//释放帧 av_free(video_dst_data[0]);//释放图片 return ret &lt; 0;&#125;]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-11.UDP-RTP协议解析]]></title>
    <url>%2F2019%2F12%2F05%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-11-UDP-RTP%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[UDP RTP头结构UDP 源数据端口，目的端口各占2个字节，长度也占2个字节，checksum 校检和也占2个字节长度 Rtp头标准长度为12个字节。其中，rtp协议版本号V占2位，填充标准P占1位，扩展标准X占1位，CSRC计数器CC占4位，这四个共占8位，一个字节。M标记占1位，有效载荷占7位，共占用1个字节。序列化占16位，占用2个字节。时间戳（Timestamp）占32位，占用4个字节。同步信源（SSRC）占32位，共占用4个字节。特约信源（CSRC），每个特约信源占32位，可以有0到15个。 MPEG-TS包头信息 详细 Sync byte:同步字节，值为0x47；Transport error indicator:传输错误指示位，置1时，表示传送包中至少有一个不可纠正的错误位。Payload unit start indicator:负载单元起始指标位，表示TS包的有效净荷以PES/PSI包的第一个字节开始，举个例子，一个PES包可能由多个TS包构成，第一个TS包的负载单元起始指标位才会被置位。Transport priority:传输优先级，表明该包比同个PID的但未置位的TS包有更高的优先级。PID:该TS包的ID号，如果净荷是PAT包，则PID固定为0x00。Transport scrambling control:传输加扰控制位Adaption field control:自适应调整域控制位，置位则表明该TS包存在自适应调整字段。Continuity counter:连续计数器，随着具有相同PID的TS包的增加而增加，达到最大时恢复为0，如果两个连续相同PID的TS包具有相同的计数，则表明这两个包是一样的，只取一个解析即可。Payload:负载内容，可能为PAT/PMT/PES。data_byte为1B长度的数据，为负载字节。 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#pragma comment(lib, "ws2_32.lib") #pragma pack(1) /* * [memo] FFmpeg stream Command: * ffmpeg -re -i sintel.ts -f mpegts udp://127.0.0.1:8880 * ffmpeg -re -i sintel.ts -f rtp_mpegts udp://127.0.0.1:8880 */ typedef struct RTP_FIXED_HEADER&#123; /* byte 0 */ unsigned char csrc_len:4; /* expect 0 */ unsigned char extension:1; /* expect 1 */ unsigned char padding:1; /* expect 0 */ unsigned char version:2; /* expect 2 */ /* byte 1 */ unsigned char payload:7; unsigned char marker:1; /* expect 1 */ /* bytes 2, 3 */ unsigned short seq_no; /* bytes 4-7 */ unsigned long timestamp; /* bytes 8-11 */ unsigned long ssrc; /* stream number is used here. */&#125; RTP_FIXED_HEADER; typedef struct MPEGTS_FIXED_HEADER &#123; unsigned sync_byte: 8; unsigned transport_error_indicator: 1; unsigned payload_unit_start_indicator: 1; unsigned transport_priority: 1; unsigned PID: 13; unsigned scrambling_control: 2; unsigned adaptation_field_exist: 2; unsigned continuity_counter: 4;&#125; MPEGTS_FIXED_HEADER; int simplest_udp_parser(int port)&#123; WSADATA wsaData;//https://baike.baidu.com/item/WSADATA/3031763?fr=aladdina //这个结构被用来存储被WSAStartup函数调用后返回的Windows Sockets数据。 WORD sockVersion = MAKEWORD(2,2);//声明调用不同的Winsock版本。例如MAKEWORD(2,2)就是调用2.2版 MAKEWORD(2,2)构成一个16位无符号的整形 MAKEWORD(a,b) ((WORD) (((BYTE) (a)) | ((WORD) ((BYTE) (b))) &lt;&lt; 8)) int cnt=0; //FILE *myout=fopen("output_log.txt","wb+"); FILE *myout=stdout; FILE *fp1=fopen("output_dump.ts","wb+"); if(WSAStartup(sockVersion, &amp;wsaData) != 0)&#123; return 0; &#125; SOCKET serSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if(serSocket == INVALID_SOCKET)&#123; printf("socket error !"); return 0; &#125; sockaddr_in serAddr;//sockaddr_in易于操作 与sockaddr大小一致 可强制转换为sockaddr serAddr.sin_family = AF_INET; serAddr.sin_port = htons(port);//网络字节顺序 变成大端 serAddr.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(serSocket, (sockaddr *)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR)&#123; printf("bind error !"); closesocket(serSocket); return 0; &#125; sockaddr_in remoteAddr; int nAddrLen = sizeof(remoteAddr); //How to parse? int parse_rtp=1; int parse_mpegts=1; printf("Listening on port %d\n",port); char recvData[10000]; while (1)&#123; int pktsize = recvfrom(serSocket, recvData, 10000, 0, (sockaddr *)&amp;remoteAddr, &amp;nAddrLen); if (pktsize &gt; 0)&#123; //printf("Addr:%s\r\n",inet_ntoa(remoteAddr.sin_addr)); //printf("packet size:%d\r\n",pktsize); //Parse RTP // if(parse_rtp!=0)&#123; char payload_str[10]=&#123;0&#125;; RTP_FIXED_HEADER rtp_header; int rtp_header_size=sizeof(RTP_FIXED_HEADER); //RTP Header memcpy((void *)&amp;rtp_header,recvData,rtp_header_size); //RFC3551 char payload=rtp_header.payload; switch(payload)&#123; case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: sprintf(payload_str,"Audio");break; case 31: sprintf(payload_str,"H.261");break; case 32: sprintf(payload_str,"MPV");break; case 33: sprintf(payload_str,"MP2T");break; case 34: sprintf(payload_str,"H.263");break; case 96: sprintf(payload_str,"H.264");break; default:sprintf(payload_str,"other");break; &#125; unsigned int timestamp=ntohl(rtp_header.timestamp);//将网络字节顺序 转成本机 无符号长整 unsigned int seq_no=ntohs(rtp_header.seq_no);//无符号短整 fprintf(myout,"[RTP Pkt] %5d| %5s| %10u| %5d| %5d|\n",cnt,payload_str,timestamp,seq_no,pktsize); //RTP Data char *rtp_data=recvData+rtp_header_size; int rtp_data_size=pktsize-rtp_header_size; fwrite(rtp_data,rtp_data_size,1,fp1); //Parse MPEGTS if(parse_mpegts!=0&amp;&amp;payload==33)&#123; MPEGTS_FIXED_HEADER mpegts_header; for(int i=0;i&lt;rtp_data_size;i=i+188)&#123;//一段固定188 if(rtp_data[i]!=0x47)//同步字 固定0x47 break; //MPEGTS Header //memcpy((void *)&amp;mpegts_header,rtp_data+i,sizeof(MPEGTS_FIXED_HEADER)); fprintf(myout," [MPEGTS Pkt]\n"); &#125; &#125; &#125;else&#123; fprintf(myout,"[UDP Pkt] %5d| %5d|\n",cnt,pktsize); fwrite(recvData,pktsize,1,fp1); &#125; cnt++; &#125; &#125; closesocket(serSocket); WSACleanup(); fclose(fp1); return 0;&#125;]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-10.FLV封装格式解析]]></title>
    <url>%2F2019%2F11%2F29%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-10-FLV%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[FLV封装格式FLV包含文件头和文件体两部分，文件体由多个Tag组成，Tag的类型可以是视频、音频和Script，每个Tag只能包含以上三种类型的数据中的一种 。如下图 Type为0x08即音频 名称 音频编码类型 音频采样率 音频采样精度 音频类型 0 Linear PCM，platform endian 5.5kHz 8bits sndMono 1 ADPCM 11KHz 16bits sndStereo 2 MP3 22 kHz 3 Linear PCM，little endian 44 kHz 4 Nellymoser 16-kHz mono 5 Nellymoser 8-kHz mono 6 Nellymoser 7 G.711 A-law logarithmic PCM 8 G.711 mu-law logarithmic PCM 9 reserved 10 AAC 14 MP3 8-Khz 15 Device-specific sound Type为0x09即视频 名称 帧类型 视频编码类型 1 keyframe （for AVC，a seekable frame） JPEG （currently unused） 2 inter frame （for AVC，a nonseekable frame） Sorenson H.263 3 disposable inter frame （H.263 only） Screen video 4 generated keyframe （reserved for server use） On2 VP6 5 video info/command frame On2 VP6 with alpha channel 6 Screen video version 2 7 AVC Type为0x12即控制帧 该类型Tag又通常被称为Metadata Tag，会放一些关于FLV视频和音频的元数据信息如：duration、width、height等。通常该类型Tag会跟在File Header后面作为第一个Tag出现，而且只有一个。 AMF1： 第1个字节表示AMF包类型，一般总是0x02，表示字符串。第2-3个字节为UI16类型值，标识字符串的长度，一般总是0x000A（“onMetaData”长度）。后面字节为具体的字符串，一般总为“onMetaData”（6F,6E,4D,65,74,61,44,61,74,61） 第1个字节表示AMF包类型，一般总是0x08，表示数组。第2-5个字节为UI32类型值，表示数组元素的个数。后面即为各数组元素的封装，数组元素为元素名称和值组成的对。 | 值 | 含义 || ————— | ———— || duration | 时长 || width | 视频宽度 || height | 视频高度 || videodatarate | 视频码率 || framerate | 视频帧率 || videocodecid | 视频编码方式 || audiosamplerate | 音频采样率 || audiosamplesize | 音频采样精度 || stereo | 是否为立体 || audiocodecid | 音频编码方式 || filesize | 文件大小 | 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#pragma pack(1) //包大小设为1 #define TAG_TYPE_SCRIPT 18#define TAG_TYPE_AUDIO 8#define TAG_TYPE_VIDEO 9 typedef unsigned char byte;typedef unsigned int uint; typedef struct &#123; byte Signature[3]; byte Version; byte Flags; uint DataOffset;&#125; FLV_HEADER; typedef struct &#123; byte TagType; byte DataSize[3]; byte Timestamp[3]; uint Reserved;&#125; TAG_HEADER; //大端转小端uint reverse_bytes(byte *p, char c) &#123; int r = 0; int i; for (i=0; i&lt;c; i++) r |= ( *(p+i) &lt;&lt; (((c-1)*8)-8*i)); return r;&#125; int simplest_flv_parser(char *url)&#123; //whether output audio/video stream int output_a=1; int output_v=1; FILE *ifh=NULL,*vfh=NULL, *afh = NULL; //FILE *myout=fopen("output_log.txt","wb+"); FILE *myout=stdout; FLV_HEADER flv; TAG_HEADER tagheader; uint previoustagsize, previoustagsize_z=0; uint ts=0, ts_new=0; ifh = fopen(url, "rb+"); if ( ifh== NULL) &#123; printf("Failed to open files!"); return -1; &#125; //FLV file header fread((char *)&amp;flv,1,sizeof(FLV_HEADER),ifh); fprintf(myout,"============== FLV Header ==============\n"); fprintf(myout,"Signature: 0x %c %c %c\n",flv.Signature[0],flv.Signature[1],flv.Signature[2]); fprintf(myout,"Version: 0x %X\n",flv.Version); fprintf(myout,"Flags : 0x %X\n",flv.Flags); fprintf(myout,"HeaderSize: 0x %X %d\n",reverse_bytes((byte *)&amp;flv.DataOffset, sizeof(flv.DataOffset))); fprintf(myout,"========================================\n"); //move the file pointer to the end of the header fseek(ifh, reverse_bytes((byte *)&amp;flv.DataOffset, sizeof(flv.DataOffset)), SEEK_SET); //process each tag do &#123; previoustagsize = _getw(ifh); fread((void *)&amp;tagheader,sizeof(TAG_HEADER),1,ifh); //int temp_datasize1=reverse_bytes((byte *)&amp;tagheader.DataSize, sizeof(tagheader.DataSize)); int tagheader_datasize=tagheader.DataSize[0]*65536+tagheader.DataSize[1]*256+tagheader.DataSize[2]; int tagheader_timestamp=tagheader.Timestamp[0]*65536+tagheader.Timestamp[1]*256+tagheader.Timestamp[2]; char tagtype_str[10]; switch(tagheader.TagType)&#123; case TAG_TYPE_AUDIO:sprintf(tagtype_str,"AUDIO");break; case TAG_TYPE_VIDEO:sprintf(tagtype_str,"VIDEO");break; case TAG_TYPE_SCRIPT:sprintf(tagtype_str,"SCRIPT");break; default:sprintf(tagtype_str,"UNKNOWN");break; &#125; fprintf(myout,"[%6s] %6d %6d |",tagtype_str,tagheader_datasize,tagheader_timestamp); //if we are not past the end of file, process the tag if (feof(ifh)) &#123; break; &#125; //process tag by type switch (tagheader.TagType) &#123; case TAG_TYPE_AUDIO:&#123; char audiotag_str[100]=&#123;0&#125;; strcat(audiotag_str,"| "); char tagdata_first_byte; tagdata_first_byte=fgetc(ifh); int x=tagdata_first_byte&amp;0xF0; x=x&gt;&gt;4; switch (x) &#123; case 0:strcat(audiotag_str,"Linear PCM, platform endian");break; case 1:strcat(audiotag_str,"ADPCM");break; case 2:strcat(audiotag_str,"MP3");break; case 3:strcat(audiotag_str,"Linear PCM, little endian");break; case 4:strcat(audiotag_str,"Nellymoser 16-kHz mono");break; case 5:strcat(audiotag_str,"Nellymoser 8-kHz mono");break; case 6:strcat(audiotag_str,"Nellymoser");break; case 7:strcat(audiotag_str,"G.711 A-law logarithmic PCM");break; case 8:strcat(audiotag_str,"G.711 mu-law logarithmic PCM");break; case 9:strcat(audiotag_str,"reserved");break; case 10:strcat(audiotag_str,"AAC");break; case 11:strcat(audiotag_str,"Speex");break; case 14:strcat(audiotag_str,"MP3 8-Khz");break; case 15:strcat(audiotag_str,"Device-specific sound");break; default:strcat(audiotag_str,"UNKNOWN");break; &#125; strcat(audiotag_str,"| "); x=tagdata_first_byte&amp;0x0C; x=x&gt;&gt;2; switch (x) &#123; case 0:strcat(audiotag_str,"5.5-kHz");break; case 1:strcat(audiotag_str,"1-kHz");break; case 2:strcat(audiotag_str,"22-kHz");break; case 3:strcat(audiotag_str,"44-kHz");break; default:strcat(audiotag_str,"UNKNOWN");break; &#125; strcat(audiotag_str,"| "); x=tagdata_first_byte&amp;0x02; x=x&gt;&gt;1; switch (x) &#123; case 0:strcat(audiotag_str,"8Bit");break; case 1:strcat(audiotag_str,"16Bit");break; default:strcat(audiotag_str,"UNKNOWN");break; &#125; strcat(audiotag_str,"| "); x=tagdata_first_byte&amp;0x01; switch (x) &#123; case 0:strcat(audiotag_str,"Mono");break; case 1:strcat(audiotag_str,"Stereo");break; default:strcat(audiotag_str,"UNKNOWN");break; &#125; fprintf(myout,"%s",audiotag_str); //if the output file hasn't been opened, open it. if(output_a!=0&amp;&amp;afh == NULL)&#123; afh = fopen("output.mp3", "wb"); &#125; //TagData - First Byte Data int data_size=reverse_bytes((byte *)&amp;tagheader.DataSize, sizeof(tagheader.DataSize))-1;//-1是个迷 FirstBYteData为什么是1和减掉 if(output_a!=0)&#123;//读完TagData for (int i=0; i&lt;data_size; i++) fputc(fgetc(ifh),afh);//将音频输出到mp3文件 &#125;else&#123; for (int i=0; i&lt;data_size; i++) fgetc(ifh); &#125; break; &#125; case TAG_TYPE_VIDEO:&#123; char videotag_str[100]=&#123;0&#125;; strcat(videotag_str,"| "); char tagdata_first_byte; tagdata_first_byte=fgetc(ifh); int x=tagdata_first_byte&amp;0xF0; x=x&gt;&gt;4; switch (x) &#123; case 1:strcat(videotag_str,"key frame ");break; case 2:strcat(videotag_str,"inter frame");break; case 3:strcat(videotag_str,"disposable inter frame");break; case 4:strcat(videotag_str,"generated keyframe");break; case 5:strcat(videotag_str,"video info/command frame");break; default:strcat(videotag_str,"UNKNOWN");break; &#125; strcat(videotag_str,"| "); x=tagdata_first_byte&amp;0x0F; switch (x) &#123; case 1:strcat(videotag_str,"JPEG (currently unused)");break; case 2:strcat(videotag_str,"Sorenson H.263");break; case 3:strcat(videotag_str,"Screen video");break; case 4:strcat(videotag_str,"On2 VP6");break; case 5:strcat(videotag_str,"On2 VP6 with alpha channel");break; case 6:strcat(videotag_str,"Screen video version 2");break; case 7:strcat(videotag_str,"AVC");break; default:strcat(videotag_str,"UNKNOWN");break; &#125; fprintf(myout,"%s",videotag_str); fseek(ifh, -1, SEEK_CUR);//往回走一位 迷 前四位是tagdata_first_byte&amp;0xF0 后四位是tagdata_first_byte&amp;0x0F 不应该啊 //if the output file hasn't been opened, open it. if (vfh == NULL&amp;&amp;output_v!=0) &#123; //write the flv header (reuse the original file's hdr) and first previoustagsize vfh = fopen("output.flv", "wb"); fwrite((char *)&amp;flv,1, sizeof(flv),vfh); fwrite((char *)&amp;previoustagsize_z,1,sizeof(previoustagsize_z),vfh); &#125;#if 0 //延长时间戳 变成双倍 //Change Timestamp //Get Timestamp ts = reverse_bytes((byte *)&amp;tagheader.Timestamp, sizeof(tagheader.Timestamp)); ts=ts*2; //Writeback Timestamp ts_new = reverse_bytes((byte *)&amp;ts, sizeof(ts)); memcpy(&amp;tagheader.Timestamp, ((char *)&amp;ts_new) + 1, sizeof(tagheader.Timestamp));//Timestamp只占三位 大端模式 去掉首位#endif //TagData + Previous Tag Size int data_size=reverse_bytes((byte *)&amp;tagheader.DataSize, sizeof(tagheader.DataSize))+4; if(output_v!=0)&#123; //TagHeader fwrite((char *)&amp;tagheader,1, sizeof(tagheader),vfh); //TagData for (int i=0; i&lt;data_size; i++) fputc(fgetc(ifh),vfh); &#125;else&#123; for (int i=0; i&lt;data_size; i++) fgetc(ifh); &#125; //rewind 4 bytes, because we need to read the previoustagsize again for the loop's sake fseek(ifh, -4, SEEK_CUR); break; &#125; default: //skip the data of this tag fseek(ifh, reverse_bytes((byte *)&amp;tagheader.DataSize, sizeof(tagheader.DataSize)), SEEK_CUR); &#125; fprintf(myout,"\n"); &#125; while (!feof(ifh)); _fcloseall(); return 0;&#125;]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-9.AAC音频码流解析]]></title>
    <url>%2F2019%2F11%2F28%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-9-AAC%E9%9F%B3%E9%A2%91%E7%A0%81%E6%B5%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[AAC基本结构详细 由图可见，ADTS frame (Audio Data Transport Stream) 之间由syncword（同步字进行分离），即0xFFF。 名称 备注 syncword 总是0xFFF, 代表一个ADTS帧的开始 ID MPEG Version: 0 for MPEG-4, 1 for MPEG-2 layer always: ‘00’ protection_absent Warning, set to 1 if there is no CRC and 0 if there is CRC profile sampling_frequency_index channel_configuration aac_frame_length 一个ADTS帧的长度包括ADTS头和AAC原始流，aac_frame_length = (protection_absent == 1 ? 7 : 9) + size(AACFrame) adts_buffer_fullness 0x7FF 说明是码率可变的码流 number_of_raw_data_blocks_in_frame 有number_of_raw_data_blocks_in_frame+1个AAC原始帧(一个AAC原始帧包含一段时间内1024个采样及相关数据) 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100int getADTSframe(unsigned char* buffer, int buf_size, unsigned char* data ,int* data_size)&#123; int size = 0; if(!buffer || !data || !data_size )&#123; return -1; &#125; while(1)&#123; if(buf_size &lt; 7 )&#123; return -1; &#125; //找出同步码 然后找到aac_frame_length的大小 保存在size if((buffer[0] == 0xff) &amp;&amp; ((buffer[1] &amp; 0xf0) == 0xf0) )&#123;//同步码 实际为0xF0FF? size |= ((buffer[3] &amp; 0x03) &lt;&lt;11); //high 2 bit size |= buffer[4]&lt;&lt;3; //middle 8 bit size |= ((buffer[5] &amp; 0xe0)&gt;&gt;5); //low 3bit break; &#125; --buf_size; ++buffer; &#125; if(buf_size &lt; size)&#123;//此段不完整 buf_size为剩下的 size为应该的大小 return 1; &#125; memcpy(data, buffer, size); *data_size = size; return 0;&#125;int aacParser(char *url)&#123; int data_size = 0; int size = 0; int cnt=0; int offset=0; unsigned char *aacframe=(unsigned char *)malloc(1024*5); unsigned char *aacbuffer=(unsigned char *)malloc(1024*1024); FILE *fp=fopen(url,"rb"); while(!feof(fp))&#123; data_size = fread(aacbuffer+offset, 1, 1024*1024-offset, ifile); unsigned char* input_data = aacbuffer; while(1) &#123; int ret=getADTSframe(input_data, data_size, aacframe, &amp;size); if(ret==-1)&#123;//段中没有完整的ADTS了 break; &#125;else if(ret==1)&#123;//offset表示将数据回退的长度 memcpy(aacbuffer,input_data,data_size); offset=data_size; break; &#125; char profile_str[10]=&#123;0&#125;; char frequence_str[10]=&#123;0&#125;; unsigned char profile=aacframe[2]&amp;0xC0; profile=profile&gt;&gt;6; switch(profile)&#123; case 0: sprintf(profile_str,"Main");break; case 1: sprintf(profile_str,"LC");break; case 2: sprintf(profile_str,"SSR");break; default:sprintf(profile_str,"unknown");break; &#125; unsigned char sampling_frequency_index=aacframe[2]&amp;0x3C; sampling_frequency_index=sampling_frequency_index&gt;&gt;2; switch(sampling_frequency_index)&#123; case 0: sprintf(frequence_str,"96000Hz");break; case 1: sprintf(frequence_str,"88200Hz");break; case 2: sprintf(frequence_str,"64000Hz");break; case 3: sprintf(frequence_str,"48000Hz");break; case 4: sprintf(frequence_str,"44100Hz");break; case 5: sprintf(frequence_str,"32000Hz");break; case 6: sprintf(frequence_str,"24000Hz");break; case 7: sprintf(frequence_str,"22050Hz");break; case 8: sprintf(frequence_str,"16000Hz");break; case 9: sprintf(frequence_str,"12000Hz");break; case 10: sprintf(frequence_str,"11025Hz");break; case 11: sprintf(frequence_str,"8000Hz");break; default:sprintf(frequence_str,"unknown");break; &#125; fprintf(myout,"%5d| %8s| %8s| %5d|\n",cnt,profile_str ,frequence_str,size); data_size -= size; input_data += size; cnt++; &#125; &#125; fclose(ifile); free(aacbuffer); free(aacframe); return 0;&#125;]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-8.H264视频码流解析]]></title>
    <url>%2F2019%2F11%2F28%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-8-H264%E8%A7%86%E9%A2%91%E7%A0%81%E6%B5%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[H.264结构基本介绍 H264比特流 = Start_Code_Prefix + NALU + Start_Code_Prefix + NALU + … 由此可见，H264由一个起始码将各个NALU（ Network Abstract Layer，即网络抽象层 U单元 ），其中，起始码分为3Byte和4Byte的0x000001和0x00000001。如果以Slice为一帧开始就用0x00000001，否则用0x000001。在起始码后面的第一个字节，就是NALU的类型。详细 类型值 解释 1 非IDR图像的编码条带，为P或B帧。P帧，前向预测编码帧，表示该帧与前一帧的差别（I或P），在I中找 出P某点的预测值和运动矢量，一起传送。接收端根据运动矢量从I中找出P某点的预测值并与差值相加得到样值。 1P帧在I帧后面1~2帧的位置 2压缩率比较高 3采用运动补偿传送差值和运动矢量 4可造成解码错误扩散 B帧，双向预测编码帧，通过前后帧与本帧数据叠加取得最终画面。先找出B帧中某点的预测值和两个运动矢量，传送预测值和运动矢量。接收端根据运动矢量在两个帧中找出预测值并求和。 1B帧由前面的I或者P和后面的P帧来计算 2压缩率最高，只反映帧间运动主体的变化 3不会造成解码错误扩散 2 编码条带数据分割块A 3 编码条带数据分割块B 4 编码条带数据分割块C 5 I帧，IDR图像的编码条带，俗称关键帧，也叫帧内编码帧。1全帧JPEG压缩编码 2描述了图像背景和运动主体的详情 3是P和B帧的参考帧 4一组只有一个 6 辅助增强信息 (SEI) 7 SPS（Sequence Parameter Set）序列参数集。包括编码所用的profile，level，图像的宽和高，deblock滤波器等 8 PPS（Picture Parameter Set）图像参数集。包括编码所用的profile，level，图像的宽和高，deblock滤波器等 9 访问单元分隔符 10 序列结尾 11 流结尾 12 填充数据 13 序列参数集扩展 19 未分割的辅助编码图像的编码条带 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179typedef enum &#123; NALU_TYPE_SLICE = 1, NALU_TYPE_DPA = 2, NALU_TYPE_DPB = 3, NALU_TYPE_DPC = 4, NALU_TYPE_IDR = 5, NALU_TYPE_SEI = 6, NALU_TYPE_SPS = 7, NALU_TYPE_PPS = 8, NALU_TYPE_AUD = 9, NALU_TYPE_EOSEQ = 10, NALU_TYPE_EOSTREAM = 11, NALU_TYPE_FILL = 12,&#125; NaluType; typedef enum &#123; NALU_PRIORITY_DISPOSABLE = 0, NALU_PRIRITY_LOW = 1, NALU_PRIORITY_HIGH = 2, NALU_PRIORITY_HIGHEST = 3&#125; NaluPriority; typedef struct&#123; int startcodeprefix_len; //slice表示4位 否则3位 unsigned len; //NALU的长度 不包括起始码 unsigned max_size; //NALU缓冲区大小 int forbidden_bit; //FALSE int nal_reference_idc; //NALU_PRIORITY_xxxx int nal_unit_type; //NALU_TYPE_xxxx char *buf; //包含EBSP后面的第一个字节&#125; NALU_t;FILE *h264bitstream;int info2=0, info3=0; static int FindStartCode2 (unsigned char *Buf)&#123; if(Buf[0]!=0 || Buf[1]!=0 || Buf[2] !=1) return 0; //0x000001? else return 1;&#125; static int FindStartCode3 (unsigned char *Buf)&#123; if(Buf[0]!=0 || Buf[1]!=0 || Buf[2] !=0 || Buf[3] !=1) return 0;//0x00000001? else return 1;&#125;int GetAnnexbNALU(NALU_t *nalu)&#123; int pos = 0; int StartCodeFound, rewind; unsigned char *Buf; if ((Buf = (unsigned char*)calloc (nalu-&gt;max_size , sizeof(char))) == NULL) printf ("GetAnnexbNALU: Could not allocate Buf memory\n"); nalu-&gt;startcodeprefix_len=3;//假设是0x000001 if (3 != fread (Buf, 1, 3, h264bitstream))&#123; free(Buf); return 0; &#125; info2 = FindStartCode2 (Buf); if(info2 != 1) &#123;//不是0x000001 if(1 != fread(Buf+3, 1, 1, h264bitstream))&#123;//多读取一个 free(Buf); return 0; &#125; info3 = FindStartCode3 (Buf);//是不是0x00000001 if (info3 != 1)&#123; free(Buf); return -1; &#125; else &#123; pos = 4; nalu-&gt;startcodeprefix_len = 4; &#125; &#125; else&#123; nalu-&gt;startcodeprefix_len = 3; pos = 3; &#125; StartCodeFound = 0; info2 = 0; info3 = 0; while (!StartCodeFound)&#123; if (feof (h264bitstream))&#123;//读到文件尾 nalu-&gt;len = (pos-1)-nalu-&gt;startcodeprefix_len; memcpy (nalu-&gt;buf, &amp;Buf[nalu-&gt;startcodeprefix_len], nalu-&gt;len); nalu-&gt;forbidden_bit = nalu-&gt;buf[0] &amp; 0x80; //1 bit 10000000 nalu-&gt;nal_reference_idc = nalu-&gt;buf[0] &amp; 0x60; // 2 bit 01100000 nalu-&gt;nal_unit_type = (nalu-&gt;buf[0]) &amp; 0x1f;// 5 bit 00011111 free(Buf); return pos-1; &#125; Buf[pos++] = fgetc (h264bitstream); //判断本段是否结束 info3 = FindStartCode3(&amp;Buf[pos-4]); if(info3 != 1) info2 = FindStartCode2(&amp;Buf[pos-3]); StartCodeFound = (info2 == 1 || info3 == 1); &#125; // Here, we have found another start code (and read length of startcode bytes more than we should // have. Hence, go back in the file rewind = (info3 == 1)? -4 : -3; if (0 != fseek (h264bitstream, rewind, SEEK_CUR))&#123; free(Buf); printf("GetAnnexbNALU: Cannot fseek in the bit stream file"); &#125; // Here the Start code, the complete NALU, and the next start code is in the Buf. // The size of Buf is pos, pos+rewind are the number of bytes excluding the next // start code, and (pos+rewind)-startcodeprefix_len is the size of the NALU excluding the start code nalu-&gt;len = (pos+rewind)-nalu-&gt;startcodeprefix_len; memcpy (nalu-&gt;buf, &amp;Buf[nalu-&gt;startcodeprefix_len], nalu-&gt;len);// nalu-&gt;forbidden_bit = nalu-&gt;buf[0] &amp; 0x80; //1 bit nalu-&gt;nal_reference_idc = nalu-&gt;buf[0] &amp; 0x60; // 2 bit nalu-&gt;nal_unit_type = (nalu-&gt;buf[0]) &amp; 0x1f;// 5 bit free(Buf); return (pos+rewind);&#125;int h264Parser(char *url)&#123; int data_offset=0; int nal_num=0; NALU_t *n=(NALU_t*)calloc(1,sizeof(NALU_t)); n-&gt;max_size=100000; n-&gt;buf = (char*)calloc (buffersize, sizeof (char)); h264bitstream=fopen(url, "rb+"); while(!feof(h264bitstream)) &#123; int data_lenth; data_lenth=GetAnnexbNALU(n); char type_str[20]=&#123;0&#125;; switch(n-&gt;nal_unit_type)&#123; case NALU_TYPE_SLICE:sprintf(type_str,"SLICE");break; case NALU_TYPE_DPA:sprintf(type_str,"DPA");break; case NALU_TYPE_DPB:sprintf(type_str,"DPB");break; case NALU_TYPE_DPC:sprintf(type_str,"DPC");break; case NALU_TYPE_IDR:sprintf(type_str,"IDR");break; case NALU_TYPE_SEI:sprintf(type_str,"SEI");break; case NALU_TYPE_SPS:sprintf(type_str,"SPS");break; case NALU_TYPE_PPS:sprintf(type_str,"PPS");break; case NALU_TYPE_AUD:sprintf(type_str,"AUD");break; case NALU_TYPE_EOSEQ:sprintf(type_str,"EOSEQ");break; case NALU_TYPE_EOSTREAM:sprintf(type_str,"EOSTREAM");break; case NALU_TYPE_FILL:sprintf(type_str,"FILL");break; &#125; char idc_str[20]=&#123;0&#125;; switch(n-&gt;nal_reference_idc&gt;&gt;5)&#123; case NALU_PRIORITY_DISPOSABLE:sprintf(idc_str,"DISPOS");break; case NALU_PRIRITY_LOW:sprintf(idc_str,"LOW");break; case NALU_PRIORITY_HIGH:sprintf(idc_str,"HIGH");break; case NALU_PRIORITY_HIGHEST:sprintf(idc_str,"HIGHEST");break; &#125; fprintf(myout,"%5d| %8d| %7s| %6s| %8d|\n",nal_num,data_offset,idc_str,type_str,n-&gt;len); data_offset=data_offset+data_lenth; nal_num++; &#125; if (n)&#123; if (n-&gt;buf)&#123; free(n-&gt;buf); n-&gt;buf=NULL; &#125; free (n); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-7.PCM音频数据处理]]></title>
    <url>%2F2019%2F11%2F27%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-7-PCM%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[分离PCM16LE双声道音频PCM16LE中左右声道是间隔存储的。16表示采样位数是16bit，LE表示Litter Endian，小端模式。 1234567891011121314151617181920int pcm16leSplit(const char * url)&#123; FILE *fp=fopen("","wb+"); FILE *fp1=fopen("","wb+"); FILE *fp2=fopen(url,"rb+"); unsigned char *temp=(unsigned char *)malloc(4); while(!feof(fp2))&#123; fread(temp,1,4,fp2); fwrite(temp,1,2,fp); fwrite(temp+2,1,2,fp1); &#125; free(temp); fclose(fp); fclose(fp1); fclose(fp2); return 0;&#125; 左声道音量减半123456789101112131415161718192021int pcm16leCutLeft(char *url)&#123; FILE *fp=fopen("","wb+"); FILE *fp2=fopen(url,"rb+"); unsigned char *temp=(unsigned char *)malloc(4); while(!feof(fp2))&#123; fread(temp,1,4,fp2); short *sh=(short *)temp; *sh=(*sh)/2; fwrite(temp,1,2,fp); fwrite(temp+2,1,2,fp); &#125; free(temp); fclose(fp); fclose(fp2); return 0;&#125; PCM16LE2PCM812345678910111213141516171819202122//将-32768~32767转换为0~255int pcm16le2pcm8(char *url)&#123; FILE *fp=fopen("","wb+"); FILE *fp2=fopen(url,"rb+"); unsigned char *temp=(unsigned char *)malloc(4); while(!feof(fp2))&#123; fread(temp,1,4,fp2); char pcm8; pcm8= (*(short*)temp)&gt;&gt;256+128; fwrite(&amp;pcm8,1,1,fp); pcm8= (*(short*)(temp+2)&gt;&gt;256+128; fwrite(&amp;pcm8,1,1,fp); &#125; free(temp); fclose(fp); fclose(fp2); return 0;&#125; PCM16LE2WAVE123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475WAVE是微软上常见的音频格式，具体为在PCM前加了一个文件头WAVE_HEADERWAVE_FMTWAVE_DATAPCM数据 ;typedef struct WAVE_HEADER&#123; char fccID[4]; unsigned long dwSize; char fccType[4]; &#125;WAVE_HEADER; typedef struct WAVE_FMT&#123; char fccID[4]; unsigned long dwSize; unsigned short wFormatTag; unsigned short wChannels; unsigned long dwSamplesPerSec; unsigned long dwAvgBytesPerSec; unsigned short wBlockAlign; unsigned short uiBitsPerSample; &#125;WAVE_FMT; typedef struct WAVE_DATA&#123; char fccID[4]; unsigned long dwSize; &#125;WAVE_DATA; int pcm16le2wave(const char *pcmUrl,int channels,int sample_rate/*44100*/,const char * waveUrl)&#123; int bits=16; unsigned short m_pcmData; WAVE_HEADER pcmHEADER; WAVE_FMT pcmFMT; WAVE_DATA pcmDATA; FILE *fp=fopen(pcmUrl,"rb+"); FILE *fp2=fopen(waveUrl,"wb+"); memcpy(pcmHEADER.fccID,"RIFF",strlen("RIFF")); memcpy(pcmHEADER.fccType,"WAVE",strlen("WAVE")); fseek(fp2,sizeof(WAVE_HEADER),1); pcmFMT.dwSamplesPerSec=sample_rate; pcmFMT.dwAvgBytesPerSec=pcmFMT.dwSamplesPerSec*sizeof(m_pcmData); pcmFMT.uiBitsPerSample=bits; memcpy(pcmFMT.fccID,"fmt ",strlen("fmt ")); pcmFMT.dwSize=16; pcmFMT.wBlockAlign=2; pcmFMT.wChannels=channels; pcmFMT.wFormatTag=1; fwrite(&amp;pcmFMT,sizeof(WAVE_FMT),1,fp2); memcpy(pcmDATA.fccID,"data",strlen("data")); pcmDATA.dwSize=0; fseek(fp2,sizeof(WAVE_DATA),SEEK_CUR); fread(&amp;m_pcmData,sizeof(unsigned short),1,fp); while(!feof(fp))&#123; pcmDATA.dwSize+=2; fwrite(&amp;m_pcmData,sizeof(unsigned short),1,fp2); fread(&amp;m_pcmData,sizeof(unsigned short),1,fp); &#125; pcmHEADER.dwSize=44+pcmDATA.dwSize;//44没说是啥 应该是文件头 rewind(fp2); fwrite(&amp;pcmHEADER,sizeof(WAVE_HEADER),1,fp2); fseek(fp2,sizeof(WAVE_FMT),SEEK_CUR); fwrite(&amp;pcmDATA,sizeof(WAVE_DATA),1,fp2); fclose(fp); fclose(fp2); return 0;&#125;]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-6.YUV像素数据处理]]></title>
    <url>%2F2019%2F11%2F27%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-6-YUV%E5%83%8F%E7%B4%A0%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[分离YUV420P12345678910111213141516int yuv420pSplit(char *url,int w,int h,int num)&#123; unsigned char *pic=(unsigned char *)malloc(w*h*3/2); FILE *fp=fopen(url,"rb+"); for(int i=0;i&lt;num;i++)&#123; fread(pic,1,w*h*3/2,fp); pic;//Y w*h pic+w*h;//U w*h/4 pic+w*h*5/4;//V w*h/4 &#125; free(pic); close(fp); return 0;&#125; 分离YUV444P12345678910111213141516int yuv444Split(char *url,int w,int h,int num)&#123; unsigned char *pic=(unsigned char *)malloc(w*h*3); FILE *fp=fopen(url,"rb+"); for(int i=0;i&lt;num;i++)&#123; fread(pic,1,w*h*3,fp); pic;//Y w*h pic+w*h;//U w*h pic+w*h*2;//V w*h &#125; free(pic); close(fp); return 0;&#125; 去掉YUV420P的颜色12345678910111213141516int yuv420Gray(char *url,int w,int h,int num)&#123; unsigned char *pic=(unsigned char *)malloc(w*h*3/2); FILE *fp=fopen(url,"rb+"); for(int i=0;i&lt;num;i++)&#123; fread(pic,1,w*h*3/2,fp); memset(pic+w*h,128,w*h/2); //色度分量在偏置处理前的取值范围是-128至127,此时无色对应0。经偏置后变成0-255，此时无色对应为128 //因此只需要将U V设置成128 &#125; free(pic); close(fp); return 0;&#125; YUV的PSNR计算 PSNR是最基本的视频质量评价方法， RGB2BMPBMP文件是由BITMAPFILEHEADER、BITMAPINFOHEADER、BGR像素数据共3个部分构成，它的结构如下图所示 12345678910111213141516171819202122typedef struct tagBITMAPFILEHEADER&#123; unsigned short int bfType; //位图文件的类型，必须为BM unsigned long bfSize; //文件大小，以字节为单位unsigned short int bfReserverd1; //位图文件保留字，必须为0 unsigned short int bfReserverd2; //位图文件保留字，必须为0 unsigned long bfbfOffBits; //位图文件头到数据的偏移量，以字节为单位&#125;BITMAPFILEHEADER; typedef struct tagBITMAPINFOHEADER &#123; long biSize; //该结构大小，字节为单位long biWidth; //图形宽度以象素为单位long biHeight; //图形高度以象素为单位short int biPlanes; //目标设备的级别，必须为1 short int biBitcount; //颜色深度，每个象素所需要的位数short int biCompression; //位图的压缩类型long biSizeImage; //位图的大小，以字节为单位long biXPelsPermeter; //位图水平分辨率，每米像素数long biYPelsPermeter; //位图垂直分辨率，每米像素数long biClrUsed; //位图实际使用的颜色表中的颜色数long biClrImportant; //位图显示过程中重要的颜色数&#125;BITMAPINFOHEADER; 12345678910111213141516171819202122232425262728293031323334353637383940414243void RGB2BMP(const char * rgbUrl,int width,int height,const char * bmpUrl)&#123; int i=0,j=0; BITMAPFILEHEADER m_BMPHeader=&#123;0&#125;; BITMAPINFOHEADER m_BMPInfoHeader=&#123;0&#125;; char bfType[2]=&#123;'B','M'&#125;; int header_size=sizeof(bfType)+sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER); unsigned char *rgb24_buffer=(unsigned char *)malloc(width*height*3); FILE *fp_rgb24=fopen(rgb24path,"rb"),*fp_bmp=fopen(bmppath,"wb"); fread(rgb24_buffer,1,width*height*3,fp_rgb24); m_BMPHeader.bfSize=3*width*height+header_size; m_BMPHeader.bfbfOffBits=header_size; m_BMPInfoHeader.biSize=sizeof(InfoHead); m_BMPInfoHeader.biWidth=width; //BMP storage pixel data in opposite direction of Y-axis (from bottom to top). m_BMPInfoHeader.biHeight=-height; m_BMPInfoHeader.biPlanes=1; m_BMPInfoHeader.biBitcount=24; m_BMPInfoHeader.biSizeImage=3*width*height; fwrite(bfType,1,sizeof(bfType),fp_bmp); fwrite(&amp;m_BMPHeader,1,sizeof(m_BMPHeader),fp_bmp); fwrite(&amp;m_BMPInfoHeader,1,sizeof(m_BMPInfoHeader),fp_bmp); //BMP save R1|G1|B1,R2|G2|B2 as B1|G1|R1,B2|G2|R2 //It saves pixel data in Little Endian //So we change 'R' and 'B' for(j =0;j&lt;height;j++)&#123; for(i=0;i&lt;width;i++)&#123; char temp=rgb24_buffer[(j*width+i)*3+2]; rgb24_buffer[(j*width+i)*3+2]=rgb24_buffer[(j*width+i)*3+0]; rgb24_buffer[(j*width+i)*3+0]=temp; &#125; &#125; fwrite(rgb24_buffer,3*width*height,1,fp_bmp); fclose(fp_rgb24); fclose(fp_bmp); free(rgb24_buffer); return 0;&#125; RGB2YUV420P123456789101112131415161718192021222324252627282930313233343536373839int RGB2YUV420P(unsigned char *rgbBuf,int w,int h,unsigned char *yuvBuf)&#123; memset(yuvBuf,0,w*h*3/2); unsigned char *pY,*pU,*pV,*pRGB; pY=yuvBuf; pU=yuvBuf+w*h; pV=yuvBuf+w*h*5/4; unsigned char y,u,v,r,g,b; for (int j = 0; j&lt;h;j++)&#123; pRGB = rgbBuf + w*j*3 ; for (int i = 0;i&lt;w;i++)&#123; r = *(pRGB++); g = *(pRGB++); b = *(pRGB++); y = (unsigned char)( ( 66 * r + 129 * g + 25 * b + 128) &gt;&gt; 8) + 16 ; u = (unsigned char)( ( -38 * r - 74 * g + 112 * b + 128) &gt;&gt; 8) + 128 ; v = (unsigned char)( ( 112 * r - 94 * g - 18 * b + 128) &gt;&gt; 8) + 128 ; //过滤一下y u v的大小 确保在0~255 *(pY++) = y; if (j%2==0&amp;&amp;i%2 ==0)&#123; *(pU++) =u; &#125;else&#123; if (i%2==0)&#123; *(pV++) =v; &#125; &#125; &#125; return 0;&#125; /*Y= 0.299*R+0.587*G+0.114*BU=-0.147*R-0.289*G+0.463*BV= 0.615*R-0.515*G-0.100*B */]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-5.YUV与RGB]]></title>
    <url>%2F2019%2F11%2F26%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-5-YUV%E4%B8%8ERGB%2F</url>
    <content type="text"><![CDATA[RGB先说RGB，人对红绿蓝三种光敏感，可以通过不同的组合达到不同的颜色。需要保存三个数据才能表示一个颜色。忽略RGBA。 YUVY表示明亮度（Luminance或Luma），也就是灰度值，而U和V表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。 内存占比RGB24一帧的大小size＝width×heigth×3 ByteRGB32一帧的大小size＝width×heigth×4 ByteYUV420一帧的大小size=width×heigth×1.5 Byte 结构分析 来源 详细黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量 YUV 4:4:4采样，每一个Y对应一组UV分量。 YUV 4:2:2采样，每两个Y共用一组UV分量。 YUV 4:2:0采样，每四个Y共用一组UV分量。 YUYV（属yuv422）：Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00 UYVY（属YUV422）：同上，只是顺序不同 YUV422P（属YUV422）：同上上，顺序不同 YV12、YU12（属YUV420）： Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00。I420的Cr和Cb互换了。 NV12、NV21（属YUV420）： Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00 I420: YYYYYYYY UU VV =&gt;YUV420PYV12: YYYYYYYY VV UU =&gt;YUV420PNV12: YYYYYYYY UVUV =&gt;YUV420SPNV21: YYYYYYYY VUVU =&gt;YUV420SP 存储空间 以720*480图像，yuv420 Y分量： (720×480)个字节 U(Cb)分量：(720×480&gt;&gt;2)个字节 V(Cr)分量：(720×480&gt;&gt;2)个字节 422与420相互转换422-&gt;420：Y不变， 将U和V信号值隔行抽样。420-&gt;422：Y不变， 将U和V信号值的每一行分别拷贝一份 。 YUV与RGB相互转换转跳1 转跳2 英文 FFmpeg中的SwsContext yuv420p( planar )与yuv420区别数据在内存中的排布不同： yuv420p: yyyyyyyy uuuu vvvvv 在AVFrame的data[]中 0表示Y、1表示U、2表示V linesize[]中 0表示Y的宽度、1表示U的宽度、2表示V的宽度 yuv420: yuv yuv yuv yuv 保存yuv420p123456789101112131415161718192021void saveYUV420p(const AVFrame * pFrame)&#123; int fWidth=pFrame-&gt;width; int fHeight=pFrame-&gt;height; int yBytes=pFrame-&gt;linesize[0]; int uBytes=pFrame-&gt;linesize[1]; int vBytes=pFrame-&gt;linesize[2]; //QFile.write((char *)pFrame-&gt;data[0],fWidth*fHeight); //QFile.write((char *)pFrame-&gt;data[1],fWidth/2*fHeight/2); //QFile.write((char *)pFrame-&gt;data[2].fWidth/2*fHeight/2); for(int i=0;i&lt;fHeight;i++)&#123; QFile.write((char *)pFrame-&gt;data[0]+i*yBytes,fWidth); &#125; for(int i=0;i&lt;fHeight/2;i++)&#123; QFile.write((char *)pFrame-&gt;data[1]+i*uBytes,fWidth/2); &#125; for(int i=0;i&lt;fHeight/2;i++)&#123; QFile.write((char *)pFrame-&gt;data[2]+i*vBytes,fWidth/2); &#125;&#125;]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-4.网络视频传输的服务质量]]></title>
    <url>%2F2019%2F11%2F26%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-4-%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[QoSQoS（Qualityof Service）服务质量，是网络的一种安全机制, 是用来解决网络延迟和阻塞等问题的一种技术。当网络过载或拥塞时，能确保重要业务量不受延迟或丢弃，同时保证网络的高效运行。主要参数有：传输带宽、传输时延和抖动、丢包率。 传输带宽传输带宽也指的是数据传输的速率。 当传输下载速度小于视频流播放数率，则会出现卡顿，解决方法只有选择低品质、低码流的视频进行传输。 传输时延和抖动传输时延定义为从服务器端发送数据到接受端接收到该数据之间的时间差，它是用来描述网络时延的一个指标。 端到端所产生时延由如下原因：1.信息源媒体采样、压缩编码和打包；2.传输；3.接收端排除和播放缓冲；4.接收端拆包、解码和输出。 时延抖动定义为网络传输延时的变化率。一般采用缓存队列平滑数据报的抖动，但是抖动过大需要使用大的缓存空间，有可能影响体验。 丢包率小的丢包率会造成图像的失真和语音的间歇中断，过高的丢包率甚至可以导致业务的中断。]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-3.音视频压缩编码基本原理]]></title>
    <url>%2F2019%2F11%2F26%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-3-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[视频编码基本原理 为什么需要编码 记录数字视频的YUV分量格式为例，YUV分别代表亮度与两个色差信号。其中Y采样频率为13.5MHz，色度信号一般为一半或更少，为6.75或3.375MHz。以4：2：2采样频率为例，采样信号以8bit量化，码率为： 13.5 8 + 6.75 8 + 6.75 * 8 = 216Mbit/s，数字量非常的大，因此需要压缩以减少码率。 视频码率就是数据传输时单位时间传送的数据位数，一般我们用的单位是kbps即千位每秒。通俗一点的理解就是取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件。 哪方面入手压缩 数据冗余。 空间冗余、时间冗余、结构冗余、信息熵冗余等，即图像的各像素之间存在着很强的相关性，可以消除。属于无损压缩。 视觉冗余。利用人眼的特性，亮度辨别阈值、视觉阈值，引入适量误差，以一定的失真换取数据压缩。属于有损压缩。 通常使用变换编码来消去除图像的帧内冗余，用运动估计和运动补偿来去除图像的帧间冗余，用熵编码来进一步提高压缩的效率。 压缩编码的方法 变换编码 作用是将空间域描述的图像信号变换到频率域 ，变换到频率域可以实现去相关和能量集中 ，然后对变换后的系数进行编码处理。 常用的正交变换有离散傅里叶变换，离散余弦变换等等。数字视频压缩过程中应用广泛的是离散余弦变换。 离散余弦变换简称为DCT变换。 它可以将L*L的图像块从空间域变换为频率域。 将图像分成互不重叠的图像块再进行DCT变换。 下图是上图中图像块经过DCT变换后的结果。从图中可以看出经过DCT变换后，左上角的低频系数集中了大 量能量，而右下角的高频系数上的能量很小。 量化过程通过对低频区的系数进行细量化，高频区的系数进行粗量化，去除了人眼不敏感的高频信息，从而降低信息传送量，此处是视频压缩中操作的主要原因。 量化的过程可以用下面的公式表示： 其中FQ（u,v）表示经过量化后的DCT系数；F（u,v）表示量化前的DCT系数；Q（u,v）表示量化加权矩阵；q表示量化步长；round表示归整，即将输出的值取为与之最接近的整数值。 DCT系数经过量化之后大部分经变为0，而只有很少一部分系数为非零值，此时只需将这些非0值进行压缩编码即可。 熵编码 熵编码多用可变字长编码（VLC，Variable Length Coding）实现。其基本原理是对信源中出现概率大的符号赋予短码，对于出现概率小的符号赋予长码，从而在统计上获得较短的平均码长。 可变字长编码通常有霍夫曼编码、算术编码、游程编码等。游程编码的压缩效率不高，但编码、解码速度快。 输出直流系数后对紧跟其后的交流系数进行Z型扫描（如图箭头线所示）。Z型扫描将二维的量化系数转换为一维的序列，并在此基础上进行游程编码。最后再对游程编码后的数据进行另一种变长编码，例如霍夫曼编码。通过这种变长编码，进一步提高编码的效率。 运动估计和运动补偿 消除图像序列时间方向相关性的有效手段。 1和2都是消除同帧图像内的像素在空间上的相关系。但是帧和帧的相关信即时间上的相关系由此进行消除，如果两帧之间背景变化不大，那就没必要每一帧单独进行编码，而只对相信帧中变化的部分进行编码。 运动估计：一般将当前的输入图像分割成若干彼此不相重叠的小图像子块，在前或后帧的搜索范围内为每个子块寻找最相似的图像子块。 运动补偿：计算两个子块会得到一个运动矢量。将当前图像的块与参考图像运动矢量所指向的最相似的图像块相减，得到残差图像块；这样可以得到更高的压缩比。 图像帧分为： I（Intra）帧、B（Bidirection prediction）帧、P（Prediction）帧。 I帧只使用本帧内的数据进行编码，在编码过程中它不需要进行运动估计和运动补偿。 P帧在编码过程中使用一个前面的I帧或P帧作为参考图像进行运动补偿，实际上是对当前图像与参考图像的差值进行编码 。 B帧的编码方式与P帧相似，惟一不同的地方是在编码过程中它要使用一个前面的I帧或P帧和一个后面的I帧或P帧进行预测。 综合 图像经过分块，得到的图像块与经过运动补偿的预测图像相减得到差值图像，然后对差值图像进行DCT变换和量化，量化输出的数据有两个去处：1.送给熵编码器编码，编码后的码流输出到缓存器中，等待传送。2.进行反量化和反变化后得到信号，该信号与运动补偿输出的图像块相加得到新的预测图像信号，并将新的预测图像块送至帧存储器。 音频编码基本原理 为什么需要编码 一套双声道数字音频，取样频率为44.1KHz，每样按16bit量化，则其码率为：2 44.1 16 = 1.411 Mbit/s 哪方面入手压缩 去除不能被人耳感知到的信号（20Hz~20KHz），即听觉范围外的音频信号以及被掩蔽掉的音频信号。当同时存在强弱音频时，掩蔽弱音信号。 频谱掩蔽效应 简单来说，人耳对音频有一定的限制，过高或者过底都听不见，同一音频不同的声贝也有可能听不见。因此可以根据这个条件去掉一部份音频。但是如果某音频的音贝提高了，临近的阈值也会提高，所以可以去除掉这一部份的音频。如下图所示： 0.2kHz处出现60dB的声音时，0.1至1kHz的阈值都升高了，虚线以下的声音都需要去除掉，不必传送。 时域掩蔽效应 当强弹音信号同时发出时，还存在时域掩蔽效应。前掩蔽指听到强信号之前短暂时间内，已经存在的弱信号会被掩蔽而听不到。同时掩蔽指同时存在，弱信号会被强信号掩蔽。后掩蔽指强信号消失后，经一段时间才能重新听见弱信号。被掩蔽的弱信号可视为冗余信号。 压缩编码的方法 对于每个音频声道中的音频采样信号，先从时域映射到频域中（子带滤波器）。音频采样块根据心理声学模型计算掩蔽门限值，由此来决定公共比特池中分配给该声道的不同频率域中多少比特数，接着进行量化以及编码工作，最后结合控制参数及辅助数据，产生编码后的数据流。]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-2.主流协议与编码格式]]></title>
    <url>%2F2019%2F11%2F26%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-2-%E4%B8%BB%E6%B5%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[流媒体协议服务器与客户端之间通信遵循的规定。目前网上主流的媒体协议如下表： 名称 传输层协议 客户端 RTSP+RTP TCP+UDP VLC，WMP RTMP TCP Flash RTMFP UDP Flash MMS TCP/UDP WMP HTTP TCP Flash RTSP(Real-TimeStream Protocol )是一种基于文本的应用层协议，被用于建立的控制媒体流的传输，它为多媒体服务扮演“网络远程控制”的角色。详细 RTMP协议是一个互联网TCP/IP五层体系结构中应用层的协议。RTMP协议中基本的数据单元称为消息（Message）。当RTMP协议在互联网中传输数据的时候，消息会被拆分成更小的单元，称为消息块（Chunk）。 详细 封装格式音视频码流按某种格式存储在一个文件中。如今流行的封闭格式如下： 名称 流媒体(边下边播) 支持的视频编码 支持的音频编码 AVI NO 几乎所有 几乎所有 MP4 YES MPEG-2, MPEG-4, H.264, H.263等 AAC, MPEG-1 Layers I, II, III, AC-3等 TS YES MPEG-1, MPEG-2, MPEG-4, H.264 MPEG-1 Layers I, II, III, AAC FLV YES Sorenson, VP6, H.264 MP3, ADPCM, Linear PCM, AAC等 MKV YES 几乎所有格式 几乎所有格式 RMVB YES RealVideo 8, 9, 10 AAC, Cook Codec, RealAudio Lossless 视频编码主要作用是将视频像素数据（RGB、YUV等）转换成码流，如果不压缩一部电影可达上百G，因此这一步骤非常的重要。命令行使用方式 视频码流分析工具 名称 推出时间 使用领域 备注 HEVC(H.265) 2013 研发中 HM的使用 H.264 2003 各领域 官方标准JM MPEG4 2001 使用率不高 MPEG2 1994 数字电视 VP9 2013 研发中 VP8 2008 不普及 深入 VC-1 2006 微软 H.264仅仅是一个编码标准，而不是一个具体的编码器。瓶颈与解决方法 VP8与H.264 AVS与H.264 音频编码主要 作用是将采集到的（PCM等）压缩成码流，但是一般数据量远小于视频，使用落后的编码标准数据量不会差距很大，主要是为了更高的音质。 名称 推出时间 使用领域 备注 AAC 1997 各个领域 简介 AC-3 1992 电影 MP3 1993 各个领域 WMA 1999 微软 AAC的音频文件格式有以下两种： ADIF：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。这种格式可以用于广播电视。 简言之。ADIF只有一个文件头，ADTS每个包前面有一个文件头。 图中表示出了ADTS一帧的简明结构，其两边的空白矩形表示一帧前后的数据。]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟雷神学音视频-1.FFmpeg处理流程]]></title>
    <url>%2F2019%2F11%2F26%2F%E8%B7%9F%E9%9B%B7%E7%A5%9E%E5%AD%A6%E9%9F%B3%E8%A7%86%E9%A2%91-1-FFmpeg%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介根据雷神介绍，使用FFmpeg进行音视频处理的步骤分为如下： 解协议，解封装，解码，像素转换，编码，封装，发送。这些步骤又可以分为几个不同的层次，如协议层，封装层，编码层，像素层。 图解 存在某协议的数据，在协议层读取数据（可以从设备中读取Device或者从内存中读取Mem Handler），然后在解封装层进行音视频分离（此时也可进行转换封装格式），得到几个不同的音视频位流。现在可以在解编码层进行解码播放音视频，得到原始数据。此时到了像素层，这里可以进行像素格式转换和添加滤镜等效果，这里还是原始数据，到编码层时，可以进行音视频编码，得到音视频位流，再进行音视频封装或者转换得到封装好的数据，最后进行流推送即可。 协议层（Protocol Layer）：该层处理的数据为符合特定流媒体协议规范的数据，例如http，rtmp，file等。 封装层（Format Layer）：该层处理的数据为符合特定封装格式规范的数据，例如mkv，mp4，flv，mpegts，avi等。 编码层（Codec Layer）：该层处理的数据为符合特定编码标准规范的数据，例如h264，h265，mpeg2，mpeg4等。 像素层（Pixel Layer）：该层处理的数据为符合特定像素格式规范的数据，例如yuv420p，yuv422p，yuv444p，rgb24等。 原文链接：https://blog.csdn.net/leixiaohua1020/article/details/42658139 协议层处理包含以下项目： simplest ffmpeg device：使用FFmpeg读取设备中的媒体数据。 simplest ffmpeg mem handler：使用FFmpeg读取内存中的数据。 simplest ffmpeg streamer：使用FFmpeg发送流媒体数据。 封装层处理包含以下项目： simplest ffmpeg format：使用FFmpeg分离音视频（demux），封装音视频（mux），转换封装格式（remux）。 编码层处理包含以下项目： simplest ffmpeg player：使用FFmpeg解码播放视频数据。 simplest ffmpeg audio player：使用FFmpeg解码播放音频数据。 simplest ffmpeg video encoder：使用FFmpeg编码视频数据。 simplest ffmpeg audio encoder：使用FFmpeg编码音频数据。 simplest ffmpeg picture encoder：使用FFmpeg编码图片。 像素层处理包含以下项目： simplest ffmpeg swscale：使用FFmpeg转换像素格式。 simplest ffmpeg video filter：使用FFmpeg给视频添加滤镜效果。 原文链接：https://blog.csdn.net/leixiaohua1020/article/details/42658139 解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。 解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。 解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。 视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。 原文链接：https://blog.csdn.net/leixiaohua1020/article/details/18893769]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[演示五]]></title>
    <url>%2F2019%2F11%2F14%2F%E6%BC%94%E7%A4%BA%E4%BA%94%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[编译QT5.5.1版本OpenCV]]></title>
    <url>%2F2019%2F04%2F21%2F%E7%BC%96%E8%AF%91QT5-5-1%E7%89%88%E6%9C%ACOpenCV%2F</url>
    <content type="text"><![CDATA[前沿因为官方不提供Mingw版本，或者没找到~~~这里选择自己编译一遍。 OpenCV下载 https://opencv.org/releases/ 准备工具CMake与QT5.5.1 本次编译的版本为2.4.13，为目前官方最新版本 编译工作 将下载的OpenCV源码，放于一个文件夹，如下图放于../opencv_2_4_13/sources 创建一个文件夹，用于存放编译完成的文件，下图放于../opencv2_4_13/build_qt 点击Configure弹出对话框，选择MinGW MakeFile和勾选Specify native compilers，点击Next生成makefile 选择QT编译器中的gcc.exe和g++.exe填于对话框中，点击Finish 此时会进行验证 验证通过后，勾选WITH_QT和WITH_OPENGL，其它不动，点击Configure 如果还显示有红色，如下图，再次点击Configure 如果全部都是白色，此时已经配置成功，点击Generate，生成MakeFile 使用CMD打开对应路径，输入mingw32-make make完成 接着进行install 打开生成的目录，include为头文件，x86里面包含lib和dll，收工！！ 编译错误 第一次错误出现在44%的时候，找了半天，需要把源码下的CMakeLists.txt，由ON改成OFF OCV_OPTION(ENABLE_PRECOMPILED_HEADERS “Use precompiled headers” OFF IF (NOT IOS) )]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2019%2F03%2F28%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前沿以前博客的文章，关于Linux常用命令的总结 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199查看类pwd 查看当前路径more 查看文件内容 分屏一页一页显示ls 查看当前路径的文件 -l详细 -a显示所有 -h人性化 -d显示目录属性 -i查id号ls [选项] [参数] []可有可无head [选项] 文件 查看文件首几行 -q隐藏文件 -v 显示文件 -c 显示多少字节 -n 显示文件头多少行tail [选项] 文件 查看文件末几行 -n末多少行 -f循环读 -s与-f同时使用表示休眠多久再读top 动态显示当前最占资源的进程 ps瞬间网络类ifconfig 查看网卡设置netstat -an 查看当前网络连接curl 命令行浏览器 http://www.cnblogs.com/wangkangluo1/archive/2012/04/17/2453975.htmlwget 网址 下载文件到当前目录tracepath ip或网址 查看本地到达目的地所要跳的点和时间mtr ping和tracepath合并 不断的发数据 查看网络丢包比较好ifdown 网卡名 关闭网卡 ifup 开启dhclient 使用dhcp获得新IP -r 释放当前ipnetstat 查看接口信息 -p 打开socket对应程序 -s 显示端口信息Route 查看路由表权限权限10位 第一位类型 -文件 d目录 l软链接 块设备 字符设备 套接字 管道 -rw-r--r--. 2-4所有者u 5-7所属组g 8-10其它o .代表acl权限 r可读取内容 w可写入(不可删除)chmod [选项] 模式 文件名 修改文件权限 chmod u+w abc 给abc的所有者添加读权限chown 用户名 文件名 把文件的所有者变成用户 或者 用户名:用户组 可以同时改变 chgrp 组名 文件 更改文件组信息umask 查看默认权限 默认不能有执行权限 建立文件后 默认权限为666-umask 目录为777-umaskacl权限 dumpe2fs -h 硬盘名 查看是否开启acl权限mount -o remount,acl 分区名 临时开启 在/tct/fstab上修改永久开启编辑目录类touch 创建空文件mkdir -p [目录名] 创建目录 -p创建一个路径 单个文件不需要cd [目录] 切换目录 cd -回到上次 cd .. 回到上一级相对路径 ../usr/local从当前目录上一级查找 绝对路径 /etc/ 从根目录开始rmdir [目录名] 只能删空的目录 不推荐rm -rf [目录名] 强制删除 -f 强制 -r 一直问cp [选项] [目录] [目标目录] 复制 -r复制目录 -p带属性 -d复制链接文件 -a全部mv [目录] [目标目录] 剪切或者改名ln -s [原文件] [目标文件] 生成链接文件 硬链接与原文件有相同I节点和block 可看作同一文件 不能跨分区 不能对目录使用 软链接 与windows快捷方式类似 用-s创建 使用绝对路径搜索命令locate 文件名 速度快 在后台/var/lib/mlocate搜索 新文件搜不到 更新数据库命令updatedb 部份即可搜到 只能搜文件 /etc/updatedb.conf 查看 筛选规则 prunefs不搜索的文件系统 prunenames不搜文件包含关键字 prunepaths不搜目录更新文件whereis 命令名 只搜索命令 -b 只查可执 -m 只查帮助文档which 文件名 与whereis类似 并且显示该命令的别名find [范围] [条件] 占资源多 功能强大 完全匹配 除非用通配符find /root -iname install.log 按名字查找-user root 按所有者 -nouser 查找没有所有者的文件 -mtime +10 查找10天前修改的文件 -10 10天内 atime文件访问时间 ctime改变文件属性 -size +表示大于 -表示小于 查找文件大小写 k M -inum 以id号查找 -a 逻辑与 -o 逻辑或 grep [选项] 字符串 文件名 在文件当中匹配符合条件的字符串 -i忽略大小写 -v取反 *包含匹配*-exec ls -h &#123;&#125; \; 在find之后 使用第二条命令把找到的结果改变通配符 *补充 ？一个字符 []里面的任意一个 需用“”括起 [a-z] [^a-z]取反 [abc] 帮助命令man 命令 获取指定命令帮助 -f 查看该命令有哪些级别 相当于whatis 命令 -k 查找与该命令相关的 相当于apropos 命令命令 --help 获取命令选项 whereis 命令 判断是否为shell内部命令 help cd 获取内部命令帮助info 命令 查看超详细命令 回车 进入子页面 u上层 n下一小节 p上一小节 q退出压缩命令zip 压缩文件名 源文件 压缩文件 -r 压缩目录unzip 文件名 解压缩gzip 源文件 压缩为.gz 源文件会消失 gzip -c 源文件 &gt; 压缩文件 源文件保留gzip -r 目录 压缩目录下的所有子文件 单个 但是不压缩目录gzip -d 文件名 解压缩 或者 gunzip 文件名bzip2 源文件 不保留源文件 -k保留 不能压缩目录 -d解压缩 或者 bunzip2 加-k保留压缩文件tar -cvf 打包文件名 源文件 打包 -c打包 -v显示过程 -f指定打包后的文件名tar -xvf 打包文件名 -x 解打包 -zcvf 压缩名名.tar.gz 源文件 -z压缩为.tar.gz -zxvf 压缩包名.tar.gz -x解压缩.tar.gz -jcvf压缩成tar.bz2 -jxvf 解压缩.tar.bz2 -ztvf 查找该压缩名内有什么关机与重启命令shutdown -r hh:mm &amp;（后台运行） -c取消 -h关机 -r重启 （halt poweroff init 0 直接关机 不推荐） reboot 重启可以使用 init 6runlevel 查找当前运行级别 x y 当前y从x过来 /etc/inittab 查找开机时运行的级别logout 退出当前用户挂载命令 用户登录查看和用户交互命令即分配盘符mount 查询系统已经挂载设备 -a 依据/etc/fstab的内容 自动挂载mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点 -o：exec/noexec 设定是否允许在文件系统中执行可执行文件; remount 重新挂载已经挂载的文件系统如果系统已经挂载的可以不写设备文件名 mount -t ios9660 /dev/sr0 /mnt/cdrom 挂载光盘umount 设备文件名或者挂载点 都一样 卸载挂载点fdish -l 查看系统识别的硬盘，主要用于查看外设备名 光盘默认/dev/sr0 或者/dev/cdrom（软链接）mount -t vfat /dev/sdb1 /mnt/usb/ 挂载u盘 vfat==fat32w命令 查看登录用户信息 who命令 与w类似last命令 查询当前与过去登录用户和时间 /var/log/wtmp数据lastlog命令 查看系统中所有的用户登录时间 /var/log/lastlogecho [选项] [内容] 要使用转义 需要加选项 -e &quot;\e[1;31m \e[0m&quot; 从\e到\e 把里面变成红色vi或者vim 文件名 打开并进入或者创建并进入运行 bash shell文件名 或者 chmod 755 shell文件名 ./shell文件名alias 查看系统命令的 原名 或者 alias vi=&amp;#39;vim&amp;#39;即把vi变成vim unalias 别名 删除别名 vi ~/.bashrc 别名永久生效命令顺序 绝对路径或相对路径的命令 &gt; 别名 &gt; bash的内部命令 &gt; $path上找到的第一个命令history [选项] [历史命令保存文件] 查看历史命令 -c清空 -w写入文件 ~/.bash_history /etc/profile里面可以更改保存数据多少输出重定向命令&gt;文件 覆盖的方式 输出到指定文件或设备 &gt;覆盖 &gt;&gt;追加错误命令 2&gt;文件 2不可缺失 与上面使用类似 但是左不能有空格命令 &gt; 文件 2&gt;&amp;1 正确就输出到文件 错误就把错误写到正确当中 再写到文件 与 &amp;&gt; 一样命令 &gt;&gt;文件1 2&gt;&gt;文件2wc [选项] [文件名] -c统计字节数 -w统计单词数 -l统计行数&lt; 输入重定向 如 wc &lt; 文件 wc &lt;&lt; abc 一直输入到abc 统计之间的数据多命令顺序执行命令1;命令2 一个一个执行 &amp;&amp; ||管道 命令1 | 命令2 将1的正确输出作为2的操作对象 a=123 echo $a 输出123 echo &amp;#39;$a&amp;#39; 输出$a echo &quot;$a&quot; 输出123&amp;#39;&amp;#39; 所有特殊符号都无效 &quot;&quot;除了$(取值) `(引用命令) \(转义) 其他符号无效a=`ls` echo &quot;$aa&quot; 相当于执行ls 相当于 a=$(ls) echo $avi编辑器vi-&gt;vim 支持多级撤销 跨平台 语法高亮 图形界面vim 文件名 打开或者创建文件 vim +x 文件名 光标处于第x行打开或者创建文件 若没有x 即最后一行 vim +/字符串 文件名 打开文件 光标跳到第一次配的行首 vim aa bb cc 即打开aa bb cc文件 以在命令行上输入n向下个文件 N或者prev向上个文件 进入后 属于命令模式 输入 i 转向编辑模式 esc切换至低行模式 输入:wq (w保存 q退出 !即强制 退不出去可强制退出!q) 命令模式连按两个d 删除光标当前行 o在当前行下方插入一行并切换到输入 yy 复制当前行 p在当前行下方粘贴 P上方 :ls 列出打开的文件 :数字 光标跳转 :/xxx 向后匹配 :?xxx向前匹配 kjhi 光标上下左右 ctrl+f向下翻页 +b向上 +d向下半页 +u向上磁盘管理df 查看磁盘分区使用情况 -l显示本地磁盘 a 显示所有文件系统 h人性化 H以1000进制输出单位 T显示磁盘分区类型 t显示指定类型文件系统分区 x不显示du 统计磁盘上文件大小 -b 以byte为单位 k 以kb m以mb h以1024 H以1000 s指定统计目标fdisk 显示硬盘信息（MBR） fdisk 硬盘名 m查看操作信息 看显示信息操作 操作完w即可保存parted 分区工具 （可gpt也可mbr） 输入select 硬盘名 mklabel msdos或者gpt确实格式 mkpart 添加分区 交互式操作 print查看当前分区情况 mkpart 分区名 开始位置M 结束位置M (直接命令生成) rm 分区号 删除分区 mkfs.ext3 /dev/sda 分区格式化 将sda这个分区格式化为ext3 与mkfs -t ext3 /dev/sda效果一样开机自动挂载 /etc/fstab 文件 在末行 设备名称 挂载点 文件类型 defaults 0 0mkswap /dev/sdb 把该分区建立成交换分区 swapon /dev/sdb启动 swapoff关闭 在 fdisk接着t里面设置为82号格式用户信息/etc/group 组名 : 组密码占位符 : 组编号 : 组中用户名列表/etc/gshadow 与group一一对应 组名称 : 组密码 : 组管理者 : 组用户列表/etc/passwd 用户名 密码点位符 编号 组编号 注释信息 主目录 shell类型/etc/shadow 用户名 密码(加密了) 后面没啥用 groupadd 组名 添加组 -g 带编号groupmod -n 改名后名 改名前名 更改组名 -g 编号 组名 更改组编号groupdel 组名 删除组(注意先删除用户)useradd -g 用户组 用户名 添加用户 -d 路径 用户名 指定路径创建用户 -G 接着-g后面 用户组2，用户组3.。。同时添加多用户组usermod -c 备注信息 用户名 给该用户添加备注 -l 后用户名 前用户名 修改用户名 -d 目录 用户名 更改用户目录 -g 新用户组 原用户组 更改用户组userdel 用户名 删除用户 -r包括文件passwd -l 用户名 锁定用户 -u 解锁 -d 不需要密码登录gpasswd -a 用户名 组名 添加用户到该组 该组为附属组 -d为删除newgrp 用户组 切换用户组gpasswd imooc 修改组密码id 用户名 显示用户信息 groups 用户名 显示用户所在组chfn 用户名 设置用户资料finger 用户名 显示详细资料根目录下的文件夹用途bin sbin usr/bin usr/sbin 存放系统命令 bin普通 sbin超级用户boot 启动目录 保存启动数据dev 硬件文件etc 系统默认配置文件home root 用户目录lib 函数库media misc mnt 空目录 挂载使用proc sys 内存过载点 不能动tmp 临时目录usr 系统软件资源var 启动可变文档tab键 一下补全 两下把所有相关的显示上下键 翻出历史命令 !n运行第n条命令 !!运行上一条命令 !字串 重复执行第一个匹配命令ctrl+l清屏ctrl+c或者ctrl+d 强制终止ctrl+a 移动到命令行首ctrl+e 移动到行尾ctrl+z 从光标位删除到行首ctrl+z 把命令放入后台ctrl+r 历史命令]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT数据库之SQLite]]></title>
    <url>%2F2019%2F03%2F26%2FQT%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BSQLife%2F</url>
    <content type="text"><![CDATA[前沿QT中，已经内置了一个专门为数据库操作的库，并且QSqlQuery提供了执行SQL语句并返回结果。并提供了抽象层的QSqlTableModel和QSqlRelationalTableModel。 层次 描述 驱动层 数据库与SQL接口底层桥接，如QSqlDriver、QSqlDriverCreator、QSqlDriverCreatorBase、QSqlDriverPlugin、QSqlResult SQL接口层 QSqlDatabase类提供了数据库访问类、数据库连接操作，QSqlQuery类提供了与数据库的交互操作，还有QSqlError、QSqlField、QSqlTableModel、QSqlRecord 用户接口层 提供从数据库数据到用于数据表示的窗体映射，包括QSqlQueryModel、QSqlTableModel、QSqlRelationalTabl SQLite基于C语言，已经广泛应用各行业。可以直接读写硬盘数据，也可存在内存中，无须服务器进程或引擎。开源，代码量少，注释多。占用内存极少。支持视图、触发器和事务，支持嵌套SQL。提供虚拟机处理SQL语句。不配置、不安装。编程接口易用。 基本使用，插入，更新，删除，查找pro文件上 QT += sql 12345678910111213141516171819202122232425262728293031323334353637QSqlDatabase db;if (QSqlDatabase::contains("qt_sql_default_connection")) //默认库名，如果存在 不需要再设置&#123; db = QSqlDatabase::database("qt_sql_default_connection");&#125; else &#123; db = QSqlDatabase::addDatabase("QSQLITE");//第二个参数可以填一个char *类型，方便下次使用，下次可以用上面的方法直接取到该数据库，而且一个程序中，不需要多次打开库。 db.setHostName("localhost"); db.setDatabaseName("database.db"); db.setUserName("root"); db.setPassword("123456"); &#125; if (!db.open()) &#123; qDebug() &lt;&lt; "open false:" &lt;&lt; database.lastError(); &#125; QSqlQuery sqlQuery; qDebug()&lt;&lt;sqlQuery.exec("drop table girlfriend"); qDebug()&lt;&lt;sqlQuery.exec("create table girlfriend (id int primary key,name varchar(50),money double)");//建表 qDebug()&lt;&lt;sqlQuery.exec("insert into girlfriend values(1,'ming',6.66)"); qDebug()&lt;&lt;sqlQuery.exec("insert into girlfriend values(2,'ning',8.88)"); qDebug()&lt;&lt;sqlQuery.prepare("insert into girlfriend values(?,?,?)"); sqlQuery.bindValue(0,3); sqlQuery.bindValue(1,"ling"); sqlQuery.bindValue(2,9.99); sqlQuery.exec(); sqlQuery.exec(QString("update girlfriend set money=%1 where name = 'ling'").arg(99.99)); sqlQuery.exec("delete from girlfriend where id = 1"); qDebug()&lt;&lt;sqlQuery.exec("select * from girlfriend"); while(sqlQuery.next())&#123; qDebug()&lt;&lt;sqlQuery.value(0)&lt;&lt;sqlQuery.value(1)&lt;&lt;sqlQuery.value(2); &#125; 当前支持数据库 驱动 数据库管理系统 QDB2 IBM DB2及以上 QIBASE Borland InterBase QMYSQL MySQL QOCI Oracle call Interface Driver QODBC ODBC包括微软SQL Server和其它兼容ODBC QPSQL PostgreSQL 6和7 QSQLITE 3及以上 QSQLITE2 2 QTDS Sybase Adaptive Server]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提取HTML信息]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%8F%90%E5%8F%96HTML%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[前沿 有时候需要从HTML文件上找指定标签上的内容，自己平时用QString的字符串操作，比较麻烦，于是网上找了几个库，记录下来。使用平台是windows QT mingw32 HTMLCXX经过使用，该库符合以下几项要求：使用简单，运行高效。将HTML文件夹和CSS文件夹导入工程即可。使用参考下文。这样已经可以满足我们获取标签上的内容。如果还需要获取CSS，可以看htmlcxx.cc，里面有一个很完整的例子。该库还可以编译成.lib导入工程使用。 手册，找不到原出处，贴上博客：https://blog.csdn.net/ictextr9/article/details/6893085 123456789101112131415161718192021222324252627282930313233343536#include &lt;htmlcxx/html/ParserDom.h&gt; ... using namespace std; using namespace htmlcxx; //Parse some html code string html = "&lt;html&gt;&lt;body&gt;hey&lt;/body&gt;&lt;/html&gt;"; HTML::ParserDom parser; tree&lt;HTML::Node&gt; dom = parser.parseTree(html); //Print whole DOM tree cout &lt;&lt; dom &lt;&lt; endl; //Dump all links in the tree tree&lt;HTML::Node&gt;::iterator it = dom.begin(); tree&lt;HTML::Node&gt;::iterator end = dom.end(); for (; it != end; ++it) &#123; if (strcasecmp(it-&gt;tagName().c_str(), "A") == 0) &#123; it-&gt;parseAttributes(); cout &lt;&lt; it-&gt;attribute("href").second &lt;&lt; endl; &#125; &#125; //Dump all text of the document it = dom.begin(); end = dom.end(); for (; it != end; ++it) &#123; if ((!it-&gt;isTag()) &amp;&amp; (!it-&gt;isComment())) &#123; cout &lt;&lt; it-&gt;text(); &#125; &#125; cout &lt;&lt; endl; GUMBO该库完全由C99编写。另外有C++版本（https://github.com/lazytiger/gumbo-query） 官方设定： 完全符合HTML5规范。 坚固耐用，输入不良。 简单的API，可以很容易地被其他语言包装。 支持源位置和指针返回原始文本。 支持片段解析。 相对轻量级，没有外部依赖性。 传递所有html5lib测试，包括模板标记。 测试了谷歌指数超过25亿页。 根据官方介绍，进行编译，在QT mingw32下，直接导入源文件也能使用。或者编译出.h lib*.a .dll导入工程即可。数据结构大概参考下图，下图省略了很多小标签，结构非常值得参考。 图片转自 12345678910 使用下面两个方式，将html字符串传入，得到GumboOutput*的一个结构体，可以从该结构体中获取到想要的数值。 方式一： GumboOutput* output = gumbo_parse(contents.c_str());//do something gumbo_destroy_output(&amp;kGumboDefaultOptions, output); 方式二： GumboOutput* output = gumbo_parse_with_options( &amp;kGumboDefaultOptions, contents.data(), contents.length());//do something gumbo_destroy_output(&amp;kGumboDefaultOptions, output); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647官方示例，实际用得不深入，以后还会另开博客写该类。简单介绍下example，为查找A标签的href属性值#include &lt;stdlib.h&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include "gumbo.h"static void search_for_links(GumboNode* node) &#123; if (node-&gt;type != GUMBO_NODE_ELEMENT) &#123;//不是元素，递归返回 return; &#125; GumboAttribute* href; if (node-&gt;v.element.tag == GUMBO_TAG_A &amp;&amp; (href = gumbo_get_attribute(&amp;node-&gt;v.element.attributes, "href"))) &#123;//是A标签，gumbo_get_attribute查找href属性，如果找到就返回，找不到返回NULL，不区分大小写 std::cout &lt;&lt; href-&gt;value &lt;&lt; std::endl; &#125; GumboVector* children = &amp;node-&gt;v.element.children;//指向子结点 for (unsigned int i = 0; i &lt; children-&gt;length; ++i) &#123; search_for_links(static_cast&lt;GumboNode*&gt;(children-&gt;data[i]));//递归查找 &#125;&#125;int main(int argc, char** argv) &#123; if (argc != 2) &#123; std::cout &lt;&lt; "Usage: find_links &lt;html filename&gt;.\n"; exit(EXIT_FAILURE); &#125; const char* filename = argv[1]; std::ifstream in(filename, std::ios::in | std::ios::binary); if (!in) &#123; std::cout &lt;&lt; "File " &lt;&lt; filename &lt;&lt; " not found!\n"; exit(EXIT_FAILURE); &#125; std::string contents; in.seekg(0, std::ios::end); contents.resize(in.tellg()); in.seekg(0, std::ios::beg); in.read(&amp;contents[0], contents.size()); in.close(); GumboOutput* output = gumbo_parse(contents.c_str());//将从文本读到的html字符串传入，获得GumboOutput结构体 search_for_links(output-&gt;root); gumbo_destroy_output(&amp;kGumboDefaultOptions, output);//析构结构体&#125;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>LIBARY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIOS与系统引导]]></title>
    <url>%2F2019%2F03%2F19%2FBIOS%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[前言从某书上看到，记录下来~~ BIOSBasic Input/Output System，输入输出系统。当CPU的复位引脚被触发，在0xfffffff0处执行一条命令，转跳到ROM中的启动代码，并开始执行，这些代码称为BIOS。 主要作用硬件自检（BIOS自检、上电自检POST），检测系统外围关键设备是否正常。如果自检发现严重故障，直接停机，没有任何提示或者信号，非严重故障，出现提示或者报警信号。 引导设备在BIOS中需要设定一个顺序，在自检完成之后，按顺序将控制权转交给外部设备。 系统引导PC引导（bootloader）分两部分，主引导记录（MBR），引导位于某个分区上的第二部分引导程序，如NTLDR、BOOTMGR、GRUB。主引导主要告诉计算机，硬盘哪个位置找操作系统，1~446字节：调用操作系统的机器码，447~510：分区表，511~512：主引导记录签名（0x55和0xAA） 从BIOS上获取到控制权后，读取该设备的第一扇区（前512字节），如果最后两字节为0x55和0xAA，就表明设备可以启动，否则将控制权移到下一设备。 分区分区表长度64字节，分为4项，每项16字节，所以一个硬盘最多只有4个一级分区（主分区）。第1字节：0x80表示主分区激活，一级分区只能有一个是激活的。2~4字节：主分区第一扇区的物理地址（柱面、磁头、扇区号等）。5：主分区类型。6~8：主分区最后一个扇区的物理位置。9~12：第一个扇区的逻辑地址。13~16：主分区的扇区总数。所以一个分区最大为扇区大小*(2^32)。 系统在激活的主分区：计算机会读取激活分区的第一个扇区，激活分区叫作卷引导记录（VBR），此时会加载操作系统。 系统在逻辑分区：分区表只有四项，因此规定了其中一个区可以定义成扩展分区，在该分区中又有多个逻辑分区。先读取第一个扇区扩展引导记录EBR，里面也包含一张64字节的分区表，分区表分为两项，描述第一个逻辑分区和描述第二个逻辑分区，这样可以完成无限个分区连续。如果要启动这个分区上的系统，需要事先安装好启动管理器，如GRUB，这意味着第二部分代码启动了，在此选择启动系统。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTTP运作]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%B5%85%E8%B0%88HTTP%E8%BF%90%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[HTTP超文本传输协议该协议主要应用于应用层，用于传输两个计算机之间的文件。主要是Web服务器和客户端。 HTTP定义了一个GET方法，如果客户端想要数据，就发送HTTP GET请求，并列出文件名。如果Web决定回应，即返回码200，表示OK和响应内容。404即找不到文件。 网页上的文件称为对象，如文本、图形、动画、音视频等。想要获取这些数据，必须得到第一个文件，才能通过访文件内包含的URL获取更多，即先进入别人的网站才能获取资源。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>NETWORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈TCP与UDP]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%B5%85%E8%B0%88TCP%E4%B8%8EUDP%2F</url>
    <content type="text"><![CDATA[两者优势既然TCP和UDP同时存在于传输层，那么各自都有不可取代的优势。首先，两都都可以根据端口号正确选择对应的应用程序（多路复用）。TCP提供的是可靠性连接，带有错误恢复，有序数据传输和数据分段，避免拥塞。而UDP报头数据比TCP少，在传输过程中开销少，并且不会像TCP一样进行避免拥塞，而减慢传输效率。 TCP报头 源端口 目标端口 序列号 确认数 偏移量 保留 代码位 窗口 校验和 紧急标志 第行4字节，共20字节，TCP字段（L4PDU、数据段） 多路复用计算机会运行很多软件，同时会发送很多数据，而接收回来的数据TCP和UDP多路复用让计算机知道将数据交给哪个应用。是基于socket实现的，而socket由3部分组成：IP地址、端口号、传输协议，这样的组合可以完成唯一定位。客户方发送时，端口动态分配1024以后，服务端口号必须已知，侦听连接客户端请求。 TCP三次握手TCP连接指的是两个套接字之间的连接。通过 客户向服务发送SYN。服务向客户发送SYN,ACK。客户向服务发送ACK。完成连接。由于IP地址记录在IP报头，所以TCP报头只记录端口号即可。 SYN：同步化序列号。ACK：指目前接收的确认值，附带滑动窗口大小。 终止连接：ACK,FIN。ACK，ACK,FIN。ACK。第二步骤发送的第一条ACK为告知客户，已经收到，防止多次发送。统称为面向连接。而UDP则无连接。 面向连接：需要在传输数据之前交换消息或需要在两个端点间预先设立关联协议 无连接：不需要交换消息或不需要在终端之间预先设定关联的协议 TCP错误确认客户向服务发送数据 1000字节，序列号0 1000字节，序列号1000 1000字节，序列号2000 1000字节，序列号3000如果服务端回复无数据，确认值4000，那么客户就发送下一组。如果服务回复无数据，确认值2000，表明接收了2000字节，所以发送序列号为2000的那组，以完成数据错误恢复。错误时，客户会等待，并不会发送下一组，启动一个计时器。 滑动窗口（Slice Window）TCP使用窗口概念实现了流量控制。应用在待解决和待确认状态的数据。是接收主机告知发送主机可以接收多少数据，然后发送主机根据实际进行加减速发送。而接收主机是根据是否丢数据段或者网络堵塞现象来进行判断。 UDP为应用程序提供服务，使它们能够交换消息。提供无连接，不使用窗口技术，不对数据排序，也不把大数据分成小数据。但是实现了数据传输和多路复用。所以开销低。但是需要容忍数据丢失，或者有恢复丢失数据的程序机制。 UDP报头 源端口 目标端口 长度 校验和 每行4字节，共8字节]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>NETWORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[㳀谈域名解析与地址解析]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[域名解析DNS因IP地址为数字，这是不能接受的，因此产生域名，将域名和IP绑定在一起。 将主机名发送到DNS服务器，服务器解析后，返回对应的IP地址，然后再发送对应的数据包。 IP地址分布在多个DNS服务器上，通过协同工作，彼此转发查询获取IP地址信息。 使用UDP的IP数据包发送。 地址解析协议ARP主机和路由间是不知道互相的MAC地址的，但是数据链路转发时需要知道MAC地址。所以产生ARP。 概念：是LAN上任何主机或路由动态获取同一LAN上另一台IP主机或路由器MAC地址的方法。定义了一个包含ARP请求的协议和ARP回复，列出源IP地址和相匹配的MAC地址。主机会记录ARP结果，存在ARP缓存或ARP表中。 统一资源定位符URL用户使用Web服务时，可以输入一个URL去确定一个想要获取的Web网页。 http://www.bugnull.com/index.html 其中http是方案（协议） www.bugnull.com 是授权机构（服务器的名称） index.html是路径（Web页面）]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>NETWORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[㳀淡路由转发]]></title>
    <url>%2F2019%2F03%2F10%2F%E3%B3%80%E6%B7%A1%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[路由转发逻辑检查数据链路FCS，确定帧没有错误；删除帧中旧的数据链路报头和报尾，留下IP数据包。将IP数据包的目的IP地址与路由表比较，找到与目标地址相匹配的路由。将IP数据包封装进新的输出接口的数据链路报头和报尾，转发。直到数据包到达最终目的地。 路由器在匹配目的IP时，会考虑网络号所在的地址组，网络号和子网号代表一组以相同前缀开头的地址。 MAC地址是通过数据链路进行传输，传输到该MAC的网口上，网口复制该信息，然后检验FCS，查找目的IP与路由表，并将下一跳的MAC写入，转发。 路由选择协议的目的动态地获知到网络中所有子网的路由，并加入到路由表中，只保存最佳路由，及时检查路由表的有效性失效就删除，若删除了一条路由，若发现新途径，则添加。尽快找替代失效的路由，花费的时间称收敛时间。防止环路。 每一台路由都为直接与其连接的各个子网在其路由表中添加一条路由。都把自己所存的表告知相邻的路由。从相邻路由获知新路由后，路由选择协议将在路由表中添加一条路由，该路由器获知的来源通常就是下一跳的相邻路由器。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>NETWORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈IPv4寻址]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%B5%85%E8%B0%88IPv4%E5%AF%BB%E5%9D%80%2F</url>
    <content type="text"><![CDATA[前沿IP定义了网络层地址，然后路由根据它来识别与TCP/IP网络连接的任何主机或路由器接口。TCP/IP将IP地址编制成地址组，位于同一地址组里的IP地址使用的物理网络是相同的。路由器根据该地址组可以将每个IP网络或IP子网的整体列成一个路由表，而不是每个单个IP地址一个表项。 寻址的规则设备必须有一个IP地址，由32位数字组成。能够收发IP数据包的设备都称为IP主机。 IP地址分组原理TCP/IP把IP地址编成一系列连续地址组的最初的详细说明称为IP网络。同一网络中的所有地址的第一部分数值都是相同的。（同一地址组里的所有IP地址不能被路由器分隔；被路由器分融的IP地址必须属于不同的地址组） A、B、C类IP网络号IP地址前8位即十进制第一个数字，1~126为A类，B类以128~191，C类192~223，前三类都为单播地址。224~239定D类多播地址，可以将数据包发送给多台主机。 A类网络：以1-126开头，每个网络可以存在256 256 256-2个主机。全0（网络号）全1（广播地址，因此减去2） B类网络：以128-191开头，并且与第二位十进制组合，每个网络可以存在256*256-2个主机 C类网络：以192-223开头，道孚县与第二第三位十进制组成，可以包含254个主机 IP子网划分子网划分定义了细分IPv4地址空间的方法，可以将单独的IP网络进一步细分 成许多较小的组。类似的如果使用一个B类网络对一个LAN进行配置，将LAN中每个路由上都配上B类网络的子网，如150.1.1.0，可以节省非常多的IP地址，当然也可以用多个B类网络进行配置~~~~ IPv4路由选择如果目的IP地址与源主机在同一个子网内，直接把数据包发送给目的主机；否则，把数据包发送给源主机默认网关。 IPv4报头 版本 报头长度 DS字段 数据包长度 标识 标志位 分段偏移 生存周期 协议 报头校验和 源IP地址 目的IP地址 总共20字节 每一行4字节]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>NETWORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈以太网]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%B5%85%E8%B0%88%E4%BB%A5%E5%A4%AA%E7%BD%91%2F</url>
    <content type="text"><![CDATA[以太网概念：一系列的LAN协议和标准，定义了最常见的有线LAN技术类型中的物理层和数据链路层。由美国电气和电子工程师协会IEEE制定，并以数字802.3作为起始部分进行命名。 以太网的类型根据速率和电缆类型分为10BASE-T、100BASE-T、1000BASE-LX、1000BASE-T、10GBASE-T（速率单位为Mbps） 以太网链路两个以太网节点间的所有物理电缆。 直连与交叉：因为规定RJ45是通过12引角发送36引脚接收，45发送78接收；常用的电缆为UTP（非屏蔽双绞线）。为了方便，集线器和交换机做成36引脚发送，可以不使用路线直接相连。 常用以太网帧 字段 字段长度 描述 前导码 7 同步 开妈帧分隔符 1 表示下一个字节开始将是目的MAC 目的MAC 6 标识该帧的预订接收方 源MAC 6 标识该帧的发送方 类型 2 定义了帧中所含协议类型：IPv4 IPv6等 数据和填充 46-1500 存储高层数据。不足46需要自动填充 帧检验序列 4 为接收方网卡提供判断帧完整的方法 以太网寻址以太网地址称为MAC（介质访问控制），是一个12位十六进制数。大多数MAC标识一个单独的网卡或其它以太网口，称为单播以太网地址。由IEEE和制造商确保MAC的不重复性。广播地址：标识LAN中所有设备的地址。多播地址：在以太网中，多播地址表示以太网LAN中当前所有设备的子集。 全双工和半双工全双工指可以边发送，边接收以太网帧。半双工指接收以太网帧时，不能同时发送。使用半双工是由于LAN集线器，因为集线器在同一时间接收多个信号，电信号就会发生冲突，以至于无法识别，属于物理层硬件。 半双工机制：CSMA/CD（载波侦听多路访问/冲突检测）有一设备发送帧时，同一集线器内所有设备会同时接收该帧，所以不会再发送，但是还是会出现同时发出的情况，所以这里，同时发送设备都取消，随机一个等待时间，再发送，直到发出去为止。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>NETWORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈TCP/IP与OSI网络模型结构]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%B5%85%E8%B0%88TCP-IP%E4%B8%8EOSI%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[TCP/IP网络模型TCP/IP模型按层分可以分为五层（最初的模型只有四层，将链路层拆分为数据链路层和物理层）。每一层都包含与该功能分类相关的协议和标准。 四层（应用层，传输层，互联网层，链路层） 五层（应用层，传输层，网络层，数据链路层，物理层） 应用层为运行在计算机上的应用软件提供服务。常用协议：HTTP超文本传输协议，POP3邮局协议3，SMTP简单邮件传输协议 传输层为应用层提供服务。常用协议：TCP传输控制协议，UDP用户数据报协议 网络层最重要的是寻址和路由选择。协议：IP互联网协议。 寻址：每台TCP/IP主机都需要有一个独一无二的地址，以便被识别；将地址分组。 路由选择：利用IP协议，将IP数据包传输到另一个设备的服务。 链路层定义了通过物理网络来传递数据所需的协议和硬件。链路指两个设备间的物理连接或链路，并通过协议来控制。路层会根据网络层的要求，完成具体发送数据包的工作。常用协议：PPP点到点协议、以太网、HDLC高级数据链路控制 数据名称应用层产生数据在传输层增加报头则产生数据段，网络层增加IP报头内则产生数据包，数据链路层增加报头和报尾产帧。 OSI网络模型OSI模型分为七层，与TCP/IP比较类似。 七层（应用层，表示层，会话层，传输层，网络层，数据链路层，物理层）每层的数据名称根据层号来分，以物理层为第一层，所以网络层的数据名称为L3PDU 第三层协议数据单元。 应用层提供应用程序与网络之间的接口。 表示层协商数据格式。 会话层提供多个双向消息分组到一个工作流的方法。 其它几层功能与TCP/IP类似。 分层协议的优点降低复杂性，将概念细分成多个小部分，达到解耦。标准化接口。互用性，只要遵守标准开发的产品，都可以在同一个网络中工作。模块化。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>NETWORK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[演示四]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%BC%94%E7%A4%BA%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[演示三]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%BC%94%E7%A4%BA%E4%B8%89%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[演示二]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%BC%94%E7%A4%BA%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[二进制文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[演示一]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%BC%94%E7%A4%BA%E4%B8%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[QT的衣服--样式表]]></title>
    <url>%2F2019%2F03%2F01%2FQT%E7%9A%84%E8%A1%A3%E6%9C%8D-%E6%A0%B7%E5%BC%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[之前一直想找本书，介绍各个控件的样式表与子部件，发现并没有，只能通过官方网站的介绍（甩网址三连）： 样式表的作用 样式表参考 样式表例子 一、设定样式表1231.通过UI设置“改变样式表”,将对应的样式表写进去2.通过代码设置，控件使用setStyleSheet(QString)3.通过文件，读取文本，将文本使用setStyleSheet(QString)写入qApp中 二、指定对象设置样式表123456789101112131415类中有多个按钮，但是需要设置成不同的样子QPushbutton btn1,btn2,btn3;1.btn1.setStyleSheet("");btn2.setStyleSheet("");btn3.setStyleSheet("");2.btn1.setObjectName("btn1");btn2.setObjectName("btn2");btn3.setObjectName("btn3");this.setStyleSheet("QPushbutton#btn1&#123;&#125;QPushbutton#btn2&#123;&#125;QPushbutton#btn3&#123;&#125;");类#类名::子部件:伪状态&#123;&#125; 应该是这个形式了还有一个更复杂的，修改QTabWidget的QTabBar点击下去的属性QTabWidget#tabWidget QTabBar::tab:selected&#123;&#125; 样式表学习可以通过CSS，因为有时候有点迷，找前端的妹子问一下，就可以了~~~两者相似度估计达80% 因为每个控件都有自己独特的样式表，列举不完，而且也比较菜~~~~经验自己总结总结，本人也会总结，看情况再更新这个吧。打个赌，哈哈。2019-03-02 16:38-58]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路径的集合QPainterPath]]></title>
    <url>%2F2019%2F02%2F26%2F%E8%B7%AF%E5%BE%84%E7%9A%84%E9%9B%86%E5%90%88QPainterPath%2F</url>
    <content type="text"><![CDATA[经常把这个跟QPainter结合使用，比较方便~~~ 12345678QPainterPath是一个集合，比如我要画个矩形，不通过addRect方法，使用lineTo，它会保存当前点，如QPainterPath path;path.moveTo(10,10);path.lineTo(20,10);path.lineTo(20,20);path.lineTo(10,20);path.lineTo(10,10);以上一个点为终于，不需要设置，如果从来 可以调用void closeSubpath(); 一、API介绍 函数名 意义 void closeSubpath(); 将当前点设回（0，0） void moveTo(const QPointF &amp;p); 将当前点移动到某点 inline void moveTo(qreal x, qreal y); void lineTo(const QPointF &amp;p); 从当前点画直线到某点 inline void lineTo(qreal x, qreal y); void arcMoveTo(const QRectF &amp;rect, qreal angle); 移动到某点，计算方式为以某矩形为外接矩形的angle角度处 inline void arcMoveTo(qreal x, qreal y, qreal w, qreal h, qreal angle); void arcTo(const QRectF &amp;rect, qreal startAngle, qreal arcLength); 从当前点画圆弧 inline void arcTo(qreal x, qreal y, qreal w, qreal h, qreal startAngle, qreal arcLength); void cubicTo(const QPointF &amp;ctrlPt1, const QPointF &amp;ctrlPt2, const QPointF &amp;endPt); 三次样条曲线，c1和c2为控制点 inline void cubicTo(qreal ctrlPt1x, qreal ctrlPt1y, qreal ctrlPt2x, qreal ctrlPt2y,qreal endPtx, qreal endPty); void quadTo(const QPointF &amp;ctrlPt, const QPointF &amp;endPt); 二次样条曲线， c为控制点 inline void quadTo(qreal ctrlPtx, qreal ctrlPty, qreal endPtx, qreal endPty); QPointF currentPosition() const; 当前位置 void addRect(const QRectF &amp;rect); 插入一个矩形 inline void addRect(qreal x, qreal y, qreal w, qreal h); void addEllipse(const QRectF &amp;rect); 插入一个圆 inline void addEllipse(qreal x, qreal y, qreal w, qreal h); inline void addEllipse(const QPointF &amp;center, qreal rx, qreal ry); void addPolygon(const QPolygonF &amp;polygon); 插入一个多边形 void addText(const QPointF &amp;point, const QFont &amp;f, const QString &amp;text); 插入文字 inline void addText(qreal x, qreal y, const QFont &amp;f, const QString &amp;text); void addPath(const QPainterPath &amp;path); 添加一个路径 void addRegion(const QRegion &amp;region); //Adds the given region to the path by adding each rectangle in the region as a separate closed subpath. void addRoundedRect(const QRectF &amp;rect, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize); 添加圆角矩形 inline void addRoundedRect(qreal x, qreal y, qreal w, qreal h,qreal xRadius, qreal yRadius,Qt::SizeMode mode = Qt::AbsoluteSize); void addRoundRect(const QRectF &amp;rect, int xRnd, int yRnd); inline void addRoundRect(qreal x, qreal y, qreal w, qreal h,int xRnd, int yRnd); inline void addRoundRect(const QRectF &amp;rect, int roundness); inline void addRoundRect(qreal x, qreal y, qreal w, qreal h,int roundness); void connectPath(const QPainterPath &amp;path); 以当前结束点为起点 添加path bool contains(const QPointF &amp;pt) const; 是否包含该点 bool contains(const QRectF &amp;rect) const; 是否包含该矩形 bool intersects(const QRectF &amp;rect) const; 是否与之相交 void translate(qreal dx, qreal dy); 平移 inline void translate(const QPointF &amp;offset); QPainterPath translated(qreal dx, qreal dy) const Q_REQUIRED_RESULT; inline QPainterPath translated(const QPointF &amp;offset) const Q_REQUIRED_RESULT; QRectF boundingRect() const; 返回外接矩形 QRectF controlPointRect() const; 比boundingRect快 是它的超集 Qt::FillRule fillRule() const; void setFillRule(Qt::FillRule fillRule); bool isEmpty() const; QPainterPath toReversed() const Q_REQUIRED_RESULT; 返回一个反向路径 QList toSubpathPolygons(const QMatrix &amp;matrix = QMatrix()) const; 返回路径吧 底下几个都有点像 QList toFillPolygons(const QMatrix &amp;matrix = QMatrix()) const; QPolygonF toFillPolygon(const QMatrix &amp;matrix = QMatrix()) const; QList toSubpathPolygons(const QTransform &amp;matrix) const; QList toFillPolygons(const QTransform &amp;matrix) const; QPolygonF toFillPolygon(const QTransform &amp;matrix) const; int elementCount() const; QPainterPath::Element elementAt(int i) const; void setElementPositionAt(int i, qreal x, qreal y); qreal length() const; qreal percentAtLength(qreal t) const; QPointF pointAtPercent(qreal t) const; qreal angleAtPercent(qreal t) const; qreal slopeAtPercent(qreal t) const; bool intersects(const QPainterPath &amp;p) const; bool contains(const QPainterPath &amp;p) const; QPainterPath united(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; QPainterPath intersected(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; QPainterPath subtracted(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; QPainterPath subtractedInverted(const QPainterPath &amp;r) const Q_REQUIRED_RESULT; 二、从QPainterPath中获取所有数据并绘制出来（包括文字轮廓，文字轮廓也可以用FreeType~~~~）1234567891011121314QPainterPath path;path.addRect(30,30,30,30);path.addText(100,100,QFont("宋体",80),"135赟");QList&lt;QPolygonF&gt; list=path.toSubpathPolygons();for(int i=0;i&lt;list.size();i++)&#123; QPolygonF polygonF=list[i]; //p.drawPolygon(polygonF); //方法一 for(int j=1;j&lt;polygonF.size();j++)&#123; p.drawLine(polygonF.at(j-1),polygonF.at(j)); //可以获取到各个点 &#125;&#125;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神奇的QPainter]]></title>
    <url>%2F2019%2F02%2F22%2FQPainter%E7%A5%9E%E5%A5%87%E7%9A%84%E7%94%BB%E7%AC%94%2F</url>
    <content type="text"><![CDATA[前沿很多很好看的控件，都不是通过样式表设定样式出现的，而是通过自绘控件或者QStyle或者代理，这几种方式，都会有QPainter的出现！对于一个widget，只能有一个激活的QPainter进行绘制，会打架的！设定有两种方式，一种是构造函数，一种是begin。 QT没有采用二维笛卡尔坐标，以屏幕左上角为原点，向右为X+，向下为Y+。可以使用setWindow实现， 一、API 函数名 意义 QPainter(); explicit QPainter(QPaintDevice *); 构造并且指定绘制的控件 QPaintDevice *device() const; 返回指定的控件 bool begin(QPaintDevice *); 在该控件绘制 bool end(); 结束绘制 bool isActive() const; 是否绘制 void initFrom(const QPaintDevice *device); 以device初始化pen font background const QFont &amp;font() const; 绘制字体时的字体 void setFont(const QFont &amp;f); 指定一个字体 void setPen(const QColor &amp;color); 几种设定画笔的方式 void setPen(const QPen &amp;pen); void setPen(Qt::PenStyle style); const QPen &amp;pen() const; void setBrush(const QBrush &amp;brush); 设定QBrush 用于指定填充颜色 void setBrush(Qt::BrushStyle style); 不需要时可以 setBrush(Qt::NoBrush) const QBrush &amp;brush() const; void setBackgroundMode(Qt::BGMode mode); 设定透明或者不透明模式 没用过 0_0 Qt::BGMode backgroundMode() const; QPoint brushOrigin() const; 用意不明 设定填充的起点 inline void setBrushOrigin(int x, int y); inline void setBrushOrigin(const QPoint &amp;); void setBrushOrigin(const QPointF &amp;); void setBackground(const QBrush &amp;bg); 设定背景色 const QBrush &amp;background() const; qreal opacity() const; 设定不透明度 void setOpacity(qreal opacity); QRegion clipRegion() const; 设定一个区域，只能在该区域绘图 QRegion可以用来求面积相交的部分 QPainterPath clipPath() const; void setClipRect(const QRectF &amp;, Qt::ClipOperation op = Qt::ReplaceClip); void setClipRect(const QRect &amp;, Qt::ClipOperation op = Qt::ReplaceClip); inline void setClipRect(int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip); void setClipRegion(const QRegion &amp;, Qt::ClipOperation op = Qt::ReplaceClip); void setClipPath(const QPainterPath &amp;path, Qt::ClipOperation op = Qt::ReplaceClip); void setClipping(bool enable); bool hasClipping() const; QRectF clipBoundingRect() const; void save(); 大有用处！保存和恢复pen brush 变换（rotate,translate,scale,shear） void restore();(World Coordinates)==&gt;(Window Coordinates)==&gt;(Device Coordinates) 世界坐标（逻辑坐标） 世界变换 窗口坐标 窗口视图变换 设备坐标 | || void setTransform(const QTransform &amp;transform, bool combine = false); | 修改世界变换 替换了setWorldMatrix || const QTransform &amp;transform() const; | || const QTransform &amp;deviceTransform() const; | || void resetTransform(); | || void setWorldTransform(const QTransform &amp;matrix, bool combine = false); | || const QTransform &amp;worldTransform() const; | || void scale(qreal sx, qreal sy); | 缩放 || void shear(qreal sh, qreal sv); | 剪切 || void rotate(qreal a); | 旋转 || void translate(const QPointF &amp;offset); | 平移 || inline void translate(const QPoint &amp;offset); | || inline void translate(qreal dx, qreal dy); | || QRect window() const; | 修改窗口绘图坐标 设定绘图区域范围是多少 如 0,0 100,100 右下角就是100，100 || void setWindow(const QRect &amp;window); | || inline void setWindow(int x, int y, int w, int h); | || QRect viewport() const; | 修改视图绘图坐标 设定绘图区域范围 如 0,0 100,100 那么只在这个矩形内画图，并且100，100这个点对应的范围是 window的右下角 || void setViewport(const QRect &amp;viewport); | || inline void setViewport(int x, int y, int w, int h); | || void setViewTransformEnabled(bool enable); | || bool viewTransformEnabled() const; | || void scale(qreal sx, qreal sy); | 缩放 || void shear(qreal sh, qreal sv); | 扭曲 || void rotate(qreal a); | 旋转 | QPainter内置的一些图形，如果有更多的需求，配合QPainterPath实现 函数名 意义 void strokePath(const QPainterPath &amp;path, const QPen &amp;pen); 绘制path的轮廓 void fillPath(const QPainterPath &amp;path, const QBrush &amp;brush); 绘制path的填充区域 void drawPath(const QPainterPath &amp;path); 绘制path drawPoint 画一个点 drawPoints 画几个点 drawLine 画一条线 drawLines 画几条线 drawRect 画一个矩形 drawRects 画几个矩形 drawEllipse 画正圆或者椭圆 drawPolyline 画多段线 drawPolygon 画多边形 drawConvexPolygon 画凸多边形 drawArc 画圆弧，参数只能传整数，若画90度，角度参数传90*16 drawPie 画饼图，参数只能传整数，若画90度，角度参数传90*16 drawChord 画弦图 drawRoundedRect 画圆角矩阵，百份比 drawRoundRect 画圆角矩阵，度数 drawPicture 画.pic图片 drawPixmap 画位图 若是QBitmap则是使用pen的颜色绘制 QPixmap则使用原图 drawPixmapFragments 同时绘制多个pixmax或者子图 带优化 drawImage 画QImage 二、简单使用1234567891011//实现父类虚函数void paintEvent(QPaintEvent *e)&#123; //一 QPainter painter(this); //二 QPainter painter; painter.begin(this); painter.end();&#125; 三、QT坐标转笛卡尔坐标（setWindow，setViewport）1234567891011因为QT的QPainter坐标是以左上角为原点，与迪卡尔坐标不一样，所以我当时做的操作是x=_x;y=(-_y)+height(); y轴先与x轴对称，然后平衡一个屏幕的高度，完成转换笛卡尔坐标操作 当然这也有好处，全部东西都由自己控制二、void setWindow(const QRect &amp;window);void setViewport(const QRect &amp;viewport);最近才发现这两个函数，这样解释一下，setWindow有四个参数x,y,w,h，前两个参数是设定图像左上角的坐标，右角坐标为 x+w,y+h 用这个函数可以直接实现笛卡尔坐标系（左下角为原点）setWindow(0,height(),width(),-height()); 这个意思体会体会setViewport 就是设定绘画的区域 目前没有找到哪里合适用 四、类中子控件绘制123456789101112131415161718192021子控件是QWidget的派生类： 在类中重写void paintEvent(QPaintEvent *e);进行相应的绘制就行子控件不是QWidget的派生类，但是想在类中绘制，可以使用拦截事件： QWidget *paintWidget=new QWidget(); paintWidget-&gt;installEventFilter(this); 接着重载事件过滤事件 bool eventFilter(QObject *o, QEvent *e)&#123; if(o==paintWidget)&#123; if(e-&gt;type()==QEvent::Paint)&#123; mPainterWidget(paintWidget); return true; &#125; &#125; return QWidget::eventFilter(o,e); &#125; void mPainterWidget(QWidget *w)&#123; QPainter painter(w); //draw somthing &#125; 五、画一个带角度的椭圆12345678910当初好奇，想画一个带角度的椭圆，发现图形画圆的drawEllipse 没有带角度的参数，只有一个外接矩形后面又发现QPainter自带一个角度旋转（顺时针） 舒服void translate(const QPointF &amp;offset);void rotate(qreal a);步骤：painter.translate(x,y); 因为角度旋转是以原点旋转，所以先将坐标点平移到椭圆中心painter.rotate(15); 旋转角度painter.drawEllipse(x-w/2,y-h/2,w,h);painter.resetTransform(); 恢复原来]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT布局个人总结]]></title>
    <url>%2F2019%2F01%2F31%2FQT%E5%B8%83%E5%B1%80%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[很久很久以前，刚接触QT，发现UI拖控件真爽，做个计算器什么的，一下子就搭出来了！实现起来也很得心应手，后面做的界面越来越复杂后，特别是别人跟你提意见，需要修改的时候，绝望！打破布局各种不友好。开始使用代码布局，代码new控件，修改的时候也比较好修改，而且可以实现动态布局！感觉缺点就是样式表没有UI这么友好，实时体现。 一、布局类123456789101112QLayoutItem QLayout(和QObject) QBoxLayout QHBoxLayout 水平布局 QVBoxLayout 垂直布局 QGridLayout 栅栏布局 QFormLayout 表单布局 QGraphicsLayout QStackedLayout 堆布局 QSpacerItem 空白占位（UI上的弹簧） QWidgetItem QWidgetItemV2 为什么个人不喜欢用QGridLayout呢？因为QGridLayout很容易被控制改变实际比例，导致出现和预设的比例不同。排问题好麻烦，推荐在行或者列使用相同的控件时使用。（有可能是我太菜了，使用不来） QLayout 函数名 意义 QWidget *parentWidget() const; 返回布局依赖控件 void setContentsMargins(int left, int top, int right, int bottom); 布局的左上右下边距 void setContentsMargins(const QMargins &amp;margins); void getContentsMargins(int left, int top, int right, int bottom) const; QMargins contentsMargins() const; QRect contentsRect() const; void addWidget(QWidget *w); 添加控件 virtual void addItem(QLayoutItem *) = 0; void removeWidget(QWidget *w); 移除控件，不生效！下面会讲怎么从布局中去掉控件 void removeItem(QLayoutItem *); void setEnabled(bool); bool isEnabled() const; void setMargin(int); void setSpacing(int); virtual QLayoutItem *itemAt(int index) const = 0; virtual QLayoutItem *takeAt(int index) = 0; virtual int indexOf(QWidget *) const; virtual int count() const = 0; QBoxLayout 函数名 意义 void addSpacing(int size); 添加指定大小的占位 void addStretch(int stretch = 0); 添加指定比例的占位 void addSpacerItem(QSpacerItem *spacerItem); 添加一个弹簧 void addWidget(QWidget *, int stretch = 0, Qt::Alignment alignment = 0); 添加一个布局 void addLayout(QLayout *layout, int stretch = 0); 添加一个布局 void addStrut(int);//Limits the perpendicular dimension of the box (e.g. height if the box is LeftToRight) to a minimum of size. Other constraints may increase the limit. void addItem(QLayoutItem *) Q_DECL_OVERRIDE; 继承自QLayoutItem 纯虚函数还有对应的insert插入操作 void setSpacing(int spacing); 设定控件之间的距离 bool setStretchFactor(QWidget *w, int stretch); 更改该控件的比例 bool setStretchFactor(QLayout *l, int stretch); 更改该布局的比例 void setStretch(int index, int stretch); 更改第index项的比例 QGridLayout 函数名 意义 void setHorizontalSpacing(int spacing); 控件间距 int horizontalSpacing() const; void setVerticalSpacing(int spacing); int verticalSpacing() const; void setSpacing(int spacing); int spacing() const; void setRowStretch(int row, int stretch); 行列比例 void setColumnStretch(int column, int stretch); int rowStretch(int row) const; int columnStretch(int column) const; int columnCount() const; 行列数量 int rowCount() const; inline void addWidget(QWidget *w) { QLayout::addWidget(w); } 插入控件 void addWidget(QWidget *, int row, int column, Qt::Alignment = 0); void addWidget(QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0); void addLayout(QLayout *, int row, int column, Qt::Alignment = 0); void addLayout(QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0); QFormLayout没用过，类似一个QHBoxLayout，固定一个QLabel和一个等待插入的控件。 QGraphicsLayout没用过，给Graphics View使用。 QStackedLayout跟QStackedWidget一样，方式不一样，QStackedLayout是多个Layout QStackedWidget是多个Widget QSpacerItem弹簧 1234567QSpacerItem(int w, int h, QSizePolicy::Policy hData = QSizePolicy::Minimum, QSizePolicy::Policy vData = QSizePolicy::Minimum) : width(w), height(h), sizeP(hData, vData) &#123; &#125; void changeSize(int w, int h, QSizePolicy::Policy hData = QSizePolicy::Minimum, QSizePolicy::Policy vData = QSizePolicy::Minimum); QWidgetItem没用过 Normally, you don’t need to use this class directly. Qt’s built-in layout managers provide the following functions for manipulating widgets in layouts 二、布局遍历1234for(int i=0;i&lt;mlayout-&gt;count();i++)&#123; QLabel *lab=qobject_cast&lt;QLabel*&gt;(mlayout.itemAt(i)-&gt;widget()); qDebug()&lt;&lt;lab-&gt;text();&#125; 三、清除布局1234while(mlayout-&gt;count())&#123; mlayout-&gt;itemAt(0)-&gt;widget()-&gt;setParent(nullptr); //将父类设空既可 下面一句保留 //mlayout-&gt;removeWidget(mlayout-&gt;itemAt(0)-&gt;widget());&#125; 四、动态布局动态布局借用清除布局，将layout里面的widget全部清空，然后重新添加需要的widget，视觉上面可以看到是界面可以动态变换 123clearLayout(mlayout);mlayout-&gt;addWidget(subWidget1,1);mlayout-&gt;addwidget(subWidget2,2); 五、注意设置布局前，控件应该设定好大小策略，限定大小的变化 1234567891011 void QWidget::setSizePolicy(QSizePolicy::Policy hor, QSizePolicy::Policy ver);void setSizePolicy(QSizePolicy);enum Policy &#123; Fixed = 0, Minimum = GrowFlag, Maximum = ShrinkFlag, Preferred = GrowFlag | ShrinkFlag, MinimumExpanding = GrowFlag | ExpandFlag, Expanding = GrowFlag | ShrinkFlag | ExpandFlag, Ignored = ShrinkFlag | GrowFlag | IgnoreFlag &#125;;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置文件与注册表]]></title>
    <url>%2F2019%2F01%2F27%2F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一、QSettings​ QT中，对.ini文件和注册表都是使用同一个类，就是QSettings类。使用简单，但是不知道是设置问题还是啥，会有点小问题，下面我会指出。 ​ API中介绍，创建QSettings时，必须需要指定公司或者组织、应用名称。注册表使用的，读取INI不需要设置。（you must pass the name of your company or organization as well as the name of your application.） 1QSettings settings("MySoft", "Star Runner"); 1）简单介绍 函数名 作用 QSettings(const QString &amp; fileName, Format format, QObject * parent = 0)； /FormatQSettings::NativeFormat 0 在windows平台，用于读取注册表，OSX和IOS 读CFPreferences，Unix读INIQSettings::IniFormat 1 Store the settings in INI files.QSettings::InvalidFormat 16 Special value returned by registerFormat(). / | 构造函数 || QStringList allKeys() const; | 返回所有的键 如group/key || void beginGroup(const QString &amp; prefix); | 直接读取prefix组 || void QSettings::endGroup();/settings.beginGroup(“mainwindow”);settings.setValue(“size”, win-&gt;size());settings.setValue(“fullScreen”, win-&gt;isFullScreen());settings.endGroup();settings.beginGroup(“outputpanel”);settings.setValue(“visible”, panel-&gt;isVisible());settings.endGroup(); / | 返回上一级 || QStringList QSettings::childGroups() const; | 返回所有的group || QStringList QSettings::childKeys() const; | 返回当前级别的key || bool QSettings::contains(const QString &amp; key) const; | 是否包含key || void QSettings::remove(const QString &amp; key); | 删除本项及子项 || void QSettings::setIniCodec(QTextCodec codec); | 设置编码 || void QSettings::setIniCodec(const char codecName); | || [static] void QSettings::setPath(Format format, Scope scope, const QString &amp; path);QSettings::UserScope 0 特定用户范围.QSettings::SystemScope 1 本机所有用户. | 设置文件路径 || void QSettings::setValue(const QString &amp; key, const QVariant &amp; value); | 写入值 || QVariant QSettings::value(const QString &amp; key, const QVariant &amp; defaultValue = QVariant()) const; | 取值 | 2）读写配置文件12345QSetting qset("./my.ini"，QSettings::IniFormat);qset.setValue("group/key","nice");qDebug()&lt;&lt;qset.value("group/key"); //可以取到nice//对于中文utf8的文档 需要增加一句qset.setIniCodec("UTF8"); //GBK UNICODE GB2312 3）读写注册表12345QSetting REGRead("MySoft", "Star Runner"); //会在注册表中建了一个MySoft，底下会有个Star Runner的文件夹 下面的操作会在 Star Runner中进行//写REGRead.setValue("",""); //读REGRead.value(""); 二、API1）读写配置文件12345678910111213141516171819202122232425262728293031323334//读写系统配置文件GetProfileInt(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);GetProfileString(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize);WriteProfileString(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString);GetProfileSection(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize);WriteProfileSection(LPCWSTR lpAppName, LPCWSTR lpString);//读写自定义配置文件GetPrivateProfileInt(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);GetPrivateProfileString(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);WritePrivateProfileString(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);GetPrivateProfileSection(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);WritePrivateProfileSection(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName);GetPrivateProfileSectionNames(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);GetPrivateProfileStruct(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);WritePrivateProfileStruct(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);//例子//写WritePrivateProfileString( reinterpret_cast&lt;const wchar_t *&gt;(group.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(key.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(error.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(filepath.utf16()));//读wchar_t buf[64];GetPrivateProfileString( reinterpret_cast&lt;const wchar_t *&gt;(group.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(key.utf16()), reinterpret_cast&lt;const wchar_t *&gt;(error.utf16()), buf,sizeof(buf)-1, reinterpret_cast&lt;const wchar_t *&gt;(filepath.utf16()));QString::fromWCharArray(buf); 2）读写注册表​ 只捉几个介绍！ 12345678910111213141516171819202122232425RegCreateKeyEx(HKEY hKey,LPCWSTR lpSubKey,DWORD Reserved,LPWSTR lpClass,DWORD dwOptions,REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,PHKEY phkResult,LPDWORD lpdwDisposition);RegCreateKey(HKEY hKey,LPCWSTR lpSubKey,PHKEY phkResult);/*创建键值*/RegDeleteKeyEx(HKEY hKey,LPCWSTR lpSubKey,REGSAM samDesired,DWORD Reserved);RegDeleteKey(HKEY hKey,LPCWSTR lpSubKey);/*删除键值*/RegOpenKeyEx(HKEY hKey,LPCWSTR lpSubKey,DWORD ulOptions,REGSAM samDesired,PHKEY phkResult);RegOpenKey(HKEY hKey,LPCWSTR lpSubKey,PHKEY phkResult);/*打开键值*/RegQueryValueEx(HKEY hKey,LPCWSTR lpValueName,LPDWORD lpReserved,LPDWORD lpType,LPBYTE lpData,LPDWORD lpcbData);RegQueryValue(HKEY hKey,LPCWSTR lpSubKey,LPWSTR lpData,PLONG lpcbData);/*获取键值*/RegSetValueEx(HKEY hKey,LPCWSTR lpValueName,DWORD Reserved,DWORD dwType,CONST BYTE *lpData,DWORD cbData);RegSetValue(HKEY hKey,LPCWSTR lpSubKey,DWORD dwType,LPCWSTR lpData,DWORD cbData);/*修改键值*/]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QString与QStringList]]></title>
    <url>%2F2019%2F01%2F26%2FQString%E4%B8%8EQStringList%2F</url>
    <content type="text"><![CDATA[对于我而言，这两者用的频率真的非常高了。 一、QString​ 根据api顺序，把自己现在的经验写下来。 函数名 意义 QString &amp; append(const QString &amp; str); 追加一个串到尾部，有多个重载 QString arg(const QString &amp; a, int fieldWidth = 0, QChar fillChar = QLatin1Char( ‘ ‘ )) const; 使用a替换%1 最少占用fieldWidth字符，不足用fillChar替换 fieldWidth为正，右对齐。反之，左对齐 QString QString::arg(const QString &amp; a1, const QString &amp; a2) const; QString str;str = “%1 %2”;str.arg(“%1f”, “Hello”); // returns “%1f Hello”str.arg(“%1f”).arg(“Hello”); // returns “Hellof %2” | || int QString::compare(const QString &amp; s1, const QString &amp; s2, Qt::CaseSensitivity cs = Qt::CaseSensitive); int x = QString::compare(“aUtO”, “AuTo”, Qt::CaseInsensitive); // x == 0int y = QString::compare(“auto”, “Car”, Qt::CaseSensitive); // y &gt; 0int z = QString::compare(“auto”, “Car”, Qt::CaseInsensitive); // z &lt; 0 | 比较两个串 || bool QString::contains(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; QString str = “Peter Pan”;str.contains(“peter”, Qt::CaseInsensitive); // returns true | 是否包含str || int QString::count(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; | 包含str多少次 || QChar QString::data(); | 将QString转成QChar字符串 || bool QString::startsWith(const QString &amp; s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; | 是否以s开始 || bool QString::endsWith(const QString &amp; s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; | 是否以s结束 || QString &amp; QString::fill(QChar ch, int size = -1); | 使用连续size个ch填充 || [static] QString QString::fromLatin1(const char str, int size = -1); | 从char 转入 || [static] QString QString::fromLocal8Bit(const char str, int size = -1); | 从8字节长度char 转入 || [static] QString QString::fromRawData(const QChar unicode, int size); | 从unicode转入 || [static] QString QString::fromStdString(const std::string &amp; str); | 从标准string转入 || [static] QString QString::fromStdU16String(const std::u16string &amp; str); | 从标准16字长的string转入 || [static] QString QString::fromStdWString(const std::wstring &amp; str); | 从标准宽字节转入 || [static] QString QString::fromUtf8(const char str, int size = -1); | 从utf8字串转入 || [static] QString QString::fromUtf16(const ushort unicode, int size = -1); | 从unicode字串转入 || [static] QString QString::fromWCharArray(const wchar_t * string, int size = -1); | 从宽字串转入 || int QString::indexOf(const QString &amp; str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; | 从from位置开始 str出现的位置 没有返回-1 || QString &amp; QString::insert(int position, const QString &amp; str); | 从position位置插入str || bool QString::isEmpty() const; QString().isEmpty(); // returns trueQString(“”).isEmpty(); // returns trueQString(“x”).isEmpty(); // returns falseQString(“abc”).isEmpty(); // returns false | || bool QString::isNull() const; QString().isNull(); // returns trueQString(“”).isNull(); // returns falseQString(“abc”).isNull(); // returns false | || QString QString::left(int n) const; | 保留左边起n个 || QString QString::right(int n) const; | 保留右边起n个 || QString QString::mid(int position, int n = -1) const; | 保留position位置起，连续n个 || [static] QString QString::number(long n, int base = 10); | 将n转成串 || | || QString &amp; QString::prepend(const QString &amp; str); QString x = “ship”;QString y = “air”;x.prepend(y);// x == “airship” | 将str做为前缀 || QString &amp; QString::remove(int position, int n); | 从Position删除连续n个 || QString QString::repeated(int times) const; | 串重复times次 || QString &amp; QString::replace(int position, int n, const QString &amp; after);//不止下面两种QString x = “Say yes!”;QString y = “no”;x.replace(4, 3, y);// x == “Say no!”或者QString str = “colour behaviour flavour neighbour”;str.replace(QString(“ou”), QString(“o”));// str == “color behavior flavor neighbor” | || QString QString::section(QChar sep, int start, int end = -1, SectionFlags flags = SectionDefault) const;QString str;QString csv = “forename,middlename,surname,phone”;QString path = “/usr/local/bin/myapp”; // First field is emptyQString::SectionFlag flag = QString::SectionSkipEmpty;str = csv.section(‘,’, 2, 2); // str == “surname”str = path.section(‘/‘, 3, 4); // str == “bin/myapp”str = path.section(‘/‘, 3, 3, flag); // str == “myapp” | 以sep切开，也可以以串切开 || QString QString::simplified() const;QString str = “ lots\t of\nwhitespace\r\n “;str = str.simplified();// str == “lots of whitespace”; | 去除整串的占位符 || QStringList QString::split(const QString &amp; sep, SplitBehavior behavior = KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;SplitBehavior:QString::KeepEmptyParts 0 If a field is empty, keep it in the result.QString::SkipEmptyParts 1 If a field is empty, don’t include it in the result.str = “This time, a normal English sentence.”;list = str.split(QRegExp(“\W+”), QString::SkipEmptyParts);// list: [ “This”, “time”, “a”, “normal”, “English”, “sentence” ] | 切割 || QByteArray QString::toLatin1() const; | || QByteArray QString::toLocal8Bit() const; | || std::string QString::toStdString() const | || QString QString::toLower() const; | 转成小写 || QString QString::toUpper() const; | 转成大写 || QString QString::trimmed() const; | 去掉首尾占位 || void QString::truncate(int position);QString str = “Vladivostok”;str.truncate(4);// str == “Vlad” | 与left有点类似 保留前position个 || const QChar QString::unicode() const; | 字面意思 || const ushort QString::utf16() const; | | 12345678910111213[static] QString QString::number(double n, char format = 'g', int precision = 6);/*format:e format as [-]9.9e[+|-]999E format as [-]9.9E[+|-]999f format as [-]9.9g use e or f format, whichever is the most conciseG use E or f format, whichever is the most conciselong a = 63;QString s = QString::number(a, 16); // s == "3f"QString t = QString::number(a, 16).toUpper(); // t == "3F"*/ 12345678QString与string的转换，经实验，string与QString使用API互相转换，中文会乱码string2QString&#123; qstr=QString::fromLocal8Bit(str.data());&#125;QString2string&#123; str=string(qstr.toLocal8Bit());&#125; 二、QStringList​ 其实就是QString的数组 函数名 意义 bool QStringList::contains(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; 是否包含str QStringList QStringList::filter(const QString &amp; str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const; QStringList list;list &lt;&lt; “Bill Murray” &lt;&lt; “John Doe” &lt;&lt; “Bill Clinton”;QStringList result;result = list.filter(“Bill”);// result: [“Bill Murray”, “Bill Clinton”] | 过虑出包含str的串 || int QStringList::indexOf(const QRegExp &amp; rx, int from = 0) const; | 匹配 || QStringList &amp; QStringList::replaceInStrings(const QString &amp; before, const QString &amp; after, Qt::CaseSensitivity cs = Qt::CaseSensitive);QStringList list;list &lt;&lt; “alpha” &lt;&lt; “beta” &lt;&lt; “gamma” &lt;&lt; “epsilon”;list.replaceInStrings(“a”, “o”);// list == [“olpho”, “beto”, “gommo”, “epsilon”] | 替换 || void QStringList::sort(Qt::CaseSensitivity cs = Qt::CaseSensitive); | 排序 |]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包罗万象的QVariant]]></title>
    <url>%2F2019%2F01%2F26%2F%E5%8C%85%E7%BD%97%E4%B8%87%E8%B1%A1%E7%9A%84QVariant%2F</url>
    <content type="text"><![CDATA[一、概念该类常用于数据库中！类似联合数据类型。 它可以包含QT中各种数据类型，包括一些类。摘抄自QT5.5的文档 二、使用1234567891011121314QVariant QVariant::fromValue(const T &amp; value); //会返回一个QVariant 否则与setValue一样void QVariant::setValue(const T &amp; value);//设定一个值T QVariant::value() const;//返回一个值bool QVariant::canConvert(int targetTypeId) const； //如果支持该类型，返回真bool QVariant::convert(int targetTypeId); //将该类型转成targetTypeId 如果不支持，类型会变，而且值会变成0//其中T为一所介绍的类型//例子QVariant qvar;qvar.setValue("bugnull.com");qDebug()&lt;&lt;qvar.toString();qDebug()&lt;&lt;QVariant::fromValue("bugnull.cn");qDebug()&lt;&lt;qvar.value&lt;QString&gt;();qDebug()&lt;&lt;qvar.canConvert&lt;QString&gt;();qDebug()&lt;&lt;qvar.convert&lt;QString&gt;();]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT添加外部库]]></title>
    <url>%2F2019%2F01%2F26%2FQT%E6%B7%BB%E5%8A%A0%E5%A4%96%E9%83%A8%E5%BA%93%2F</url>
    <content type="text"><![CDATA[QT的库虽然已经非常的多，但是还是还是满足不了需求。如音视频库FFMpeg和图纸解析dxflib opendwg等。。。。省略一万字。 一、PRO文件修改​ 增加 123INCLUDEPATH+= 头文件目录LIBS += -L（.lib或者.a的目录） -l（.lib或者.a的名字 不带后缀）#推荐使用 $$PWD/ 表示pro文件当前路径 路径带空格了，可以使用""包括，但是不要把PWD/也包在内！ 常规操作，如果特别的库，看介绍吧。下课！！]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QLibrary使用动态库]]></title>
    <url>%2F2019%2F01%2F26%2FQLibrary%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[我使用这种方法一般是因为没有.h .a(.lib)文件的支持下，只能使用QLibrary进行手动提取。 一、常用函数12345bool load()；//加载 需要指定了文件名，跟文件的open一样bool unload()；//卸载void setFileName(const QString &amp; fileName)； //设置库名QFunctionPointer resolve(const char * symbol)； //函数名QString errorString() const； //错误信息 二、使用例子1234567891011121314显示调用QLibrary myLib("mylib");typedef void (*MyPrototype)();MyPrototype myFunction = (MyPrototype) myLib.resolve("mysymbol");if (myFunction) myFunction();隐式调用typedef void (*MyPrototype)();MyPrototype myFunction = (MyPrototype) QLibrary::resolve("mylib", "mysymbol");if (myFunction) myFunction();//上面typedef void (*fun)()为指定一个指针fun为指向反回值为void没有参数的函数指针 三、加载类​ 如果调用函数方法，可以通过上面去加载！类呢？类是由编译期就完成的了！无法实时去索引。经搜索，还真发现了可以完成的例子。 ​ 他利用虚表的特性，在运行时可以动态索引。使用一个接口类，对外进行公开，添加创建对象函数，返回类型为接口类型。 12345678910111213141516171819202122232425262728293031class TestInterface&#123;public: virtual ~TestInterface() &#123; &#125; virtual int getValues() = 0;&#125;class TESTDLL_LIBSHARED_EXPORT TestDLL_lib : public TestInterface&#123;public: TestDLL_lib(); virtual ~TestDLL_lib(); int a; int b; int c; int getValues() override; // MSVC may not support "override"&#125;; // return pointer to interface!// TestDLL_lib can and should be completely hidden from the applicationextern "C" TESTDLL_LIBSHARED_EXPORT TestInterface *create_TestDLL_lib()&#123; return new TestDLL_lib();&#125;//https://stackoverflow.com/questions/26234327/qlibrary-import-a-class]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[extern "C"与_cplusplus]]></title>
    <url>%2F2019%2F01%2F26%2Fextern-C%E4%B8%8E-cplusplus%2F</url>
    <content type="text"><![CDATA[一、extern”C”​ 百度百科讲得很清楚 ，就是说，c++编译器虽然支持c，但是由于函数重载的存在，编译的时候会把参数也加到编译中，而c却不支持。所以使用该符号，表明使用c的方式去编译这些文件。 extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 二、extern​ extern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定义，另外，extern也可用来进行链接指定。我觉得它是个导出声明符号，达到代码段共享的作用。 ​ 当时我有点不明白，它和static静态全局有什么区别？extern是真全局变量，可以在多个地方进行extern int a这样的声明，仅仅是声明，只可以在一个地方进行定义。只要声明了之后，就可以共享这个变量a。而static为只申请一次，然后一直存在，作用域内的地方可以一直使用它，而且值也不变，不会跟函数结束而被释放。同名会被作用域小的替代。 三、_cplusplus​ 它是个宏定义，表明当前是c++环境。结合使用，效果更佳 12345678&gt; #ifdef __cplusplus /* 如果采用了C++，如下代码使用C编译器 */&gt; extern &quot;C&quot;&#123;/* 如果没有采用C++，顺序预编译 */&gt; #endif&gt; /* 采用C编译器编译的C语言代码段 */&gt; #ifdef __cplusplus /* 结束使用C编译器 */&gt; &#125;&gt; #endif&gt;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT静态库与使用]]></title>
    <url>%2F2019%2F01%2F25%2FQT%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用静态库解决了我之前的共享库那篇文章下面那个问题！ 一、新建工程1. 新建Library\C++工程 2.选择静态链接库，设定路径 3.选择对应的模块，也可以在pro里面增加 二、工程介绍1.本工程没有main函数，可以归类为库。2.pro文件介绍需要debug版本的，手动增加，多了一条CONFIG+=staticlib 这里得知，告知编译器将编译出静态库 12345CONFIG+=debug_and_releaseCONFIG(debug,debug|release)&#123; unix:TARGET=$$join(TARGET,,,_debug) else:TARGET=$$join(TARGET,,,d)&#125; 3.主类或函数​ 可以看出，该类与普通类定义完全一样 5.编译完成​ 在windows平台下，会成生一个.a文件（我使用的是Mingw5.5.1，MSVC会生成.lib） 三、库的使用1.新建一个Application项目​ 右击工程，弹出，添加库，选择.a文件，设置见下图2 2. pro文件会发生变化​ INCLUDEPATH表示头文件的路径 ​ DEPENDPATH表示编译时依赖文件的路径 ​ 最好把 .h .a 放到与该工程下（该方法直接发布exe即可） 3.使用​ 包含.h头文件即可以正常使用函数或者类。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多域名指向GithubPage]]></title>
    <url>%2F2019%2F01%2F23%2F%E5%A4%9A%E5%9F%9F%E5%90%8D%E6%8C%87%E5%90%91GithubPage%2F</url>
    <content type="text"><![CDATA[域名1 bugnull.com 域名2 bugnull.cn 一、购买域名​ 如果没有域名都是白瞎！！这两个域名都是通过阿里云购买的，加起来80多块一年。淘到两个好域名，开心。 二、访问*.github.io​ 确保自己的 *.github.io可以访问。 1. 设置第一个域名​ 打开github的仓库，选择自己的github.io，点击设置，拉到下面的GithubPage，修改下面为下图2，因为Github更新的比较快，大家看情况设置。 2.域名解析​ 在Github仓库上，增加一个CNAME的文件，里面的内容为，例如我的，就填bugnull.com，仅此而已，连www也不需要，正是因为CNAME只支持一个域名，所以才有我东找西找的结果。 ​ 添加CNAME和A分别对应github.io和 github.io对应的ip地址 ​ 如果不知道对应的ip地址 使用cmd ping一下就可以看到了 ​ 如果准备做多个域名，在这里，顺便把其它的域名也加上A字段，填上个IP即可 3.第一个域名设置完成​ 此时等个几分钟，就可以使用第一个域名访问了 4.设置第二个或者更多个域名​ 写本文的目的从这里才开始，因为前面那几个网上多的是！ ​ 原理，Github上面每一个仓库都可以设置一个域名！利用这个特性，进行域名转跳！ 5.创建一个新的仓库​ 因为一个帐号只能有一个github.io仓库，所以这个仓库随便建，同样新建的仓库，设置。 6.添加文件​ 在新建的仓库新加404.html里面的内容为，你们的域名填写主域名！ ​ 再新建一个CNAME文件，里面的内容为你的副域名。到这里就设置完了，原理是GithubPage的仓库可独立域名和利用404报错页面进行转跳的。有点神奇吧！ 三、大概流程​ 在GithubPage上，设置域名，仓库上增加CNAME，云解析填上对应的解析。 ​ 多域名，利用404转跳，和Github仓库的强大作用。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT共享库与使用]]></title>
    <url>%2F2019%2F01%2F21%2FQT%E5%85%B1%E4%BA%AB%E5%BA%93%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[之前因为一些原因，需要将一些widget派生类封装成dll，给其它项目使用。研究了一下，首先，该widget派生类需要与使用类尽量没有关联。（当明有一个共用类，保存各种全局变量，里面有一个变量，与语言选择相关的，共享类也包含了该头文件，可是并没有获取到全局变量的值） 一、新建工程1. 新建Library\C++工程 2.选择共享库，设定路径 3.选择对应的模块，也可以在pro里面增加 二、工程介绍1.本工程没有main函数，可以归类为库。2.pro文件介绍​ 需要debug版本的，手动增加 12345CONFIG+=debug_and_releaseCONFIG(debug,debug|release)&#123; unix:TARGET=$$join(TARGET,,,_debug) else:TARGET=$$join(TARGET,,,d)&#125; 3.*_global.h介绍​ 下图1为_global.h的内容，下图2为实际Q_DECL_EXPORT和Q_DECL_IMPORT**的宏定义 4.主类或函数​ 定义前加上PUBLICSHARED_EXPORT即可，然后做自己想做的控件。 1234567PUBLICSHARED_EXPORT int max(int x,int y); //尽量不要使用这些c++或者qt库中带有的函数名，万不得已经在使用前加:表明命名空间类定义class PUBLICSHARED_EXPORT Public&#123;public: Public();&#125;; 5.编译完成​ 在windows平台下，会成生一个.a文件和一个.dll（我使用的是Mingw5.5.1，MSVC会生成.lib和.dll） 三、库的使用1.新建一个Application项目​ 右击工程，添加库，选择内部库，在库文件中选择.a或者.lib。看图说话- - 2. pro文件会发生变化​ INCLUDEPATH表示头文件的路径 ​ DEPENDPATH表示编译时依赖文件的路径 ​ 最好把 .h *_global.h .a .dll 放到与该工程下（该方法发布的时候需要把dll一起发布） ​ 3.使用​ 包含.h头文件即可以正常使用函数或者类。 4.注意​ 有一个全局变量Language表示当前界面显示的语言，由程序开启后第一时间读取配置文件，供全局使用。使用了上面的方法，生成共享库的时候在头文件也包含了该类。结果在使用的时候经调试发现，两者的Language为两个互不关联的变量。即数据不共享，通过信号槽或者函数调用可以达到共享。]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT工程编译流程]]></title>
    <url>%2F2019%2F01%2F20%2FQT%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本章为简单介绍，qmake里面有大学问。 一、qmale 第一步是运行qmake，根据当前的项目工程，生成pro，然后运行qmake生成MakeFile文件（有时候，增加资源文件或者删除后，运行会警告缺失文件，执行一次qmake即可） 命令 qmake project.pro 生成pro 然后 qmake 生成MakeFile 二、构建 构建我理解为是编译，第二次执行只编译变化了的部分，一个一个生成.o和目标文件，最终生成exe 命令 mingw32-make、moc、uic、rcc moc.exe -o mclass.h moc_mclass.cpp 编译继承qt的类 uic.exe -o mclass.ui ui_mclass.h 将ui编译生成类 rcc.exe -o -no-compress my.qrc my.cpp 编译资源文件 重新构建 将所有部分重新编译 三、清除 只留下exe，其它文件都删掉(MakeFile会留下) 四、运行 根据已经存在的MakeFile进行编译，然后打开exe，如果MakeFile不存在才会重新执行qmake。（估计是这样才会导致我之前说的那个问题） （之前查了一下资料，发现QT Create运行程序和在资源管理器上双击打开程序的区别。QT Create上运行使用的库是当前设置好，准备编译该工程的库。而双击运行会去环境变量中找，导致两者使用的库不一致，所以有可能其中一方运行不起来而另外一方可以运行。）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集与字符编码]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[主要是总结，资料来源是网络，底部会把链接挂上。 一、名词解释 字符集 ：字符编码就是一个系统支持的所有抽象字符的集合，字符是各种文字和符号的总称。 字符编码 ：将符号转换为计算机可以接受的数字系统的规则，是符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。 编码 ：按照某种字符编码将字符存储在计算机中 解码 ：将存储在计算机中的二进制数解析出来 二、编码集 ASCII 美国最早推出，由一个字节表示，共128个，编码范围是0-127 ISO 由西欧国家对ASCII的扩展，增加到256个字符，ISO8859 GB2312 中国推出，完整保留ASCII，兼容约7000简体字、数学符号、罗马希腊字母、日本假名等。小于127的字符与ASCII对应，两个大于127的结合起来表示一个汉字。高位在0xA1到0xF7，低位在0xA1到0xFE，其中更包括ASCII就有的字符，但是这里为“全角”，小于127的称为“半角”。该编码称为GB2312 。 GBK 当时GB2312这并没有包括完整的中文，简体都没包括完整，繁体就更别说了。在这个前提下出现GBK 编码，把低位的0xA1不从0开始，这里就将繁体等字符加进来了，范围为0x8140至0xFEFE。向下与 GB 2312 编码兼容，向上支持 ISO，与 Unicode 组织的 Unicode 编码完全兼容。GB13000等同于ISO10646 GB18030 兼容GB2312，基本兼容GBK，支持GB13000及Unicode的全部统一汉字。编码与utf8相同，采用可变长度的编码，GB18030-2000为强制要求支持的版本，GB18030-2005为增加多种少数民族文字编码。 三、Unicode编码集与UTF8、UTF16、UTF32​ 单独总结Unicode，表示该编码的重要性。在计算机领域中，Unicode编码是业界的一种标准。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 ​ Unicode是字符集，UTF32、UTF16、UTF8是三种字符编码方案 。 Unicode字符集可以简写为UCS（Unicode Character Set），0x0000~0X00ff与ISO 8859-1保持一致 Unicode可以逻辑分为17平面（Plane），每个平面拥有65536（ 共1114112）个代码点，虽然目前只有少数平面被使用。 平面0 (0000–FFFF): 基本多文种平面（Basic Multilingual Plane, BMP）. 平面1 (10000–1FFFF): 多文种补充平面（SupplementaryMultilingual Plane, SMP）. 平面2 (20000–2FFFF): 表意文字补充平面（SupplementaryIdeographic Plane, SIP）. 平面3 (30000–3FFFF): 表意文字第三平面（TertiaryIdeographic Plane, TIP）. 平面4 to 13 (40000–DFFFF)尚未使用 平面14 (E0000–EFFFF): 特别用途补充平面（SupplementarySpecial-purpose Plane, SSP） 平面15 (F0000–FFFFF)保留作为私人使用区（PrivateUse Area, PUA） 平面16 (100000–10FFFF)，保留作为私人使用区（PrivateUse Area, PUA） 原文：https://blog.csdn.net/harrywater123/article/details/50738079 UTF8 是一种针对Unicode的可变长度字符编码，又称万国码， 用1到6个字节编码Unicode字符。 规则：如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的字节数，其余各字节均以10开头。 1.第一种是一个字节的编码：即128个ascii字符（只需要一个字节） 格式：0xxxxxxx 2^7 - 1 = 127 = 7F = (0111-1111) 编码方式Unicoe范围由(U+0000 至 U+007F) 2.第二种是两个字节的编码：即带有符号的拉丁文，希腊文，西里尔字母，亚美尼亚语，希伯来文，阿拉伯文等，则需要两个字节编码(Unicode 范围由U+0080至U+07FF) 格式：110xxxxx 10xxxxxx (0080)16 = (128)10 (07FF) 16 = (2047)10 = 2^11-1; 3.第三种是三字节的编码，即其他多文种平面(BMP)中的字符（这包括了大部分的汉字）（范围为: U+0800 至 U+FFFF） 格式：1110xxxx 10xxxxxx 10xxxxxx U+0800 = 2048； U+FFFF = 65535 = 2^16 -1； 1110xxxx 10xxxxxx 10xxxxxx 4.第四种是4-6字节编码。 U+1 0000至U+1 FFFFF：使用四字节 U+20 0000 至U+3FF FFFF：使用五字节 U+400 0000至U+7FFF FFFF UTF-8就是以8位为单元对UCS进行编码。从UCS-2到UTF-8的编码方式如下： UCS-2编码(16进制) 范围 UTF-8 字节流(二进制) 0000 - 007F 0 - 127 0xxxxxxx 0080 - 07FF 128-2047 110xxxxx 10xxxxxx 0800 - FFFF 2048-65535 1110xxxx 10xxxxxx 10xxxxxx 例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 目前计算机一般使用 2 个字节（16 位）来存放一个序号（DBCS,DoubleByte Character System），因此，这种方式存放的字符也被称作宽字节字符。比如，字符串”中文123” 在 Windows2000 下，内存中实际存放的是 5 个字符，一共10个字节；若在gb2312编码中，共计五个字符，7个字节。 原文：https://blog.csdn.net/harrywater123/article/details/50738079 优点，可变长度编码，对于常用的ASCII字符，只需要用一位编码即可，多字节的字符使用频率很低，节省了存储空间。 缺点，无法判断UTF8的字节数，较多 10xxxxxx 网络传输会产生错误。 UTF16 将0–65535范围内的字符编码成2个字节，空间利用率比UTF32高两倍 如果字符编码U小于0x10000，也就是十进制的0到65535之内，则直接使用两字节表示； 如果字符编码U大于0x10000，由于UNICODE编码范围最大为0x10FFFF，从0x10000到0x10FFFF之间 共有0xFFFFF个编码，也就是需要20个bit就可以标示这些编码。用U’表示从0-0xFFFFF之间的值，将其前 10 bit作为高位和16 bit的数值0xD800进行 逻辑or 操作，将后10 bit作为低位和0xDC00做 逻辑or 操作，这样组成的 4个byte就构成了U的编码。 UTF32 使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。可以在常数时间内定位字符。 四、BOM​ Unicode编码标准中用于标识文件是采用哪种格式的编码。 ​ BOM —— Byte Order Mark，中文名译作“字节顺序标记” ​ UTF8不需要表明字节顺序，但是可以用BOM来表明编码方式。字符 “Zero Width No-Break Space” 的 UTF-8 编码是 EF BB BF。所以如果接收者收到以 EF BB BF 开头的字节流，就知道这是 UTF-8编码了。Windows 就是使用 BOM 来标记文本文件的编码方式的。 ​ 在保存一个以编utf8码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。在保存一个以utf8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。 编码 表示 (十六进制) 表示 (十进制) utf8 EF BB BF 239 187 191 utf16 大端 FE FF 254 255 utf16 小端 FF FE 255 254 utf32 大端 00 00 FE FF 0 0 254 255 utf32 小端 FF FE 00 00 255 254 0 0 iso8859-1 ​ 最早的编码是iso8859-1，和ascii编码相似。但为了方便表示各种各样的语言，逐渐出现了很多编码。iso8859-1属于单字节编码，最多能表示的字符范围是0-255，应用于英文系列。比如，字母a的编码为0x61=97。很明显，iso8859-1表示的字符范围很窄，无法表示中文字符。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用iso8859-1编码来表示。而且在很多协议上，默认使用该编码。比如，虽然”中文”两个字不存在iso8859-1编码，以gb2312编码为例，应该是”d6d0 cec4”两个字符，使用iso8859-1编码的时候则将它拆开为4个字节来表示：”d6 d0 ce c4”（事实上，在进行存储的时候，也是以字节为单位处理的）。而如果是UTF编码，则是6个字节”e4 b8 ad e6 96 87”。很明显，这种表示还需要以另一种编码为基础。 汉字编码: * GB2312字集是简体字集，全称为GB2312(80)字集，共包括国标简体汉字6763个。 * BIG5字集是台湾繁体字集，共包括国标繁体汉字13053个。 * GBK字集是简繁字集，包括了GB字集、BIG5字集和一些符号，共包括21003个字符。 * GB18030是国家制定的一个强制性大字集标准，全称为GB18030-2000，它的推出使汉字集有了一个“大一统”的标准。 UCS:通用字符集(Universal Character Set，UCS)是由ISO制定的ISO 10646(或称ISO/IEC 10646)标准所定义的字符编码方式，采用4字节编码。UCS包含了已知语言的所有字符。除了拉丁语、希腊语、斯拉夫语、希伯来语、阿拉伯语、亚美尼亚语、格鲁吉亚语，还包括中文、日文、韩文这样的象形文字，UCS还包括大量的图形、印刷、数学、科学符号。​ * UCS-2: 与unicode的2byte编码基本一样。​ * UCS-4: 4byte编码, 目前是在UCS-2前加上2个全零的byte。 MIME： 通用因特网邮件扩充协议，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。 因为在因特网上邮件发送协议SMTP存在几个缺点，主要是不能发送可执行文件和其他的二进制文件，只限于传送7位的ASCII码，因此MIME协议起初用于解决该问题，即是在传送二进制数据时先通过MIME转换成SMTP可传送的ACSII码，接收时再通过MIME还原成原始的二进制码。为此SMTP也响应增加了MIME-version、content-type等5个新的首部。 其中首部Content-transfer-encoding的值有5种—-“7bit”、”8bit”、”binary”、”quoted-printable”和”base64”—-其中”7bit”是缺省值，即不用转化的ASCII字符。真正常用是“quoted-printable”和”base64”两种，用以指明编码转换的方式。 MIME_type类型语法： media-type=type/subtype​ 媒体类型(type)与子类型(subtype)组成了MIME，它们之间使用反斜杠/分割，其中type可取值为：application audio example image message model multipart text video，subtype是某种类型的唯一标识符，比如：css gif xml等。常见的MIME类型： 超文本标记语言文本 .html,.html text/html普通文本 .txt text/plainRTF文本 .rtf application/rtfGIF图形 .gif image/gifJPEG图形 .ipeg,.jpg image/jpegau声音文件 .au audio/basicMIDI音乐文件 mid,.midi audio/midi,audio/x-midiRealAudio音乐文件 .ra,.ram audio/x-pn-realaudioMPEG文件 .mpg,.mpeg video/mpegAVI文件 .avi video/x-msvideoGZIP文件 .gz application/x-gzipTAR文件 .tar application/x-tar quoted-printable： 主要用于ACSII文本中夹杂少量非ASCII码字符的情况，不适合于转换纯二进制文件。它规定将每一个8位的字节，转换为3个字符。第一个字符是”=”号，这是固定不变的。 后面二个字符是二个十六进制数，分别代表了这个字节前四位和后四位的数值。举例来说，ASCII码中”换页键”（form feed）是12，二进制形式是00001100，写成十六进制就是0C，因此它的编码值为”=0C”。”=”号的ASCII值是61，二进制形式是00111101，因为它的编码值是”=3D”。除了可打印的ASCII码以外，所有其他字符都必须用这种方式进行转换。 所有可打印的ASCII码字符（十进制值从33到126）都保持原样不变，”=”（十进制值61）除外。 base64： ​ 所谓Base64，就是说选出64个字符—-小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“（再加上作为垫字的”=”，实际上是65个字符）—-作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。具体来说，转换方式可以分为四步： 第一步，将每三个字节作为一组，一共是24个二进制位。 第二步，将这24个二进制位分为四组，每个组有6个二进制位。 第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节。 第四步，根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值。 如果字节数不足三，则这样处理： a）二个字节的情况：将这二个字节的一共16个二进制位，按照上面的规则，转成三组，最后一组除了前面加两个0以外，后面也要加两个0。这样得到一个三位的Base64编码，再在末尾补上一个”=”号。比如，”Ma”这个字符串是两个字节，可以转化成三组00010011、00010110、00010000以后，对应Base64值分别为T、W、E，再补上一个”=”号，因此”Ma”的Base64编码就是TWE=。 b）一个字节的情况：将这一个字节的8个二进制位，按照上面的规则转成二组，最后一组除了前面加二个0以外，后面再加4个0。这样得到一个二位的Base64编码，再在末尾补上两个”=”号。比如，”M”这个字母是一个字节，可以转化为二组00010011、00010000，对应的Base64值分别为T、Q，再补上二个”=”号，因此”M”的Base64编码就是TQ==。 参考与引用： 十分钟搞清字符集和字符编码 浅谈编码集 字符集和字符编码（Charset &amp; Encoding）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QTCP与断线重连]]></title>
    <url>%2F2019%2F01%2F16%2FQTCP%E4%B8%8E%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E%2F</url>
    <content type="text"><![CDATA[先简单介绍一下QTcpSocket上面常用的几个信号与函数 信号名 触发条件 connected() 连接成功时 disconnected() 断开连接时 error(QAbstractSocket::SocketError socketError) 产生错误时，附带错误码 hostFound() 调用connectToHost，并且找到主机后发出，还没连接上 proxyAuthenticationRequired(const QNetworkProxy &amp; proxy, QAuthenticator * authenticator) This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection. stateChanged(QAbstractSocket::SocketState socketState) 连接状态发生改变时，会发出，附带当前状态的状态码 常用函数 简介 connectToHost 连接 disconnectFromHost 断开连接，会等待数据发送完毕 abort 立即断开，丢弃数据 state 查看当前socket的状态 error 查看当前socket的错误 close 关闭包括（I/O设备，连接，socket，重置各种数据） waitForConnected 阻塞，等待连接，连接成功发出true，超时发出false waitForReadyRead 阻塞，等待数据和readyRead信号，超时反回false waitForBytesWritten 阻塞，至少写入一个字节和发出byteswrite信号后才发出true，超时发出false waitForDisconnected 阻塞，等待断开，断开成功发出true，超时发出false read 读取，可以每次读取一定量的数据 readLine 读取一行数据 readAll 读取缓冲区所有数据 write 写入数据 断线重连机制原理​ 下面两种方法原理其实都一样，检查socket的状态，如果是断开，开启重新连接机制，连接成功，关掉机制。 一、使用定时器 基于QTcpSocket的派生类，信号和槽在构造函数中连接 在定时器的timeout信号触发时，对应的槽函数处理为 12345if( 判断当前socket的状态，没有连接上 )&#123; socket连接&#125;else &#123; 定时器stop&#125; 在socket的disconnected信号发出时，对应的槽函数处理为 123abort();disconnectFromHost();定时器启动 缺点是与当前线程占相同的资源，优点个人感觉实现起来非常简单。 二、使用线程 基于QThread的派生类，信号和槽，socket创建，需要在调用线程start前创建好 在线程的run方法中，处理如下， 12345678910while(threadRun)&#123; if( socket没有连接上 )&#123; connectToHost; waitForConnected(); 连接并产生阻塞，退出当前线程 &#125; if( socket没有连接上 )&#123; continue; &#125; waitForReadyRead(); 来到这里表示socket连接成功，产生阻塞，等待数据到来&#125; 因为socket的处理是在新的线程中运行，接收到数据需要发送到主线程中，readyRead对应的槽函数处理为 1234while( bytesAvailable()&gt;0 )&#123; byteArray=readAll(); emit signalReadyRead(byteArray);&#125;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT信号槽]]></title>
    <url>%2F2019%2F01%2F15%2FQT%E4%BF%A1%E5%8F%B7%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[个人使用过的信号槽的连接方式有三种，需要产生信号的类需要在类定义中加入Q_OBJECT，并且重新执行qmake 1.QT4信号槽12345678910111213141516171819202122connect(sender,SIGNAL(),receiver,SLOT());分别为发送信号的类，对应的信号，接收信号的类，处理信号的槽关于SIGNAL和SLOT，其实是qt的两个宏定义Q_CORE_EXPORT const char *qFlagLocation(const char *method);#ifndef QT_NO_META_MACROS#ifndef QT_NO_DEBUG# define QLOCATION "\0" __FILE__ ":" QT_STRINGIFY(__LINE__)# ifndef QT_NO_KEYWORDS# define METHOD(a) qFlagLocation("0"#a QLOCATION)# endif# define SLOT(a) qFlagLocation("1"#a QLOCATION)# define SIGNAL(a) qFlagLocation("2"#a QLOCATION)#else# ifndef QT_NO_KEYWORDS# define METHOD(a) "0"#a# endif# define SLOT(a) "1"#a# define SIGNAL(a) "2"#a#endif 2.QT5信号槽1234connect(sender,&amp;senderClassName::functionName,receiver,&amp;receiverClassName::function);因为会进行错误检查，而qt4不会，从上面可以得知，qt4信号槽的参数只是字符串。但是对于信号重载的处理比较麻烦，qt4只需要在signals里面使用()括上参数即可，而qt5需要进行强制转换。static_cast&lt;void (className::*)(parameter)&gt;(&amp;className::functionName) 3.信号与Lamda表达式结合1234567891011connect(sender,&amp;senderClassName::functionName,[=]( //parameter )&#123; //slove &#125;);[] 捕捉列表 [] 不捕获任何值 [var1,var2...] 在函数里，捕获var1,var2的值 [&amp;var1,&amp;var2...] 捕获var1,var2的引用对象 [=] 捕获所有外部变量的值 [&amp;] 捕获所有外部变量的引用() 参数 mutable 可以修改捕捉值，但是值本身不会发生改变&#123;&#125; 处理 4.隐藏的第五个参数 Constant Value Description Qt::AutoConnection 0 (默认)如果发送和接收都在同一个线程，使用Qt::DirectConnection，否则使用Qt::QueuedConnection。类型是在信号发送时才确定的 Qt::DirectConnection 1 收到信号后，马上即行 Qt::QueuedConnection 2 保存在一个队列中，当接收事件循环启动时，执行槽函数 Qt::BlockingQueuedConnection 3 与Qt::QueuedConnection类似，但是运行槽函数时，会阻塞信号线程。发送与接收不可以在同一线程，会造成死锁 Qt::UniqueConnection 0x80 可以使用OR实现多种参数连接，但是如果已经存在相同的connect时，会失败。 注意，使用连接时，需要考虑之前是否有连接，因为重新连接了相同的信号与槽，发出一个信号后，会多次触发槽函数，非常浪费资源！！ 补充介绍disconnec的使用 12345disconnect(sender,信号，receiver,槽);其中，信号、receiver、槽都可以为0(0表示任意所有) sender不能为0例1、sender多个不同的信号与receiver的一个槽绑定，参数可以这样写，（sender,0,receiver,槽）例2、sender多个信号与receiver的多个槽绑定了，（sender,0,receiver,0）例3、sender多个信号与多个receiver的多个槽绑定了，（sender,0,0,0）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型转换]]></title>
    <url>%2F2019%2F01%2F15%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在使用这一段时间中，数据类型太多了，很多都需要转换。本章为总结。 C++强制转换有四种1234static_cast&lt;&gt;()dynamic_cast&lt;&gt;()const_cast&lt;&gt;()reinterpret_cast&lt;&gt;() static_cast 基本数据的转换、空指针与指针之间的转换 目前使用于信号槽函数强制转换，基于QT5的新特性，在使用connect时，第二第四个参数产生的为&amp;className::functionName，如果函数被重载了，QT无法判断需要使用哪个信号，即使你的槽函数设置对应的参数，这里需要对第二个参数进行强制转换，如下。 static_cast&lt;void (className::*)(parameter)&gt;(&amp;className::functionName)这样可以将函数进行强制转换，解决信号定位的问题。 dynamic_cast&lt;&gt;() 类的下行转换，由基数向派生类转换 目前没有使用过 const_cast&lt;&gt;() 去掉const或者volatile属性 12const char *cstr="rts";char *str=const_cast&lt;char *&gt;(cstr); reinterpret_cast&lt;&gt;() 主要将数据从一种类型转换为另一种类型，二进制的形式重新解释 在使用windows api的时候，需要使用宽字符wcahr_t，而qt里面没有原这样的类型，但是qstring有转换成宽字符的函数，操作如下 12QString str;reinterpret_cast&lt;const wchar_t *&gt;(str.utf16()); 百度百科介绍，static_cast进行类的转换，会进行实际的偏移，而reinterpret_cast不会 qobject_cast(QObject *object) 该转换只适用于继承自object的派生类，且类中带有Q_OBJECT宏声明。 用于将一个QObject对象转换为对应的派生类，如果类型不符合，则转换为0； sender为槽对象，默认是QObject类型 在这里，如果有多个不同的信号对应同一个槽，可以根据该转换来判断传递对象的类型，像这里，如果sender是QLabel则会转换成功，否则为空 1qobject_cast&lt;QLabel *&gt;(sender())；]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo建站小结]]></title>
    <url>%2F2019%2F01%2F06%2FHexo%E5%BB%BA%E7%AB%99%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[搭建工作下载安装 node.js 和 git 默认安装即可安装成功后，右击系统菜单键会多出两项 在系统盘上，找个地方，如D:/github/ 进入到文件夹，右击，点击Git Bash Here 安装Hexo12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 意思分别为 安装hexo hexo在blog文件夹初始化，不需要手动创建 (blog可以改变，只是一个文件夹名字) 进入blog文件夹 安装扩展插件 开启服务，此时在浏览器输入http://localhost:4000/ 或者 http://127.0.0.1:4000 可以看到相关页面（ctrl+c退出） Hexo常用命令123456hexo generate (hexo g) 编译生成hexo server (hexo s) 启动服务hexo deploy (hexo d) 上传hexo new page &quot;p&quot; 生成一个p页面 hexo new &quot;p&quot; 生成一个标题为p的新文章hexo clean 清除编译生成 Hexo还有很多插件，如果下面使用过程中发现问题，可以百度查找，安装对应的插件创建一个Github代码仓库 如果没有帐号，需要注册一个 点击在网页右上角，选择新建仓库 仓库的Repository name为仓库名，格式有规定，如果你注册的github帐户名为orz，那么这里就要填orz.github.io，其它设置看介绍，创建仓库 添加SSH数据提交这里选择SSH，下面是SSH安装与Github绑定SSH安装1234567ls ~/.ssh检查是否安装了ssh，如果有id_rsa.pub，跳过下面步骤ssh-keygen -t rsa -C &quot;邮箱地址&quot;安装的时候，连续点击三次回车，分别是跳过文件夹和把密码设置为空pwd ~/.ssh查看ssh的安装路径 绑定 找到ssh/id_rsa.pub，打开，复制全部内容 打开github网站，选择SSH and GPG keys New SSH Key标题随便写，将复制的内容写到Key里面，添加 验证是否连通 输入 ssh -T git@github.com如果看到你在github注册的帐号名，即表示成功 初始化设置打开D:/github/blog/_config.yml 1234deploy: type: git repo: branch: master rope的值参考下图 点击Clone or download弹出的链接 写入到_config.yml的rope 注意和：有一个空格，不能少 主题设置从网上查找Hexo主题，下载放到D:/github/blog/themes里面。打开D:/github/blog/_config.yml将theme：改为刚刚下载的主题文件夹名。其余设置需要参考主题的介绍 纸上得来终觉㳀，绝知此事要躬行]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
