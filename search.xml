<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[构建、qmake、重新构建、清除]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%9E%84%E5%BB%BA%E3%80%81qmake%E3%80%81%E9%87%8D%E6%96%B0%E6%9E%84%E5%BB%BA%E3%80%81%E6%B8%85%E9%99%A4%2F</url>
    <content type="text"><![CDATA[本章为简单介绍，qmake里面有大学问。 一、qmale 第一步是运行qmake，根据当前的项目工程，生成pro，然后运行qmake生成MakeFile文件（有时候，增加资源文件或者删除后，运行会警告缺失文件，执行一次qmake即可） 命令 qmake project.pro 生成pro 然后 qmake 生成MakeFile 二、构建 构建我理解为是编译，第二次执行只编译变化了的部分，一个一个生成.o和目标文件，最终生成exe 命令 mingw32-make、moc、uic、rcc moc.exe -o mclass.h moc_mclass.cpp 编译继承qt的类 uic.exe -o mclass.ui ui_mclass.h 将ui编译生成类 rcc.exe -o -no-compress my.qrc my.cpp 编译资源文件 重新构建 将所有部分重新编译 三、清除 只留下exe，其它文件都删掉(MakeFile会留下) 四、运行 根据已经存在的MakeFile进行编译，然后打开exe，如果MakeFile不存在才会重新执行qmake。（估计是这样才会导致我之前说的那个问题） （之前查了一下资料，发现QT Create运行程序和在资源管理器上双击打开程序的区别。QT Create上运行使用的库是当前设置好，准备编译该工程的库。而双击运行会去环境变量中找，导致两者使用的库不一致，所以有可能其中一方运行不起来而另外一方可以运行。）]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集与字符编码]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[主要是总结，资料来源是网络，底部会把链接挂上。 一、名词解释 字符集 ：字符编码就是一个系统支持的所有抽象字符的集合，字符是各种文字和符号的总称。 字符编码 ：将符号转换为计算机可以接受的数字系统的规则，是符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。 编码 ：按照某种字符编码将字符存储在计算机中 解码 ：将存储在计算机中的二进制数解析出来 二、编码集 ASCII 美国最早推出，由一个字节表示，共128个，编码范围是0-127 ISO 由西欧国家对ASCII的扩展，增加到256个字符，ISO8859 GB2312 中国推出，完整保留ASCII，兼容约7000简体字、数学符号、罗马希腊字母、日本假名等。小于127的字符与ASCII对应，两个大于127的结合起来表示一个汉字。高位在0xA1到0xF7，低位在0xA1到0xFE，其中更包括ASCII就有的字符，但是这里为“全角”，小于127的称为“半角”。该编码称为GB2312 。 GBK 当时GB2312这并没有包括完整的中文，简体都没包括完整，繁体就更别说了。在这个前提下出现GBK 编码，把低位的0xA1不从0开始，这里就将繁体等字符加进来了，范围为0x8140至0xFEFE。向下与 GB 2312 编码兼容，向上支持 ISO，与 Unicode 组织的 Unicode 编码完全兼容。GB13000等同于ISO10646 GB18030 兼容GB2312，基本兼容GBK，支持GB13000及Unicode的全部统一汉字。编码与utf8相同，采用可变长度的编码，GB18030-2000为强制要求支持的版本，GB18030-2005为增加多种少数民族文字编码。 三、Unicode编码集与UTF8、UTF16、UTF32​ 单独总结Unicode，表示该编码的重要性。在计算机领域中，Unicode编码是业界的一种标准。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 ​ Unicode是字符集，UTF32、UTF16、UTF8是三种字符编码方案 。 Unicode字符集可以简写为UCS（Unicode Character Set），0x0000~0X00ff与ISO 8859-1保持一致 Unicode可以逻辑分为17平面（Plane），每个平面拥有65536（ 共1114112）个代码点，虽然目前只有少数平面被使用。 平面0 (0000–FFFF): 基本多文种平面（Basic Multilingual Plane, BMP）. 平面1 (10000–1FFFF): 多文种补充平面（SupplementaryMultilingual Plane, SMP）. 平面2 (20000–2FFFF): 表意文字补充平面（SupplementaryIdeographic Plane, SIP）. 平面3 (30000–3FFFF): 表意文字第三平面（TertiaryIdeographic Plane, TIP）. 平面4 to 13 (40000–DFFFF)尚未使用 平面14 (E0000–EFFFF): 特别用途补充平面（SupplementarySpecial-purpose Plane, SSP） 平面15 (F0000–FFFFF)保留作为私人使用区（PrivateUse Area, PUA） 平面16 (100000–10FFFF)，保留作为私人使用区（PrivateUse Area, PUA） 原文：https://blog.csdn.net/harrywater123/article/details/50738079 UTF8 是一种针对Unicode的可变长度字符编码，又称万国码， 用1到6个字节编码Unicode字符。 规则：如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的字节数，其余各字节均以10开头。 1.第一种是一个字节的编码：即128个ascii字符（只需要一个字节） 格式：0xxxxxxx 2^7 - 1 = 127 = 7F = (0111-1111) 编码方式Unicoe范围由(U+0000 至 U+007F) 2.第二种是两个字节的编码：即带有符号的拉丁文，希腊文，西里尔字母，亚美尼亚语，希伯来文，阿拉伯文等，则需要两个字节编码(Unicode 范围由U+0080至U+07FF) 格式：110xxxxx 10xxxxxx (0080)16 = (128)10 (07FF) 16 = (2047)10 = 2^11-1; 3.第三种是三字节的编码，即其他多文种平面(BMP)中的字符（这包括了大部分的汉字）（范围为: U+0800 至 U+FFFF） 格式：1110xxxx 10xxxxxx 10xxxxxx U+0800 = 2048； U+FFFF = 65535 = 2^16 -1； 1110xxxx 10xxxxxx 10xxxxxx 4.第四种是4-6字节编码。 U+1 0000至U+1 FFFFF：使用四字节 U+20 0000 至U+3FF FFFF：使用五字节 U+400 0000至U+7FFF FFFF UTF-8就是以8位为单元对UCS进行编码。从UCS-2到UTF-8的编码方式如下： UCS-2编码(16进制) 范围 UTF-8 字节流(二进制) 0000 - 007F 0 - 127 0xxxxxxx 0080 - 07FF 128-2047 110xxxxx 10xxxxxx 0800 - FFFF 2048-65535 1110xxxx 10xxxxxx 10xxxxxx 例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 目前计算机一般使用 2 个字节（16 位）来存放一个序号（DBCS,DoubleByte Character System），因此，这种方式存放的字符也被称作宽字节字符。比如，字符串”中文123” 在 Windows2000 下，内存中实际存放的是 5 个字符，一共10个字节；若在gb2312编码中，共计五个字符，7个字节。 原文：https://blog.csdn.net/harrywater123/article/details/50738079 优点，可变长度编码，对于常用的ASCII字符，只需要用一位编码即可，多字节的字符使用频率很低，节省了存储空间。 缺点，无法判断UTF8的字节数，较多 10xxxxxx 网络传输会产生错误。 UTF16 将0–65535范围内的字符编码成2个字节，空间利用率比UTF32高两倍 如果字符编码U小于0x10000，也就是十进制的0到65535之内，则直接使用两字节表示； 如果字符编码U大于0x10000，由于UNICODE编码范围最大为0x10FFFF，从0x10000到0x10FFFF之间 共有0xFFFFF个编码，也就是需要20个bit就可以标示这些编码。用U’表示从0-0xFFFFF之间的值，将其前 10 bit作为高位和16 bit的数值0xD800进行 逻辑or 操作，将后10 bit作为低位和0xDC00做 逻辑or 操作，这样组成的 4个byte就构成了U的编码。 UTF32 使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。可以在常数时间内定位字符。 四、BOM​ Unicode编码标准中用于标识文件是采用哪种格式的编码。 ​ BOM —— Byte Order Mark，中文名译作“字节顺序标记” ​ UTF8不需要表明字节顺序，但是可以用BOM来表明编码方式。字符 “Zero Width No-Break Space” 的 UTF-8 编码是 EF BB BF。所以如果接收者收到以 EF BB BF 开头的字节流，就知道这是 UTF-8编码了。Windows 就是使用 BOM 来标记文本文件的编码方式的。 ​ 在保存一个以编utf8码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。在保存一个以utf8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。 编码 表示 (十六进制) 表示 (十进制) utf8 EF BB BF 239 187 191 utf16 大端 FE FF 254 255 utf16 小端 FF FE 255 254 utf32 大端 00 00 FE FF 0 0 254 255 utf32 小端 FF FE 00 00 255 254 0 0 iso8859-1 ​ 最早的编码是iso8859-1，和ascii编码相似。但为了方便表示各种各样的语言，逐渐出现了很多编码。iso8859-1属于单字节编码，最多能表示的字符范围是0-255，应用于英文系列。比如，字母a的编码为0x61=97。很明显，iso8859-1表示的字符范围很窄，无法表示中文字符。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用iso8859-1编码来表示。而且在很多协议上，默认使用该编码。比如，虽然”中文”两个字不存在iso8859-1编码，以gb2312编码为例，应该是”d6d0 cec4”两个字符，使用iso8859-1编码的时候则将它拆开为4个字节来表示：”d6 d0 ce c4”（事实上，在进行存储的时候，也是以字节为单位处理的）。而如果是UTF编码，则是6个字节”e4 b8 ad e6 96 87”。很明显，这种表示还需要以另一种编码为基础。 汉字编码: * GB2312字集是简体字集，全称为GB2312(80)字集，共包括国标简体汉字6763个。 * BIG5字集是台湾繁体字集，共包括国标繁体汉字13053个。 * GBK字集是简繁字集，包括了GB字集、BIG5字集和一些符号，共包括21003个字符。 * GB18030是国家制定的一个强制性大字集标准，全称为GB18030-2000，它的推出使汉字集有了一个“大一统”的标准。 UCS:通用字符集(Universal Character Set，UCS)是由ISO制定的ISO 10646(或称ISO/IEC 10646)标准所定义的字符编码方式，采用4字节编码。UCS包含了已知语言的所有字符。除了拉丁语、希腊语、斯拉夫语、希伯来语、阿拉伯语、亚美尼亚语、格鲁吉亚语，还包括中文、日文、韩文这样的象形文字，UCS还包括大量的图形、印刷、数学、科学符号。​ * UCS-2: 与unicode的2byte编码基本一样。​ * UCS-4: 4byte编码, 目前是在UCS-2前加上2个全零的byte。 MIME： 通用因特网邮件扩充协议，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。 因为在因特网上邮件发送协议SMTP存在几个缺点，主要是不能发送可执行文件和其他的二进制文件，只限于传送7位的ASCII码，因此MIME协议起初用于解决该问题，即是在传送二进制数据时先通过MIME转换成SMTP可传送的ACSII码，接收时再通过MIME还原成原始的二进制码。为此SMTP也响应增加了MIME-version、content-type等5个新的首部。 其中首部Content-transfer-encoding的值有5种—-“7bit”、”8bit”、”binary”、”quoted-printable”和”base64”—-其中”7bit”是缺省值，即不用转化的ASCII字符。真正常用是“quoted-printable”和”base64”两种，用以指明编码转换的方式。 MIME_type类型语法： media-type=type/subtype​ 媒体类型(type)与子类型(subtype)组成了MIME，它们之间使用反斜杠/分割，其中type可取值为：application audio example image message model multipart text video，subtype是某种类型的唯一标识符，比如：css gif xml等。常见的MIME类型： 超文本标记语言文本 .html,.html text/html普通文本 .txt text/plainRTF文本 .rtf application/rtfGIF图形 .gif image/gifJPEG图形 .ipeg,.jpg image/jpegau声音文件 .au audio/basicMIDI音乐文件 mid,.midi audio/midi,audio/x-midiRealAudio音乐文件 .ra,.ram audio/x-pn-realaudioMPEG文件 .mpg,.mpeg video/mpegAVI文件 .avi video/x-msvideoGZIP文件 .gz application/x-gzipTAR文件 .tar application/x-tar quoted-printable： 主要用于ACSII文本中夹杂少量非ASCII码字符的情况，不适合于转换纯二进制文件。它规定将每一个8位的字节，转换为3个字符。第一个字符是”=”号，这是固定不变的。 后面二个字符是二个十六进制数，分别代表了这个字节前四位和后四位的数值。举例来说，ASCII码中”换页键”（form feed）是12，二进制形式是00001100，写成十六进制就是0C，因此它的编码值为”=0C”。”=”号的ASCII值是61，二进制形式是00111101，因为它的编码值是”=3D”。除了可打印的ASCII码以外，所有其他字符都必须用这种方式进行转换。 所有可打印的ASCII码字符（十进制值从33到126）都保持原样不变，”=”（十进制值61）除外。 base64： ​ 所谓Base64，就是说选出64个字符—-小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“（再加上作为垫字的”=”，实际上是65个字符）—-作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。具体来说，转换方式可以分为四步： 第一步，将每三个字节作为一组，一共是24个二进制位。 第二步，将这24个二进制位分为四组，每个组有6个二进制位。 第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节。 第四步，根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值。 如果字节数不足三，则这样处理： a）二个字节的情况：将这二个字节的一共16个二进制位，按照上面的规则，转成三组，最后一组除了前面加两个0以外，后面也要加两个0。这样得到一个三位的Base64编码，再在末尾补上一个”=”号。比如，”Ma”这个字符串是两个字节，可以转化成三组00010011、00010110、00010000以后，对应Base64值分别为T、W、E，再补上一个”=”号，因此”Ma”的Base64编码就是TWE=。 b）一个字节的情况：将这一个字节的8个二进制位，按照上面的规则转成二组，最后一组除了前面加二个0以外，后面再加4个0。这样得到一个二位的Base64编码，再在末尾补上两个”=”号。比如，”M”这个字母是一个字节，可以转化为二组00010011、00010000，对应的Base64值分别为T、Q，再补上二个”=”号，因此”M”的Base64编码就是TQ==。 参考与引用： 十分钟搞清字符集和字符编码 浅谈编码集 字符集和字符编码（Charset &amp; Encoding）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QTCP与断线重连]]></title>
    <url>%2F2019%2F01%2F16%2FQTCP%E4%B8%8E%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E%2F</url>
    <content type="text"><![CDATA[先简单介绍一下QTcpSocket上面常用的几个信号与函数 信号名 触发条件 connected() 连接成功时 disconnected() 断开连接时 error(QAbstractSocket::SocketError socketError) 产生错误时，附带错误码 hostFound() 调用connectToHost，并且找到主机后发出，还没连接上 proxyAuthenticationRequired(const QNetworkProxy &amp; proxy, QAuthenticator * authenticator) This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection. stateChanged(QAbstractSocket::SocketState socketState) 连接状态发生改变时，会发出，附带当前状态的状态码 常用函数 简介 connectToHost 连接 disconnectFromHost 断开连接，会等待数据发送完毕 abort 立即断开，丢弃数据 state 查看当前socket的状态 error 查看当前socket的错误 close 关闭包括（I/O设备，连接，socket，重置各种数据） waitForConnected 阻塞，等待连接，连接成功发出true，超时发出false waitForReadyRead 阻塞，等待数据和readyRead信号，超时反回false waitForBytesWritten 阻塞，至少写入一个字节和发出byteswrite信号后才发出true，超时发出false waitForDisconnected 阻塞，等待断开，断开成功发出true，超时发出false read 读取，可以每次读取一定量的数据 readLine 读取一行数据 readAll 读取缓冲区所有数据 write 写入数据 断线重连机制原理​ 下面两种方法原理其实都一样，检查socket的状态，如果是断开，开启重新连接机制，连接成功，关掉机制。 一、使用定时器 基于QTcpSocket的派生类，信号和槽在构造函数中连接 在定时器的timeout信号触发时，对应的槽函数处理为 12345if( 判断当前socket的状态，没有连接上 )&#123; socket连接&#125;else &#123; 定时器stop&#125; 在socket的disconnected信号发出时，对应的槽函数处理为 123abort();disconnectFromHost();定时器启动 缺点是与当前线程占相同的资源，优点个人感觉实现起来非常简单。 二、使用线程 基于QThread的派生类，信号和槽，socket创建，需要在调用线程start前创建好 在线程的run方法中，处理如下， 12345678910while(threadRun)&#123; if( socket没有连接上 )&#123; connectToHost; waitForConnected(); 连接并产生阻塞，退出当前线程 &#125; if( socket没有连接上 )&#123; continue; &#125; waitForReadyRead(); 来到这里表示socket连接成功，产生阻塞，等待数据到来&#125; 因为socket的处理是在新的线程中运行，接收到数据需要发送到主线程中，readyRead对应的槽函数处理为 1234while( bytesAvailable()&gt;0 )&#123; byteArray=readAll(); emit signalReadyRead(byteArray);&#125;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT信号槽]]></title>
    <url>%2F2019%2F01%2F15%2FQT%E4%BF%A1%E5%8F%B7%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[个人使用过的信号槽的连接方式有三种，需要产生信号的类需要在类定义中加入Q_OBJECT，并且重新执行qmake 1.QT4信号槽12345678910111213141516171819202122connect(sender,SIGNAL(),receiver,SLOT());分别为发送信号的类，对应的信号，接收信号的类，处理信号的槽关于SIGNAL和SLOT，其实是qt的两个宏定义Q_CORE_EXPORT const char *qFlagLocation(const char *method);#ifndef QT_NO_META_MACROS#ifndef QT_NO_DEBUG# define QLOCATION "\0" __FILE__ ":" QT_STRINGIFY(__LINE__)# ifndef QT_NO_KEYWORDS# define METHOD(a) qFlagLocation("0"#a QLOCATION)# endif# define SLOT(a) qFlagLocation("1"#a QLOCATION)# define SIGNAL(a) qFlagLocation("2"#a QLOCATION)#else# ifndef QT_NO_KEYWORDS# define METHOD(a) "0"#a# endif# define SLOT(a) "1"#a# define SIGNAL(a) "2"#a#endif 2.QT5信号槽1234connect(sender,&amp;senderClassName::functionName,receiver,&amp;receiverClassName::function);因为会进行错误检查，而qt4不会，从上面可以得知，qt4信号槽的参数只是字符串。但是对于信号重载的处理比较麻烦，qt4只需要在signals里面使用()括上参数即可，而qt5需要进行强制转换。static_cast&lt;void (className::*)(parameter)&gt;(&amp;className::functionName) 3.信号与Lamda表达式结合1234567891011connect(sender,&amp;senderClassName::functionName,[=]( //parameter )&#123; //slove &#125;);[] 捕捉列表 [] 不捕获任何值 [var1,var2...] 在函数里，捕获var1,var2的值 [&amp;var1,&amp;var2...] 捕获var1,var2的引用对象 [=] 捕获所有外部变量的值 [&amp;] 捕获所有外部变量的引用() 参数 mutable 可以修改捕捉值，但是值本身不会发生改变&#123;&#125; 处理 4.隐藏的第五个参数 Constant Value Description Qt::AutoConnection 0 (默认)如果发送和接收都在同一个线程，使用Qt::DirectConnection，否则使用Qt::QueuedConnection。类型是在信号发送时才确定的 Qt::DirectConnection 1 收到信号后，马上即行 Qt::QueuedConnection 2 保存在一个队列中，当接收事件循环启动时，执行槽函数 Qt::BlockingQueuedConnection 3 与Qt::QueuedConnection类似，但是运行槽函数时，会阻塞信号线程。发送与接收不可以在同一线程，会造成死锁 Qt::UniqueConnection 0x80 可以使用OR实现多种参数连接，但是如果已经存在相同的connect时，会失败。 注意，使用连接时，需要考虑之前是否有连接，因为重新连接了相同的信号与槽，发出一个信号后，会多次触发槽函数，非常浪费资源！！ 补充介绍disconnec的使用 12345disconnect(sender,信号，receiver,槽);其中，信号、receiver、槽都可以为0(0表示任意所有) sender不能为0例1、sender多个不同的信号与receiver的一个槽绑定，参数可以这样写，（sender,0,receiver,槽）例2、sender多个信号与receiver的多个槽绑定了，（sender,0,receiver,0）例3、sender多个信号与多个receiver的多个槽绑定了，（sender,0,0,0）]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型转换]]></title>
    <url>%2F2019%2F01%2F15%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在使用这一段时间中，数据类型太多了，很多都需要转换。本章为总结。 C++强制转换有四种1234static_cast&lt;&gt;()dynamic_cast&lt;&gt;()const_cast&lt;&gt;()reinterpret_cast&lt;&gt;() static_cast 基本数据的转换、空指针与指针之间的转换 目前使用于信号槽函数强制转换，基于QT5的新特性，在使用connect时，第二第四个参数产生的为&amp;className::functionName，如果函数被重载了，QT无法判断需要使用哪个信号，即使你的槽函数设置对应的参数，这里需要对第二个参数进行强制转换，如下。 static_cast&lt;void (className::*)(parameter)&gt;(&amp;className::functionName)这样可以将函数进行强制转换，解决信号定位的问题。 dynamic_cast&lt;&gt;() 类的下行转换，由基数向派生类转换 目前没有使用过 const_cast&lt;&gt;() 去掉const或者volatile属性 12const char *cstr="rts";char *str=const_cast&lt;char *&gt;(cstr); reinterpret_cast&lt;&gt;() 主要将数据从一种类型转换为另一种类型，二进制的形式重新解释 在使用windows api的时候，需要使用宽字符wcahr_t，而qt里面没有原这样的类型，但是qstring有转换成宽字符的函数，操作如下 12QString str;reinterpret_cast&lt;const wchar_t *&gt;(str.utf16()); 百度百科介绍，static_cast进行类的转换，会进行实际的偏移，而reinterpret_cast不会]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo建站小结]]></title>
    <url>%2F2019%2F01%2F06%2FHexo%E5%BB%BA%E7%AB%99%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[搭建工作下载安装 node.js 和 git 默认安装即可安装成功后，右击系统菜单键会多出两项 在系统盘上，找个地方，如D:/github/ 进入到文件夹，右击，点击Git Bash Here 安装Hexo12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 意思分别为 安装hexo hexo在blog文件夹初始化，不需要手动创建 (blog可以改变，只是一个文件夹名字) 进入blog文件夹 安装扩展插件 开启服务，此时在浏览器输入http://localhost:4000/ 或者 http://127.0.0.1:4000 可以看到相关页面（ctrl+c退出） Hexo常用命令123456hexo generate (hexo g) 编译生成hexo server (hexo s) 启动服务hexo deploy (hexo d) 上传hexo new page &quot;p&quot; 生成一个p页面 hexo new &quot;p&quot; 生成一个标题为p的新文章hexo clean 清除编译生成 Hexo还有很多插件，如果下面使用过程中发现问题，可以百度查找，安装对应的插件创建一个Github代码仓库 如果没有帐号，需要注册一个 点击在网页右上角，选择新建仓库 仓库的Repository name为仓库名，格式有规定，如果你注册的github帐户名为orz，那么这里就要填orz.github.io，其它设置看介绍，创建仓库 添加SSH数据提交这里选择SSH，下面是SSH安装与Github绑定SSH安装1234567ls ~/.ssh检查是否安装了ssh，如果有id_rsa.pub，跳过下面步骤ssh-keygen -t rsa -C &quot;邮箱地址&quot;安装的时候，连续点击三次回车，分别是跳过文件夹和把密码设置为空pwd ~/.ssh查看ssh的安装路径 绑定 找到ssh/id_rsa.pub，打开，复制全部内容 打开github网站，选择SSH and GPG keys New SSH Key标题随便写，将复制的内容写到Key里面，添加 验证是否连通 输入 ssh -T git@github.com如果看到你在github注册的帐号名，即表示成功 初始化设置打开D:/github/blog/_config.yml 1234deploy: type: git repo: branch: master rope的值参考下图 点击Clone or download弹出的链接 写入到_config.yml的rope 注意和：有一个空格，不能少 主题设置从网上查找Hexo主题，下载放到D:/github/blog/themes里面。打开D:/github/blog/_config.yml将theme：改为刚刚下载的主题文件夹名。其余设置需要参考主题的介绍 纸上得来终觉㳀，绝知此事要躬行]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
