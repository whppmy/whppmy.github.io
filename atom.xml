<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BugNull</title>
  
  <subtitle>纸上得来终觉浅，绝知此事要躬行</subtitle>
  <link href="http://bugnull.com/atom.xml" rel="self"/>
  
  <link href="http://bugnull.com/"/>
  <updated>2022-08-30T12:22:44.851Z</updated>
  <id>http://bugnull.com/</id>
  
  <author>
    <name>whppmy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>物理层基本概念</title>
    <link href="http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:12:20.788Z</published>
    <updated>2022-08-30T12:22:44.851Z</updated>
    
    <content type="html"><![CDATA[<p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流<br>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么</p><p>物理层协议主要任务：<br>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置<br>电气特性：指明在接口电缆的各条线上出现的电压范围<br>功能特性：指明某条线上出现的某一电平的电压表示何种意义<br>过程特性：指明对于不同功能的各种可能事的出现顺序</p><p>传输媒体（不同媒体对应不同的物理层协议）：<br>1、导引型：双绞线（网线）、同轴电缆、光纤、电力线<br>2、非导引型：微波通信（2~40GHz)、无线电波、红外线、可见光</p><p>传输方式<br>1、串行（远距离传输，如计算机网络）。并行（CPU与内存之间，通过总线进行传输）<br>2、同步：以稳定的比特流传输，字节间没有间隔，接收端在中间时刻进行检测0或1，此时会有时钟累计误差。需要保持时钟同步。外同步：在收发双方间添加一条单独的时钟信号线。内同步：发送端将时钟同步信号编码到发送数据中一起传输（曼彻斯特编码）。异步：以一个字节为单位传输，字节间异步，在字节前后增加头和尾作为判断。<br>3、单工：单向通信（收音机）。半双工：双向交替通信，可以相互通信但不能同时（对讲机）。全双工：双向同时通信（电话）</p><p><img src="/2022/08/30/网络/2.物理层基本概念/调制与编码.png" alt="编码与调制"></p><p>常用编码：不归零编码（存在同步问题，需要额外传输时钟，不常用），归零编码（自同步，编码效率低，用零电频做隔断），曼彻斯特编码（用码元间跳变表示时钟，又表示数据），差分曼彻斯特编码</p><p><img src="/2022/08/30/网络/2.物理层基本概念/常用编码.png" alt="常用编码方法"></p><p><img src="/2022/08/30/网络/2.物理层基本概念/常用调制.png" alt="常用调制方法"></p><p>频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位中的一个。相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。</p><p>信号在信道中传输会存在失帧的可能，其中因素娄：码元传输速率，信号传输距离，噪声干扰，传输媒体质量。</p><p><img src="/2022/08/30/网络/2.物理层基本概念/信道极限容量.png" alt="奈氏准则和香农公式"></p>]]></content>
    
    
    <summary type="html">物理层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>MAC、IP、ARP基本概念</title>
    <link href="http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/4.MAC%E3%80%81IP%E3%80%81ARP/"/>
    <id>http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/4.MAC%E3%80%81IP%E3%80%81ARP/</id>
    <published>2022-08-30T12:11:57.657Z</published>
    <updated>2022-08-30T12:28:19.542Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/08/30/网络/4.MAC、IP、ARP/MAC、IP、ARP三者关系.png" alt="三者关系"><br><img src="/2022/08/30/网络/4.MAC、IP、ARP/MAC地址定义.png" alt="三者关系"><br><img src="/2022/08/30/网络/4.MAC、IP、ARP/MAC地址小结.png" alt="三者关系"><br>单播：表示只传给指定MAC地址，多播：表示该网络接口所在的多播地址，一个接口可以在多个多播地址，与帧的目的MAC地址符合，即接收该帧，广播：地址为FF:FF:FF:FF:FF:FF，所有人都接收<br><img src="/2022/08/30/网络/4.MAC、IP、ARP/IP地址定义.png" alt="三者关系"><br><img src="/2022/08/30/网络/4.MAC、IP、ARP/MAC与IP的关系与传输过程.png" alt="三者关系"></p><p><img src="/2022/08/30/网络/4.MAC、IP、ARP/ARP地址解析协议过程.png" alt="三者关系"><br><img src="/2022/08/30/网络/4.MAC、IP、ARP/ARP地址解析协议过程1.png" alt="三者关系"><br>ARP只能在同一个链路或者同一个网络上使用</p><p><img src="/2022/08/30/网络/4.MAC、IP、ARP/MAC、IP、ARP三者关系小结.png" alt="三者关系"></p>]]></content>
    
    
    <summary type="html">MAC、IP、ARP基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层基本概念</title>
    <link href="http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:11:57.287Z</published>
    <updated>2022-08-30T12:29:01.150Z</updated>
    
    <content type="html"><![CDATA[<p>封装成帧：在链路层会对IP数据报文添加帧头和帧尾</p><ul><li>帧头和帧尾包含重要的控制信息</li><li>帧头和帧尾作为帧定界，可以通过物理层交付的比特流中提取一个个的帧（PPP帧），并不是所有都包含帧定界标志（以太网V2 MAC帧），而物理层会在传输前增加8字节前导码（前7位是同步码，作为时钟同步，之后一字节作为定界符）再转为电信号发送，以太网规定帧间间隔（96比特时间）</li><li>透明传输，指数据链路层对上层交付的传输数据没有任何限制，若数据中存在帧尾字段，链路层会在该位置做字符标记（在前增加esc  ascill=27）做比特处理（每5位1后插入1个0）等，以防止在解析时提前结束帧（字符填充或者零比特填充）</li></ul><p>差错检测：比特在实际传输过程中可能会产生差错，称为比特差错或误码。一段时间内，传输错误的比特占总传输比特的比率为误码率BER。检错后一般进行重传来纠正传输中的差错或者仅仅是德育检测到差错的帧，取决于是可靠传输还是不可靠传输</p><ul><li>在以太网V2 MAC帧中，帧尾包含4字节的帧检验序列FCS字段，检测是否有误码</li><li>在PPP帧中，帧尾包含2字节FCS</li><li>奇偶校验，在待发送数据后面添加1位奇偶校验，使整个数据（包括校验位）中1的个数为奇数或者偶数，漏检率高</li><li>循环冗余校验，约定一个生成多项式，基于数据和多项式计算出冗余码，添加到数据后面一起传输，漏检率非常低，易于硬件实现，广泛用于数据链路层<br><img src="/2022/08/30/网络/3.数据链路层基本概念/循环冗余校验.png" alt="循环冗余检验CRC"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/循环冗余计算过程.png" alt="循环冗余检验CRC"></li><li>检测码只能检测出是否出错，不能定位，无法纠正错误，可以使用冗余信息更多的纠错码进行前向纠错，开销较大</li></ul><p>可靠传输：根据数据链路层向上层提供的服务类型，其可靠性不一定由数据链路层实现，其它各层均可选择实现可靠传输</p><ul><li>不可靠传输服务：仅仅丢弃有误码的帧</li><li>可靠传输服务：想办法实现发送端发送什么，接收端就收到什么</li><li>有线误码率低，不要求数据链路层向上提供可靠传输。即使出现误码，可靠传输的问题由其上层处理。</li><li>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</li><li><p>传输差错类型，比特差错、分组丢失、分组失序、分组重复，分组表示的是帧<br><img src="/2022/08/30/网络/3.数据链路层基本概念/各层对可靠及不可靠传输类型.png" alt="各层可靠性类型"></p><p>可靠传输实现机制的原理，不仅限于数据链路层</p></li><li>停止-等待协议SW（自动请求重传ARQ）<br><img src="/2022/08/30/网络/3.数据链路层基本概念/停止-等待.png" alt="传输机制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/停止-等待信道利用率.png" alt="传输机制"></li><li>回退N帧协议GBN（连续ARQ，滑动窗口协议）<ul><li>制定比特给分组编号，发送窗口尺寸，表示一次发多个组，尺寸不能大于分组号-1，接收窗口尺寸为1，（若发送尺寸==分组数，则会接口窗口检测不到错误，依然把0号放置于0号，认为正确，实际是忽略了一个组），接收窗口只能等于1，只能按序接收，数据分组内出现误码后面的分组都会丢弃。</li><li>由停止-等待发送1个改为多个，串行改并行</li><li>累积确认，在接收到前N组时，可以直接发送ACKn表示已经接收到N组数据，减少资源占用</li><li>当多个到达接收方时，出现误码，不仅会丢弃该帧，还会把序号不匹配的丢弃，重新发送多个已经接收到最大序号的ACKn<br><img src="/2022/08/30/网络/3.数据链路层基本概念/回退N帧定义.png" alt="传输机制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/回退N帧，发送与接收工作机制.png" alt="传输机制"></li></ul></li><li>选择重传协议SR<ul><li>对回退N帧进行扩展，发送滑动窗口&gt;=接收窗口&gt;=1，可进行多组分别确认，但是取消累积确认<br><img src="/2022/08/30/网络/3.数据链路层基本概念/选择重传协议定义.png" alt="传输机制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/选择重传协议工作机制.png" alt="传输机制"></li></ul></li></ul><p>点对点协议PPP：目前使用最广泛的点对点数据链路层协议，向上不提供可靠传输<br>  <img src="/2022/08/30/网络/3.数据链路层基本概念/点对点协议定义.png" alt="点对点协议"><br>  <img src="/2022/08/30/网络/3.数据链路层基本概念/PPP帧格式.png" alt="点对点协议"></p><ul><li><p>实现透明传输，面向字节的异步链路，字节填充法，对特殊字符前插入转义字符，转义字符再插入转义字符。面向比特的同步链路，比特填充法，对于连续5位1的后面插入一个0。<br><img src="/2022/08/30/网络/3.数据链路层基本概念/PPP工作状态.png" alt="点对点协议"></p><p><img src="/2022/08/30/网络/3.数据链路层基本概念/媒体接入控制.png" alt="媒体接入控制"></p><p>信道复用：</p></li><li>频分复用FDM：根据频带划分出多个了频带（信道），频带间需要有隔离频带</li><li>时分复用TDM：将传输带宽资源按时隙轮流分配给不同用户，用户只能在对应的时隙进行通信，周期性出现，一周期就是一个TDM帧</li><li>波分复用WDM：即光的频分复用，将每路（1310nm波长，2.5Gb/s）变换到1550~1561.2nm，共8路，相隔1.6nm，在同一根光纤传输，光传输会损失，中间需要掺铒光纤放大器EDFA。</li><li><p>码分复用CDM：</p><p><img src="/2022/08/30/网络/3.数据链路层基本概念/码分复用例子.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/静态划分信道小结.png" alt="媒体接入控制"></p><p>动态接入控制：<br>CSMA-CD适用于有线<br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CD概念.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CD争用期.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CD最小帧长.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CD最大帧长.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CD退避算法.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CD信道利用率.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CD发送流程.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CD接收流程.png" alt="媒体接入控制"><br>CSMA/CA适用于无线<br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CA与CD区别.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CA与CD应用.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CA帧间间隔IFS.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CA工作原理.png" alt="媒体接入控制"><br>等待DIFS表示有高优先级让其先传。等待SIFS表示最短帧间间隔，用来分隔属于一次对话的各帧。<br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CA退避算法.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CA退避算法例子.png" alt="媒体接入控制"><br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CA信道预约.png" alt="媒体接入控制"><br>请求发送RTS:帧包括源地址、目的地址及所需要时间 允许发送CTS:也包括此次通信时间<br><img src="/2022/08/30/网络/3.数据链路层基本概念/CSMA-CA虚拟载波监听.png" alt="媒体接入控制"><br>解决A C互为隐蔽站的问题，C通过CTS知道B被占用的时间</p></li></ul>]]></content>
    
    
    <summary type="html">数据链路层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>集线器与交换机基本概念</title>
    <link href="http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/5.%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA/"/>
    <id>http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/5.%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA/</id>
    <published>2022-08-30T12:11:57.238Z</published>
    <updated>2022-08-30T13:07:34.216Z</updated>
    
    <content type="html"><![CDATA[<p>总线型使用大量机械接头和无源电缆并不可靠</p><p><img src="/2022/08/30/网络/5.集线器与交换机/总线型以太网和集线器HUB的星型以太网.png" alt="总线型与星型"></p><p>可以使用集线器HUB在物理层扩展以太网，将多个碰撞域（冲突域）合并成一个更大的冲突域，在一系中的一台主机要发送给二系中一台主机，该帧信号会传输到整个网络的各个主机。</p><p>交换机会把单播帧转发到目的主机（忽略ARP过程，假设交换机的帧交换表已“学习好了”）<br><img src="/2022/08/30/网络/5.集线器与交换机/集线器与交换机SWITCH的区别.png" alt="集线器与交换机"></p><p>集线器一般使用CSMA/CD争取总线资源，只能半双工，而交换机可以进行全双工，同时进行收发工作。<br><img src="/2022/08/30/网络/5.集线器与交换机/交换机工作状态.png" alt="交换机工作状态"></p><p><img src="/2022/08/30/网络/5.集线器与交换机/对比集线器和交换机.png" alt="交换机工作状态"></p><p>交换机工作在数据链路层（也包括物理层—），集线器工作在物理层，前者性能快<br><img src="/2022/08/30/网络/5.集线器与交换机/集线器与交换机小结.png" alt="交换机工作状态"></p><p>以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。是即插即用设备，刚上电内部帧交换表是空的，随通信进行处学习算法，自动逐渐建立起帧交换表。</p><p>盲目泛洪类似广播，登录会在发送方时登记，每条记录都有时效，到期自动删除，MAC与交换机接口关系不是永久性的，更换主机、更换网卡。ARP高速缓存表中IP与MAC对应关系同样会到期自动删除。<br><img src="/2022/08/30/网络/5.集线器与交换机/交换机自学习过程.png" alt="交换机自学习"></p><p><img src="/2022/08/30/网络/5.集线器与交换机/交换机网络环路和广播风暴.png" alt="交换机自学习"></p><p>使用生成树协议，保证没有环路网络<br><img src="/2022/08/30/网络/5.集线器与交换机/生成树协议STP.png" alt="交换机自学习"></p><p>当交换机以太网足够大时，进行广播会有很大的开销<br>路由器工作在网络层，一般不转发广播，可以将交换机以太网分割成小的广播域<br><img src="/2022/08/30/网络/5.集线器与交换机/广播频繁.png" alt="虚拟VLAN"></p><p><img src="/2022/08/30/网络/5.集线器与交换机/虚拟局域网VLAN.png" alt="虚拟VLAN"></p><p><img src="/2022/08/30/网络/5.集线器与交换机/IEEE802-1Q帧.png" alt="虚拟局域网VLAN实现机制"></p><p>交换机端口类型有以下三种：Access Trunk Hybrid<br>交换机各端口的缺少VLAN ID  思科上称为Native VLAN 即本征VLAN  华为上称Port VLAN ID即端口VLAN ID,PVID</p><p><img src="/2022/08/30/网络/5.集线器与交换机/Access端口打标签与去标签.png" alt="虚拟局域网VLAN实现机制"></p><p><img src="/2022/08/30/网络/5.集线器与交换机/Trunk端口转发.png" alt="虚拟局域网VLAN实现机制"></p><p><img src="/2022/08/30/网络/5.集线器与交换机/VLAN端口类型转发.png" alt="虚拟局域网VLAN实现机制"></p><p><img src="/2022/08/30/网络/5.集线器与交换机/Hybrid端口转发.png" alt="虚拟局域网VLAN实现机制"></p>]]></content>
    
    
    <summary type="html">集线器与交换机概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>网络层基本概念</title>
    <link href="http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/6.%E7%BD%91%E7%BB%9C%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/6.%E7%BD%91%E7%BB%9C%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:11:56.808Z</published>
    <updated>2022-08-30T12:30:07.030Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/08/30/网络/6.网络层基本概念/网络层概述.png" alt="网络层概述"></p><p><img src="/2022/08/30/网络/6.网络层基本概念/面向连接的虚电路服务.png" alt="网络层提供的两种服务"><br><img src="/2022/08/30/网络/6.网络层基本概念/无连接的数据报服务.png" alt="网络层提供的两种服务"><br><img src="/2022/08/30/网络/6.网络层基本概念/虚电路与数据报服务对比.png" alt="网络层提供的两种服务"></p><p>32比特的IPV4地址不便阅读、记录、输入，因此采用点分十进制表示方法，8个一组，用.分开<br><img src="/2022/08/30/网络/6.网络层基本概念/IPV4地址概述.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/IPV4地址分类.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/IPV4-A类地址.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/IPV4-B类地址.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/IPV4-C类地址.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/IPV4编址例题.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/IPV4编址例题2.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/IPV4小结.png" alt="IPV4"></p><p>增加子网时候，需要申请新的网络号，等待时间和钱，增加路由路中路由表记录数量，浪费原网络中剩余的IP。此时需要引入子网掩码，通过与运算，取出IPV4地址所在子网的网络地址<br><img src="/2022/08/30/网络/6.网络层基本概念/子网掩码.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/子网掩码例题.png" alt="IPV4"></p><p><img src="/2022/08/30/网络/6.网络层基本概念/无分类编址的IPV4.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/无分类编址的IPV4_2.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/无分类编址的IPV4_3.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/无分类编址的IPV4小结.png" alt="IPV4"></p><p>定长即使用同一个子网掩码来划分子网，只能划分出2^n个子网，从主机号借用的。容易造成IP地址浪费。使用不同的子网掩码来划分子网，更灵活，按需分配，子网数量可以不同，减少浪费。<br><img src="/2022/08/30/网络/6.网络层基本概念/定长的子网掩码FLSM.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/变长的子网掩码VLSM.png" alt="IPV4"></p><p>路由器收到出错的数据报，丢弃后，向源主机发送ICMP数据报。<br><img src="/2022/08/30/网络/6.网络层基本概念/IP数据报的发送和转发.png" alt="路由器"></p><p>产生环路，会使用TTL进行计算，为零时抛弃，或者加入黑洞路由，使用默认路由后，当不知道转发给哪里就会转发到默认路由<br><img src="/2022/08/30/网络/6.网络层基本概念/静态路由配置及路由环路.png" alt="路由器"></p><p><img src="/2022/08/30/网络/6.网络层基本概念/静态路由选择和动态路由选择.png" alt="路由器"></p><p>在两个自治系统中，内部使用的是IGP或IRP内部网关（路由）协议，之间使用的是EGP或ERP外部网关（路由）协议，仅表示协议，不表示实际使用什么算法<br><img src="/2022/08/30/网络/6.网络层基本概念/因特网路由选择协议特点.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/常见路由选择协议.png" alt="路由器"><br>路由器会定期发送自己的路由信息<br><img src="/2022/08/30/网络/6.网络层基本概念/路由器基本结构.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/路由信息协议RIP工作原理.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/RIP更新规则.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/RIP坏消息传播慢问题.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/RIP小结.png" alt="路由器"></p><p><img src="/2022/08/30/网络/6.网络层基本概念/基于LSDB进行最短路径优先SPF计算.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/OSPF五种分组类型.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/OSPF工作过程.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/OSPF多点网络路由器邻居关系建立.png" alt="路由器"><br>减少信息洪泛，一个区域一般最多200个路由<br><img src="/2022/08/30/网络/6.网络层基本概念/OSPF把自治系统再划分为更小的区域.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/OSPF小结.png" alt="路由器"></p><p><img src="/2022/08/30/网络/6.网络层基本概念/边界网关协议BGP.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/BGP发言人.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/BCP发言人构造的连通图.png" alt="路由器"><br>BGP-4报文封装在TCP报文段中<br><img src="/2022/08/30/网络/6.网络层基本概念/BGP-4的四种报文.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/封装报文的协议.png" alt="路由器"><br><img src="/2022/08/30/网络/6.网络层基本概念/BGP小结.png" alt="路由器"></p><p><img src="/2022/08/30/网络/6.网络层基本概念/IPV4数据报分片.png" alt="IPV4"><br><img src="/2022/08/30/网络/6.网络层基本概念/IPv4数据报首部格式.png" alt="IPV4"></p><p><img src="/2022/08/30/网络/6.网络层基本概念/ICMP网际控制报文.png" alt="ICMP"><br><img src="/2022/08/30/网络/6.网络层基本概念/ICMP小结.png" alt="ICMP"></p><p>R1与R2之间类似点对点，也称IP隧道技术<br><img src="/2022/08/30/网络/6.网络层基本概念/VPN虚拟专用网.png" alt="VPN"></p><p><img src="/2022/08/30/网络/6.网络层基本概念/NAP网络地址转换.png" alt="NAP"><br><img src="/2022/08/30/网络/6.网络层基本概念/NAPT网络地址与端口号转换.png" alt="NAPT"><br><img src="/2022/08/30/网络/6.网络层基本概念/VPN与NAT小结.png" alt="NAPT"></p>]]></content>
    
    
    <summary type="html">网络层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>运输层基本概念</title>
    <link href="http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/7.%E8%BF%90%E8%BE%93%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/7.%E8%BF%90%E8%BE%93%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:11:56.616Z</published>
    <updated>2022-08-30T12:30:24.567Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/08/30/网络/7.运输层基本概念/运输层概念.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/运输层概念小结.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/端口号.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/分用与复用.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/应用层常用协议端口号.png" alt="运输层"></p><p>UDP无连接，TCP三次握手、四次挥手<br><img src="/2022/08/30/网络/7.运输层基本概念/UDP与TCP对比1.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/UDP与TCP对比2.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/UDP与TCP对比3.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/UDP与TCP对比4.png" alt="运输层"><br>TCP规定，即使接收窗口为0，也要接收零窗口探测报文、确认报文、带有紧急数据的报文<br><img src="/2022/08/30/网络/7.运输层基本概念/TCP流量控制.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP流量控制过程1.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP流量控制例题.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP拥塞控制.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP拥塞控制过程.png" alt="运输层"></p><p>慢开始会以2倍数增长拥塞窗口，拥塞避免是线性增加1<br><img src="/2022/08/30/网络/7.运输层基本概念/TCP的拥塞算法慢开始与拥塞避免.png" alt="运输层"><br>不等超时，就进行重传，需要接收连续三个确认<br><img src="/2022/08/30/网络/7.运输层基本概念/TCP的拥塞算法慢开始与拥塞避免的不足.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP拥塞算法快重传.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP拥塞算法快恢复.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP拥塞控制综合.png" alt="运输层"></p><p><img src="/2022/08/30/网络/7.运输层基本概念/TCP超时重传时间的选择.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP超时重传时间计算公式.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP超时重传往返时间.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP超时重传时间出错纠正方法.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP超时重传时间例题.png" alt="运输层"></p><p>不推荐发送窗口前沿收缩，有可能这些数据已经发送了<br><img src="/2022/08/30/网络/7.运输层基本概念/TCP可靠传输的实现滑动窗口滑动.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP可靠传输的实现滑动窗口状态.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP可靠传输的实现滑动窗口过程.png" alt="运输层"></p><p><img src="/2022/08/30/网络/7.运输层基本概念/TCP连接的三个阶段.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP连接建立解决的问题.png" alt="运输层"><br>建立连接前，服务器会先创建传输控制块（TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针、当前的发送和接收序号、。。。），然后进行LISTEN<br>客户端要发起连接时，也先创建传输控制块<br>第三次握手是为了防止多连接，而消耗掉服务器资源<br>SYN=1的报文段不能携带数据，但要消耗一个序号、普通确认报文如果不带数据，则不消耗序号<br>x客户端选择作为初始序号，y为服务端选择的初始序号<br><img src="/2022/08/30/网络/7.运输层基本概念/TCP三次握手连接过程.png" alt="运输层"></p><p>FIN=1的报文段不能携带数据，但要消耗一个序号。v等于TCP客户进程之前收到的最后一个字节序号+1。u等于TCP客户进程之前已传送过数据的最后一个字节序号+1。<br><img src="/2022/08/30/网络/7.运输层基本概念/TCP四次挥手过程.png" alt="运输层"><br><img src="/2022/08/30/网络/7.运输层基本概念/TCP保活机制.png" alt="运输层"></p>]]></content>
    
    
    <summary type="html">运输层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>应用层基本概念</title>
    <link href="http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/8.%E5%BA%94%E7%94%A8%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/8.%E5%BA%94%E7%94%A8%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:11:56.286Z</published>
    <updated>2022-08-30T12:30:37.121Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/08/30/网络/8.应用层基本概念/应用层概念.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/CS方式.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/P2P方式.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/DHCP动态主机配置协议.png" alt="应用层"><br>请求中会带有《事务ID》，用带确保是自己发出而得到的回应<br><img src="/2022/08/30/网络/8.应用层基本概念/DHCP过程.png" alt="应用层"><br>路由器不会转发广播，需要在上面配置DHCP服务器IP，才能进行单播传送<br><img src="/2022/08/30/网络/8.应用层基本概念/DHCP中继代理.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/DHCP小结.png" alt="应用层"></p><p>DNS服务器，用于查找域名-&gt;IP  使用UDP 端口53<br><img src="/2022/08/30/网络/8.应用层基本概念/域名结构.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/域名服务器类别.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/域名查询方式.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/域名缓存.png" alt="应用层"></p><p><img src="/2022/08/30/网络/8.应用层基本概念/FTP概念.png" alt="应用层"><br>控制连接会保持打开，数据连接传输完成就关闭<br><img src="/2022/08/30/网络/8.应用层基本概念/FTP工作原理.png" alt="应用层"></p><p>基于TCP<br><img src="/2022/08/30/网络/8.应用层基本概念/电子邮件概念.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/SMTP工作原理.png" alt="应用层"><br>STMP只能传输ASCII，因而引进了MIME，将图片、文件转为ASCII或者将ASCII进行逆转换。MIME同样应用于HTTP<br><img src="/2022/08/30/网络/8.应用层基本概念/SMTP补充.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/POP3邮局协议.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/基于万维网的电子邮件.png" alt="应用层"></p><p><img src="/2022/08/30/网络/8.应用层基本概念/WWW万维网概念.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/URL的组成.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/HTTP请求报文.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/HTTP响应报文.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/Cookie概念.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/Cookie工作流程.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/WWW缓存与代理服务器.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/HTTP请求例题.png" alt="应用层"><br><img src="/2022/08/30/网络/8.应用层基本概念/WWW小结.png" alt="应用层"></p>]]></content>
    
    
    <summary type="html">应用层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/1.%E8%AE%A1%E8%87%AC%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/1.%E8%AE%A1%E8%87%AC%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2022-08-30T12:11:55.150Z</published>
    <updated>2022-08-30T12:21:57.549Z</updated>
    
    <content type="html"><![CDATA[<p>三种电路交换优缺点对比：<br>电路交换（比特流直达）<br>优点：通信时延小、有序、没有冲突、适用范围广、实时性强、控制简单<br>缺点：建立连接时间长、线路独占，使用效率低、灵活性差、难以规格化<br>报文交换（整组报文转发）<br>优点：无需建立连接、动态分配线路、线路可靠性、线路利用率高、多目标服务<br>缺点：转发时延、较大存储缓存空间、传输额外的信息量<br>分组交换<br>优点：无需建立连接、线路利用率高、简化存储管理、加速传输、减少出错和重发数据量<br>缺点：转发时延、传输额外的信息量、采用数据报服务时存在失序、丢失或者重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程。</p><p>时延=发送时延（分组长度/发送数率）+传播时延（信道长度/电磁波传播速率）+处理时延（硬件相关）</p><p>时延带宽积=传播时延*带宽</p><p>利用率：<br>信道利用率 用来表示信道百分之几的时间是有数据通过<br>网络利用率 全网络的信道利用率的加权平均<br>当前时延=空闲时延/(1-利用率)  当得用率达到50%以上时，则时延会增大，可以考虑扩容，增大线路的带宽。<br>尽量动态控制通信量，保持在合理范围内。</p><p>丢包：<br>接口、结点、链路、路径、网络丢包。<br>分组丢失：分组在传输过程中出现误码，被结点丢弃；到达一台队列已满的分组交换机时被丢弃。</p><p>OSI体系结构，七层协议<br>物理、数据链路、网络、运输、会话、表示、应用层<br>TCP/IP体系结构、四层协议<br>网络接口 网络接口<br>网际 IP将网络接口互联、向TCP、UDP提供网络互联服务(IP over everythins、Everything over IP)<br>运输 TCP(在IP服务的基础上，向应用层提供可靠性传输服务) UDP(…不可靠传输服务)<br>应用层 HTTP SMTP DNS RTP</p><p>原理体系结构（适用教学）<br>应用 解决通过应用进程的交互来实现特定网络应用的问题 应用进程间交互来完成特定的网络应用<br>运输 解决进程之间基于网络的通信问题 解决进程间、传输错误处理<br>网络 解决分组在多个网络上传输（路由）的问题 路由功能，如使用IP<br>数据链路 解决分组在一个网络（或链路）上传输的问题 如使用MAC标记主机<br>物理层 解决使用何种信号来传输比特的问题 硬件如网络网口、传输方式</p><p>由应用层向物理层转变 http（报文） -&gt; http+TCP（TCP报文段） -&gt; http+TCP+IP（IP数据报） -&gt; ETH+http+TCP+IP+ETH（帧） -&gt;  ….+前导码（比特流）</p><p>协议的三要素<br>语法 定义所交换信息的格式<br>语义 定义收发双方所要完成的操作<br>同步 定义收发双方的时序关系</p><p>协议数据单元PDU 对等层次之间传送的数据包称为该层的协议数据单元<br>服务数据单元SDU 同一系统内，层与层之间交换的数据包称为服务数据单元<br>多个SDU可以合成一个PDU，一个SDU可以划分为几个PDU</p>]]></content>
    
    
    <summary type="html">计算机网络基础小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>什么是微服务架构</title>
    <link href="http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://bugnull.com/2022/08/30/%E7%BD%91%E7%BB%9C/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-08-29T16:05:19.354Z</published>
    <updated>2022-08-29T16:05:19.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构是一种架构模式或者架构风格，<strong>它提倡将单一应用程序划分成一组小的服务</strong>，每个服务运行在其独立的<strong>进程中</strong>，服务间互相协调、互相配合，为用户提供最终价值。服务间采用轻量级通信机制（通常基于HTTP的RESTful API）。每个服务都围绕着具体业务进行构建，并且能独立部署到生产环境。应尽量避免统一的、集中式的服务管理机制，对具体的服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有非常轻量的集中式管理来协调这些服务，可以使用不同的语言，也可以使用不同的数据存储。</p><p>由All in one，拆分成不同的模块（进程），一个服务做一件事，进行解耦。</p>]]></content>
    
    
    <summary type="html">记录微服务的理解</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>23.官方示例ffplay结构体</title>
    <link href="http://bugnull.com/2020/03/13/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/23-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8Bffplay%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://bugnull.com/2020/03/13/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/23-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8Bffplay%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2020-03-12T16:23:44.000Z</published>
    <updated>2022-08-28T16:03:28.809Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyAVPacketList</span> &#123;</span><span class="comment">//Packet链表 不使用AVPacketList</span></span><br><span class="line">    AVPacketpkt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyAVPacketList</span>*<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span>serial;</span><br><span class="line">&#125; MyAVPacketList;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PacketQueue</span> &#123;</span><span class="comment">//packet队列</span></span><br><span class="line">    MyAVPacketList*first_pkt, *last_pkt;</span><br><span class="line">    <span class="keyword">int</span>nb_packets;                 <span class="comment">// 包数量，也就是队列元素数量</span></span><br><span class="line">    <span class="keyword">int</span>size;                       <span class="comment">// 队列所有元素的数据大小总和</span></span><br><span class="line">    <span class="keyword">int64_t</span>duration;               <span class="comment">// 队列所有元素的数据播放持续时间</span></span><br><span class="line">    <span class="keyword">int</span>abort_request;              <span class="comment">// 用户退出请求标志</span></span><br><span class="line">    <span class="keyword">int</span>serial;                     <span class="comment">// 播放序列，所谓播放序列就是一段连续的播放动作，一个seek操作会启动一段新的播放序列</span></span><br><span class="line">    SDL_mutex*mutex;                 <span class="comment">// 互斥量</span></span><br><span class="line">    SDL_cond*cond;                  <span class="comment">// 条件变量 产生阻塞</span></span><br><span class="line">&#125; PacketQueue;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameQueue</span> &#123;</span></span><br><span class="line">    Frame <span class="built_in">queue</span>[FRAME_QUEUE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> rindex;                     <span class="comment">// 读索引。待播放时读取此帧进行播放，播放后此帧成为上一帧</span></span><br><span class="line">    <span class="keyword">int</span> windex;                     <span class="comment">// 写索引</span></span><br><span class="line">    <span class="keyword">int</span> size;                       <span class="comment">// 总帧数</span></span><br><span class="line">    <span class="keyword">int</span> max_size;                   <span class="comment">// 队列可存储最大帧数</span></span><br><span class="line">    <span class="keyword">int</span> keep_last;                  <span class="comment">// 是否保留已播放的最后一帧使能标志</span></span><br><span class="line">    <span class="keyword">int</span> rindex_shown;               <span class="comment">// 是否保留已播放的最后一帧实现手段</span></span><br><span class="line">    SDL_mutex *mutex;</span><br><span class="line">    SDL_cond *cond;</span><br><span class="line">    PacketQueue *pktq;              <span class="comment">// 指向对应的packet_queue</span></span><br><span class="line">&#125; FrameQueue;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AudioParams</span> &#123;</span><span class="comment">//音频参数</span></span><br><span class="line">    <span class="keyword">int</span>freq;                   <span class="comment">// 采样率</span></span><br><span class="line">    <span class="keyword">int</span>channels;               <span class="comment">// 通道数</span></span><br><span class="line">    <span class="keyword">int64_t</span>channel_layout;         <span class="comment">// 通道布局，比如2.1声道，5.1声道等</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormatfmt;            <span class="comment">// 音频采样格式，比如AV_SAMPLE_FMT_S16表示为有符号16bit深度，交错排列模式。</span></span><br><span class="line">    <span class="keyword">int</span>frame_size;             <span class="comment">// 一个采样单元占用的字节数（比如2通道时，则左右通道各采样一次合成一个采样单元）</span></span><br><span class="line">    <span class="keyword">int</span>bytes_per_sec;          <span class="comment">// 一秒时间的字节数，比如采样率48Khz，2 channel，16bit，则一秒48000*2*16/8=192000</span></span><br><span class="line">&#125; AudioParams;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前帧(待播放)显示时间戳，播放后，当前帧变成上一帧</span></span><br><span class="line">    <span class="keyword">double</span> pts;           <span class="comment">/* clock base */</span></span><br><span class="line">    <span class="comment">// 当前帧显示时间戳与当前系统时钟时间的差值</span></span><br><span class="line">    <span class="keyword">double</span> pts_drift;     <span class="comment">/* clock base minus time at which we updated the clock */</span></span><br><span class="line">    <span class="comment">// 当前时钟(如视频时钟)最后一次更新时间，也可称当前时钟时间</span></span><br><span class="line">    <span class="keyword">double</span> last_updated;</span><br><span class="line">    <span class="comment">// 时钟速度控制，用于控制播放速度</span></span><br><span class="line">    <span class="keyword">double</span> speed;</span><br><span class="line">    <span class="comment">// 播放序列，所谓播放序列就是一段连续的播放动作，一个seek操作会启动一段新的播放序列</span></span><br><span class="line">    <span class="keyword">int</span> serial;           <span class="comment">/* clock is based on a packet with this serial */</span></span><br><span class="line">    <span class="comment">// 暂停标志</span></span><br><span class="line">    <span class="keyword">int</span> paused;</span><br><span class="line">    <span class="comment">// 指向packet_serial</span></span><br><span class="line">    <span class="keyword">int</span> *queue_serial;    <span class="comment">/* pointer to the current packet queue serial, used for obsolete clock detection */</span></span><br><span class="line">&#125; Clock;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Frame</span> &#123;</span><span class="comment">//帧</span></span><br><span class="line">    AVFrame*frame;         <span class="comment">// 指向数据帧</span></span><br><span class="line">    AVSubtitlesub;            <span class="comment">// 用于字幕</span></span><br><span class="line">    <span class="keyword">int</span>serial;             <span class="comment">// 帧序列，在seek的操作时serial会变化</span></span><br><span class="line">    <span class="keyword">double</span>pts;            <span class="comment">// 时间戳，单位为秒</span></span><br><span class="line">    <span class="keyword">double</span>duration;       <span class="comment">// 该帧持续时间，单位为秒</span></span><br><span class="line">    <span class="keyword">int64_t</span>pos;            <span class="comment">// 该帧在输入文件中的字节位置</span></span><br><span class="line">    <span class="keyword">int</span>width;              <span class="comment">// 图像宽度</span></span><br><span class="line">    <span class="keyword">int</span>height;             <span class="comment">// 图像高读</span></span><br><span class="line">    <span class="keyword">int</span>format;             <span class="comment">// 对于图像为(enum AVPixelFormat)，对于声音则为(enum AVSampleFormat)</span></span><br><span class="line">    AVRationalsar;            <span class="comment">// 图像的宽高比，如果未知或未指定则为0/1</span></span><br><span class="line">    <span class="keyword">int</span>uploaded;           <span class="comment">// 用来记录该帧是否已经显示过？</span></span><br><span class="line">    <span class="keyword">int</span>flip_v;             <span class="comment">// =1则旋转180， = 0则正常播放</span></span><br><span class="line">&#125; Frame;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Decoder</span> &#123;</span></span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    PacketQueue*<span class="built_in">queue</span>;         <span class="comment">// 数据包队列</span></span><br><span class="line">    AVCodecContext*avctx;     <span class="comment">// 解码器上下文</span></span><br><span class="line">    <span class="keyword">int</span>pkt_serial;         <span class="comment">// 包序列</span></span><br><span class="line">    <span class="keyword">int</span>finished;           <span class="comment">// 0即解码器处于工作状态</span></span><br><span class="line">    <span class="keyword">int</span>packet_pending;     <span class="comment">// 0即解码器处于异常状态，需要考虑重置解码器；1即解码器处于正常状态</span></span><br><span class="line">    SDL_cond*empty_queue_cond;  <span class="comment">// 检查到packet队列空时发送 signal缓存read_thread读取数据</span></span><br><span class="line">    <span class="keyword">int64_t</span>start_pts;          <span class="comment">// 初始化时是stream的start time</span></span><br><span class="line">    AVRationalstart_pts_tb;       <span class="comment">// 初始化时是stream的time_base</span></span><br><span class="line">    <span class="keyword">int64_t</span>next_pts;           <span class="comment">// 记录最近一次解码后的frame的pts，当解出来的部分帧没有有效的pts时则使用next_pts进行推算</span></span><br><span class="line">    AVRationalnext_pts_tb;        <span class="comment">// next_pts的单位</span></span><br><span class="line">    SDL_Thread*decoder_tid;       <span class="comment">// 线程句柄</span></span><br><span class="line">&#125; Decoder;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoState</span> &#123;</span></span><br><span class="line">    SDL_Thread *read_tid;           <span class="comment">// demux解复用线程</span></span><br><span class="line">    AVInputFormat *iformat;</span><br><span class="line">    <span class="keyword">int</span> abort_request;</span><br><span class="line">    <span class="keyword">int</span> force_refresh;</span><br><span class="line">    <span class="keyword">int</span> paused;</span><br><span class="line">    <span class="keyword">int</span> last_paused;</span><br><span class="line">    <span class="keyword">int</span> queue_attachments_req;</span><br><span class="line">    <span class="keyword">int</span> seek_req;                   <span class="comment">// 标识一次SEEK请求</span></span><br><span class="line">    <span class="keyword">int</span> seek_flags;                 <span class="comment">// SEEK标志，诸如AVSEEK_FLAG_BYTE等</span></span><br><span class="line">    <span class="keyword">int64_t</span> seek_pos;               <span class="comment">// SEEK的目标位置(当前位置+增量)</span></span><br><span class="line">    <span class="keyword">int64_t</span> seek_rel;               <span class="comment">// 本次SEEK的位置增量</span></span><br><span class="line">    <span class="keyword">int</span> read_pause_return;</span><br><span class="line">    AVFormatContext *ic;</span><br><span class="line">    <span class="keyword">int</span> realtime;</span><br><span class="line"></span><br><span class="line">    Clock audclk;                   <span class="comment">// 音频时钟</span></span><br><span class="line">    Clock vidclk;                   <span class="comment">// 视频时钟</span></span><br><span class="line">    Clock extclk;                   <span class="comment">// 外部时钟</span></span><br><span class="line"></span><br><span class="line">    FrameQueue pictq;               <span class="comment">// 视频frame队列</span></span><br><span class="line">    FrameQueue subpq;               <span class="comment">// 字幕frame队列</span></span><br><span class="line">    FrameQueue sampq;               <span class="comment">// 音频frame队列</span></span><br><span class="line"></span><br><span class="line">    Decoder auddec;                 <span class="comment">// 音频解码器</span></span><br><span class="line">    Decoder viddec;                 <span class="comment">// 视频解码器</span></span><br><span class="line">    Decoder subdec;                 <span class="comment">// 字幕解码器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> audio_stream;               <span class="comment">// 音频流索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> av_sync_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> audio_clock;             <span class="comment">// 每个音频帧更新一下此值，以pts形式表示</span></span><br><span class="line">    <span class="keyword">int</span> audio_clock_serial;         <span class="comment">// 播放序列，seek可改变此值</span></span><br><span class="line">    <span class="keyword">double</span> audio_diff_cum; <span class="comment">/* used for AV difference average computation */</span></span><br><span class="line">    <span class="keyword">double</span> audio_diff_avg_coef;</span><br><span class="line">    <span class="keyword">double</span> audio_diff_threshold;</span><br><span class="line">    <span class="keyword">int</span> audio_diff_avg_count;</span><br><span class="line">    AVStream *audio_st;             <span class="comment">// 音频流</span></span><br><span class="line">    PacketQueue audioq;             <span class="comment">// 音频packet队列</span></span><br><span class="line">    <span class="keyword">int</span> audio_hw_buf_size;          <span class="comment">// SDL音频缓冲区大小(单位字节)</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *audio_buf;             <span class="comment">// 指向待播放的一帧音频数据，指向的数据区将被拷入SDL音频缓冲区。若经过重采样则指向audio_buf1，否则指向frame中的音频</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *audio_buf1;            <span class="comment">// 音频重采样的输出缓冲区</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> audio_buf_size; <span class="comment">/* in bytes */</span> <span class="comment">// 待播放的一帧音频数据(audio_buf指向)的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> audio_buf1_size;   <span class="comment">// 申请到的音频缓冲区audio_buf1的实际尺寸</span></span><br><span class="line">    <span class="keyword">int</span> audio_buf_index; <span class="comment">/* in bytes */</span> <span class="comment">// 当前音频帧中已拷入SDL音频缓冲区的位置索引(指向第一个待拷贝字节)</span></span><br><span class="line">    <span class="keyword">int</span> audio_write_buf_size;       <span class="comment">// 当前音频帧中尚未拷入SDL音频缓冲区的数据量，audio_buf_size = audio_buf_index + audio_write_buf_size</span></span><br><span class="line">    <span class="keyword">int</span> audio_volume;               <span class="comment">// 音量</span></span><br><span class="line">    <span class="keyword">int</span> muted;                      <span class="comment">// 静音状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AudioParams</span> <span class="title">audio_src</span>;</span>   <span class="comment">// 音频frame的参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_AVFILTER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AudioParams</span> <span class="title">audio_filter_src</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AudioParams</span> <span class="title">audio_tgt</span>;</span>   <span class="comment">// SDL支持的音频参数，重采样转换：audio_src-&gt;audio_tgt</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">swr_ctx</span>;</span>     <span class="comment">// 音频重采样context</span></span><br><span class="line">    <span class="keyword">int</span> frame_drops_early;          <span class="comment">// 丢弃视频packet计数</span></span><br><span class="line">    <span class="keyword">int</span> frame_drops_late;           <span class="comment">// 丢弃视频frame计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> ShowMode &#123;</span><br><span class="line">        SHOW_MODE_NONE = <span class="number">-1</span>, SHOW_MODE_VIDEO = <span class="number">0</span>, SHOW_MODE_WAVES, SHOW_MODE_RDFT, SHOW_MODE_NB</span><br><span class="line">    &#125; show_mode;</span><br><span class="line">    <span class="keyword">int16_t</span> sample_array[SAMPLE_ARRAY_SIZE];</span><br><span class="line">    <span class="keyword">int</span> sample_array_index;</span><br><span class="line">    <span class="keyword">int</span> last_i_start;</span><br><span class="line">    RDFTContext *rdft;</span><br><span class="line">    <span class="keyword">int</span> rdft_bits;</span><br><span class="line">    FFTSample *rdft_data;</span><br><span class="line">    <span class="keyword">int</span> xpos;</span><br><span class="line">    <span class="keyword">double</span> last_vis_time;</span><br><span class="line">    SDL_Texture *vis_texture;</span><br><span class="line">    SDL_Texture *sub_texture;</span><br><span class="line">    SDL_Texture *vid_texture;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> subtitle_stream;                <span class="comment">// 字幕流索引</span></span><br><span class="line">    AVStream *subtitle_st;              <span class="comment">// 字幕流</span></span><br><span class="line">    PacketQueue subtitleq;              <span class="comment">// 字幕packet队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> frame_timer;                 <span class="comment">// 记录最后一帧播放的时刻</span></span><br><span class="line">    <span class="keyword">double</span> frame_last_returned_time;</span><br><span class="line">    <span class="keyword">double</span> frame_last_filter_delay;</span><br><span class="line">    <span class="keyword">int</span> video_stream;</span><br><span class="line">    AVStream *video_st;                 <span class="comment">// 视频流</span></span><br><span class="line">    PacketQueue videoq;                 <span class="comment">// 视频队列</span></span><br><span class="line">    <span class="keyword">double</span> max_frame_duration;      <span class="comment">// maximum duration of a frame - above this, we consider the jump a timestamp discontinuity</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">img_convert_ctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">sub_convert_ctx</span>;</span></span><br><span class="line">    <span class="keyword">int</span> eof;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *filename;</span><br><span class="line">    <span class="keyword">int</span> width, height, xleft, ytop;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_AVFILTER</span></span><br><span class="line">    <span class="keyword">int</span> vfilter_idx;</span><br><span class="line">    AVFilterContext *in_video_filter;   <span class="comment">// the first filter in the video chain</span></span><br><span class="line">    AVFilterContext *out_video_filter;  <span class="comment">// the last filter in the video chain</span></span><br><span class="line">    AVFilterContext *in_audio_filter;   <span class="comment">// the first filter in the audio chain</span></span><br><span class="line">    AVFilterContext *out_audio_filter;  <span class="comment">// the last filter in the audio chain</span></span><br><span class="line">    AVFilterGraph *agraph;              <span class="comment">// audio filter graph</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last_video_stream, last_audio_stream, last_subtitle_stream;</span><br><span class="line"></span><br><span class="line">    SDL_cond *continue_read_thread;</span><br><span class="line">&#125; VideoState;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">TextureFormatEntry</span> &#123;</span><span class="comment">//sdl音频输出有限 需要重采样</span></span><br><span class="line">    <span class="keyword">enum</span> AVPixelFormat format;</span><br><span class="line">    <span class="keyword">int</span> texture_fmt;</span><br><span class="line">&#125; sdl_texture_format_map[] = &#123;</span><br><span class="line">    &#123; AV_PIX_FMT_RGB8,           SDL_PIXELFORMAT_RGB332 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_RGB444,         SDL_PIXELFORMAT_RGB444 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_RGB555,         SDL_PIXELFORMAT_RGB555 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_BGR555,         SDL_PIXELFORMAT_BGR555 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_RGB565,         SDL_PIXELFORMAT_RGB565 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_BGR565,         SDL_PIXELFORMAT_BGR565 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_RGB24,          SDL_PIXELFORMAT_RGB24 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_BGR24,          SDL_PIXELFORMAT_BGR24 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_0RGB32,         SDL_PIXELFORMAT_RGB888 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_0BGR32,         SDL_PIXELFORMAT_BGR888 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_NE(RGB0, <span class="number">0B</span>GR), SDL_PIXELFORMAT_RGBX8888 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_NE(BGR0, <span class="number">0</span>RGB), SDL_PIXELFORMAT_BGRX8888 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_RGB32,          SDL_PIXELFORMAT_ARGB8888 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_RGB32_1,        SDL_PIXELFORMAT_RGBA8888 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_BGR32,          SDL_PIXELFORMAT_ABGR8888 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_BGR32_1,        SDL_PIXELFORMAT_BGRA8888 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_YUV420P,        SDL_PIXELFORMAT_IYUV &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_YUYV422,        SDL_PIXELFORMAT_YUY2 &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_UYVY422,        SDL_PIXELFORMAT_UYVY &#125;,</span><br><span class="line">    &#123; AV_PIX_FMT_NONE,           SDL_PIXELFORMAT_UNKNOWN &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;<span class="comment">//音视频同步方式枚举</span></span><br><span class="line">    AV_SYNC_AUDIO_MASTER,                   <span class="comment">// 以音频为基准</span></span><br><span class="line">    AV_SYNC_VIDEO_MASTER,                   <span class="comment">// 以视频为基准</span></span><br><span class="line">    AV_SYNC_EXTERNAL_CLOCK,                 <span class="comment">// 以外部时钟为基准，synchronize to an external clock */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">官方示例ffplay结构体</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>22.音视频同步参考</title>
    <link href="http://bugnull.com/2020/03/12/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/22-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E5%8F%82%E8%80%83/"/>
    <id>http://bugnull.com/2020/03/12/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/22-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E5%8F%82%E8%80%83/</id>
    <published>2020-03-12T15:58:14.000Z</published>
    <updated>2022-08-28T16:03:36.463Z</updated>
    
    <content type="html"><![CDATA[<p>出处见链接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//blog.csdn.net/myvest/article/details/97416415</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    video-&gt;frameq.deQueue(&amp;video-&gt;frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> current_pts = *(<span class="keyword">double</span> *)video-&gt;frame-&gt;opaque;<span class="comment">//当前帧的pts</span></span><br><span class="line">    <span class="keyword">double</span> delay = current_pts - video-&gt;frame_last_pts;<span class="comment">//相减之后 就是前帧默认的时间</span></span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delay = video-&gt;frame_last_delay;<span class="comment">//数据波动太大 特殊处理</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">double</span> ref_clock = audio-&gt;get_audio_clock();<span class="comment">//参考时间</span></span><br><span class="line">    <span class="keyword">double</span> diff = current_pts - ref_clock;<span class="comment">//应该播放时间-当前时间 = 偏差时间 diff &lt; 0 :video slow,diff &gt; 0 :video fast</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> sync_threshold = FFMAX(MIN_SYNC_THRESHOLD, FFMIN(MAX_SYNC_THRESHOLD, delay)) ;<span class="comment">//规定帧播放时间在一定范围内</span></span><br><span class="line">    </span><br><span class="line">    audio-&gt;audio_wait_video(current_pts,<span class="literal">false</span>);<span class="comment">//更新时钟</span></span><br><span class="line">    video-&gt;video_drop_frame(ref_clock,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; NOSYNC_THRESHOLD) <span class="comment">// 不同步</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt;= -sync_threshold)<span class="comment">//视频比音频慢，加快</span></span><br><span class="line">        &#123;</span><br><span class="line">            delay = FFMAX(<span class="number">0</span>,  delay + diff);<span class="comment">//表示直接覆盖上一帧</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> last_delay_zero_counts = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(video-&gt;frame_last_delay &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                last_delay_zero_counts++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last_delay_zero_counts = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(diff &lt; <span class="number">-1.0</span> &amp;&amp; last_delay_zero_counts &gt;= <span class="number">10</span>)<span class="comment">//连续缓慢 视频解码跟不上</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"maybe video codec too slow, adjust video&amp;audio\n"</span>);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">ifndef</span> DORP_PACK</span></span><br><span class="line">                audio-&gt;audio_wait_video(current_pts,<span class="literal">true</span>);<span class="comment">//差距较大，需要反馈音频等待视频</span></span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span>          </span></span><br><span class="line">                video-&gt;video_drop_frame(ref_clock,<span class="literal">true</span>);<span class="comment">//差距较大，需要视频丢帧追上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//视频比音频快，减慢</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold &amp;&amp; delay &gt; SYNC_FRAMEDUP_THRESHOLD)<span class="comment">//快了一帧以上  该帧与前帧相差了不少</span></span><br><span class="line">            delay = delay + diff;<span class="comment">//直接跳过去</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold)</span><br><span class="line">            delay = <span class="number">2</span> * delay;<span class="comment">//音视频差距较小，加倍延迟，逐渐缩小</span></span><br><span class="line">    &#125;</span><br><span class="line">    video-&gt;frame_last_delay = delay;<span class="comment">//该帧从current_pts播放了delay时长</span></span><br><span class="line">    video-&gt;frame_last_pts = current_pts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> curr_time = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(av_gettime()) / <span class="number">1000000.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(video-&gt;frame_timer == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        video-&gt;frame_timer = curr_time;<span class="comment">//第一次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> actual_delay = video-&gt;frame_timer + delay - curr_time;<span class="comment">//应该为curr_time-video-&gt;frame_timer + delay</span></span><br><span class="line">    <span class="keyword">if</span> (actual_delay &lt;= MIN_REFRSH_S)</span><br><span class="line">    &#123;</span><br><span class="line">        actual_delay = MIN_REFRSH_S;</span><br><span class="line">    &#125;</span><br><span class="line">    usleep(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(actual_delay * <span class="number">1000</span> * <span class="number">1000</span>));</span><br><span class="line">    <span class="comment">//printf("actual_delay[%lf] delay[%lf] diff[%lf]\n",actual_delay,delay,diff);</span></span><br><span class="line">    <span class="comment">// Display</span></span><br><span class="line">    SDL_UpdateTexture(video-&gt;texture, &amp;(video-&gt;rect), video-&gt;frame-&gt;data[<span class="number">0</span>], video-&gt;frame-&gt;linesize[<span class="number">0</span>]);</span><br><span class="line">    SDL_RenderClear(video-&gt;renderer);</span><br><span class="line">    SDL_RenderCopy(video-&gt;renderer, video-&gt;texture, &amp;video-&gt;rect, &amp;video-&gt;rect);</span><br><span class="line">    SDL_RenderPresent(video-&gt;renderer);</span><br><span class="line">    video-&gt;frame_timer = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(av_gettime()) / <span class="number">1000000.0</span> ;<span class="comment">//刷新一帧显示时间</span></span><br><span class="line">    </span><br><span class="line">    av_frame_unref(video-&gt;frame);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//update next frame</span></span><br><span class="line">    schedule_refresh(media, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">音视频同步方案</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>21.官方示例H264的QSV加速简析</title>
    <link href="http://bugnull.com/2020/01/03/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/21-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8BH264%E7%9A%84QSV%E5%8A%A0%E9%80%9F%E7%AE%80%E6%9E%90/"/>
    <id>http://bugnull.com/2020/01/03/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/21-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8BH264%E7%9A%84QSV%E5%8A%A0%E9%80%9F%E7%AE%80%E6%9E%90/</id>
    <published>2020-01-03T15:09:12.000Z</published>
    <updated>2022-08-28T16:03:40.447Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file</span></span><br><span class="line"><span class="comment"> * Intel QSV-accelerated H.264 decoding example.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @example qsvdec.c</span></span><br><span class="line"><span class="comment"> * This example shows how to do QSV-accelerated H.264 decoding with output</span></span><br><span class="line"><span class="comment"> * frames in the GPU video surfaces.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">官方示例H264的QSV加速简析</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>20.官方示例解复用和复用简析</title>
    <link href="http://bugnull.com/2020/01/03/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/20-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%8D%E7%94%A8%E7%AE%80%E6%9E%90/"/>
    <id>http://bugnull.com/2020/01/03/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/20-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%92%8C%E5%A4%8D%E7%94%A8%E7%AE%80%E6%9E%90/</id>
    <published>2020-01-03T07:10:30.000Z</published>
    <updated>2022-08-28T16:03:44.947Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file</span></span><br><span class="line"><span class="comment"> * libavformat/libavcodec demuxing and muxing API example.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Remux streams from one container format to another.</span></span><br><span class="line"><span class="comment"> * @example remuxing.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">avformat_open_input();<span class="comment">//打开输入流和读取文件头 ifmtCtx</span></span><br><span class="line">avformat_find_stream_info();<span class="comment">//获取文件流信息</span></span><br><span class="line">av_dump_format();<span class="comment">//输出format信息</span></span><br><span class="line">avformat_alloc_output_context2();<span class="comment">//分配一个输出封装上下文ofmtCtx</span></span><br><span class="line">av_mallocz_array();<span class="comment">//分配一个内存数组</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;<span class="comment">//创建ofmtCtx里面的流</span></span><br><span class="line">avformat_new_stream();<span class="comment">//分配个新的流到封装上下文ofmtCtx 并创建一个oStream</span></span><br><span class="line">    avcodec_parameters_copy();<span class="comment">//编码器参数拷贝</span></span><br><span class="line">    oStream-&gt;codecpar-&gt;codec_tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">av_dump_format();</span><br><span class="line"><span class="keyword">if</span> (!(ofmtCtx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)) &#123;<span class="comment">//输出格式 不应该有文件被打开</span></span><br><span class="line">ret = avio_open(&amp;ofmtCtx-&gt;pb, out_filename, AVIO_FLAG_WRITE);<span class="comment">//创建初始化AVIOContext</span></span><br><span class="line">&#125;</span><br><span class="line">avformat_write_header();<span class="comment">//给ofmtCtx定入头信息</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    av_read_frame();<span class="comment">//从ifmtCtx读取一个Pkt</span></span><br><span class="line">    </span><br><span class="line">    pkt.stream_index = stream_mapping[pkt.stream_index];</span><br><span class="line">pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);</span><br><span class="line">pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);</span><br><span class="line">pkt.duration = av_rescale_q(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">pkt.pos = <span class="number">-1</span>;</span><br><span class="line">    log_packet();<span class="comment">//输出包信息</span></span><br><span class="line">    av_interleaved_write_frame();<span class="comment">//写Pkt到ofmtCtx 内部会缓存 以保证按照dtx排序</span></span><br><span class="line">    av_packet_unref();<span class="comment">//释放pkt</span></span><br><span class="line">&#125;</span><br><span class="line">av_write_trailer();<span class="comment">//将流末尾写入ofmtCtx并释放文件私有数据</span></span><br><span class="line"></span><br><span class="line">avformat_close_input(&amp;ifmtCtx);<span class="comment">//avformat_open_input</span></span><br><span class="line"><span class="keyword">if</span> (ofmtCtx &amp;&amp; !(ofmtCtx-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">avio_closep(&amp;ofmtCtx-&gt;pb);</span><br><span class="line">avformat_free_context(ofmtCtx);<span class="comment">//avformat_new_stream</span></span><br><span class="line">av_freep();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @file</span></span><br><span class="line"><span class="comment">* libavformat API example.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Output a media file in any supported libavformat format. The default</span></span><br><span class="line"><span class="comment">* codecs are used.</span></span><br><span class="line"><span class="comment">* @example muxing.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">avformat_alloc_output_context2(&amp;oc, <span class="literal">NULL</span>, <span class="literal">NULL</span>, filename);<span class="comment">//分配输出上下文</span></span><br><span class="line"><span class="keyword">if</span> (!oc) &#123;</span><br><span class="line">avformat_alloc_output_context2(&amp;oc, <span class="literal">NULL</span>, <span class="string">"mpeg"</span>, filename);<span class="comment">//尝试打开MPEG</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>（oc-&gt;oformat-&gt;video_codec!= AV_CODEC_ID_NONE）&#123;</span><br><span class="line">    add_stream(&amp;video_st, oc, &amp;video_codec, fmt-&gt;video_codec);</span><br><span class="line">    open_video(oc, video_codec, &amp;video_st, opt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fmt-&gt;audio_codec != AV_CODEC_ID_NONE) &#123;</span><br><span class="line">add_stream(&amp;audio_st, oc, &amp;audio_codec, fmt-&gt;audio_codec);</span><br><span class="line">    open_audio(oc, audio_codec, &amp;audio_st, opt);</span><br><span class="line">&#125;</span><br><span class="line">av_dump_format();<span class="comment">//输出信息</span></span><br><span class="line"><span class="keyword">if</span> (!(fmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;<span class="comment">//需要打开文件</span></span><br><span class="line"> avio_open(&amp;oc-&gt;pb, filename, AVIO_FLAG_WRITE);</span><br><span class="line">&#125;</span><br><span class="line">avformat_write_header();<span class="comment">//写入流头信息</span></span><br><span class="line"><span class="keyword">while</span> (encode_video || encode_audio) &#123;</span><br><span class="line"><span class="keyword">if</span> (encode_video &amp;&amp; (!encode_audio || av_compare_ts(video_st.next_pts, video_st.enc-&gt;time_base,audio_st.next_pts, audio_st.enc-&gt;time_base) &lt;= <span class="number">0</span>)) &#123;<span class="comment">//比较两个时间戳</span></span><br><span class="line">encode_video = !write_video_frame(oc, &amp;video_st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">encode_audio = !write_audio_frame(oc, &amp;audio_st);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">av_write_trailer();</span><br><span class="line"><span class="keyword">if</span> (!(fmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">avio_closep(&amp;oc-&gt;pb);</span><br><span class="line">avformat_free_context(oc);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log_packet</span><span class="params">(<span class="keyword">const</span> AVFormatContext *fmt_ctx, <span class="keyword">const</span> AVPacket *pkt, <span class="keyword">const</span> <span class="keyword">char</span> *tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVRational *time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s: pts:%s pts_time:%s dts:%s dts_time:%s duration:%s duration_time:%s stream_index:%d\n"</span>,</span><br><span class="line">tag,</span><br><span class="line">av_ts2str(pkt-&gt;pts), av_ts2timestr(pkt-&gt;pts, time_base),</span><br><span class="line">av_ts2str(pkt-&gt;dts), av_ts2timestr(pkt-&gt;dts, time_base),</span><br><span class="line">av_ts2str(pkt-&gt;duration), av_ts2timestr(pkt-&gt;duration, time_base),</span><br><span class="line">pkt-&gt;stream_index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_frame</span><span class="params">(AVFormatContext *fmt_ctx, <span class="keyword">const</span> AVRational *time_base, AVStream *st, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">av_packet_rescale_ts(pkt, *time_base, st-&gt;time_base);<span class="comment">//修改时间戳</span></span><br><span class="line">pkt-&gt;stream_index = st-&gt;index;</span><br><span class="line">log_packet(fmt_ctx, pkt);</span><br><span class="line"><span class="keyword">return</span> av_interleaved_write_frame(fmt_ctx, pkt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close_stream</span><span class="params">(AVFormatContext *oc, OutputStream *ost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">avcodec_free_context(&amp;ost-&gt;enc);</span><br><span class="line">av_frame_free(&amp;ost-&gt;frame);</span><br><span class="line">av_frame_free(&amp;ost-&gt;tmp_frame);</span><br><span class="line">sws_freeContext(ost-&gt;sws_ctx);</span><br><span class="line">swr_free(&amp;ost-&gt;swr_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OutputStream</span> &#123;</span></span><br><span class="line">AVStream *st;</span><br><span class="line">AVCodecContext *enc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> next_pts;<span class="comment">//生成时下一帧的pts</span></span><br><span class="line"><span class="keyword">int</span> samples_count;</span><br><span class="line"></span><br><span class="line">AVFrame *frame;</span><br><span class="line">AVFrame *tmp_frame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> t, tincr, tincr2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SwsContext</span> *<span class="title">sws_ctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">swr_ctx</span>;</span></span><br><span class="line">&#125; OutputStream;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_stream</span><span class="params">(OutputStream *ost, AVFormatContext *oc,AVCodec **codec,<span class="keyword">enum</span> AVCodecID codec_id)</span><span class="comment">//根据AVCodecID添加一个输出流</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVCodecContext *c;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">*codec = avcodec_find_encoder(codec_id);<span class="comment">//根据id查找一个编码器</span></span><br><span class="line"><span class="keyword">if</span> (!(*codec)) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not find encoder for '%s'\n"</span>,avcodec_get_name(codec_id));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ost-&gt;st = avformat_new_stream(oc, <span class="literal">NULL</span>);<span class="comment">//为oc分配一个流</span></span><br><span class="line"><span class="keyword">if</span> (!ost-&gt;st) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ost-&gt;st-&gt;id = oc-&gt;nb_streams - <span class="number">1</span>;</span><br><span class="line">c = avcodec_alloc_context3(*codec);<span class="comment">//分配和初始化c</span></span><br><span class="line"><span class="keyword">if</span> (!c) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ost-&gt;enc = c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ((*codec)-&gt;type) &#123;</span><br><span class="line"><span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">c-&gt;sample_fmt = (*codec)-&gt;sample_fmts ?(*codec)-&gt;sample_fmts[<span class="number">0</span>] : AV_SAMPLE_FMT_FLTP;</span><br><span class="line">c-&gt;bit_rate = <span class="number">64000</span>;</span><br><span class="line">c-&gt;sample_rate = <span class="number">44100</span>;<span class="comment">//采样率</span></span><br><span class="line"><span class="keyword">if</span> ((*codec)-&gt;supported_samplerates) &#123;</span><br><span class="line">c-&gt;sample_rate = (*codec)-&gt;supported_samplerates[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; (*codec)-&gt;supported_samplerates[i]; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*codec)-&gt;supported_samplerates[i] == <span class="number">44100</span>)</span><br><span class="line">c-&gt;sample_rate = <span class="number">44100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c-&gt;channels = av_get_channel_layout_nb_channels(c-&gt;channel_layout);<span class="comment">//获取通道数</span></span><br><span class="line">c-&gt;channel_layout = AV_CH_LAYOUT_STEREO;<span class="comment">//左右声道</span></span><br><span class="line"><span class="keyword">if</span> ((*codec)-&gt;channel_layouts) &#123;</span><br><span class="line">c-&gt;channel_layout = (*codec)-&gt;channel_layouts[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; (*codec)-&gt;channel_layouts[i]; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*codec)-&gt;channel_layouts[i] == AV_CH_LAYOUT_STEREO)</span><br><span class="line">c-&gt;channel_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c-&gt;channels = av_get_channel_layout_nb_channels(c-&gt;channel_layout);</span><br><span class="line">ost-&gt;st-&gt;time_base = (AVRational) &#123; <span class="number">1</span>, c-&gt;sample_rate &#125;;<span class="comment">//时基</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">c-&gt;codec_id = codec_id;</span><br><span class="line"></span><br><span class="line">c-&gt;bit_rate = <span class="number">400000</span>;</span><br><span class="line">c-&gt;width = <span class="number">352</span>;</span><br><span class="line">c-&gt;height = <span class="number">288</span>;</span><br><span class="line">ost-&gt;st-&gt;time_base = (AVRational) &#123; <span class="number">1</span>, <span class="number">25</span> &#125;;</span><br><span class="line">c-&gt;time_base = ost-&gt;st-&gt;time_base;</span><br><span class="line"></span><br><span class="line">c-&gt;gop_size = <span class="number">12</span>;<span class="comment">//每12帧一个帧</span></span><br><span class="line">c-&gt;pix_fmt = AV_PIX_FMT_YUV420P;</span><br><span class="line"><span class="keyword">if</span> (c-&gt;codec_id == AV_CODEC_ID_MPEG2VIDEO) &#123;</span><br><span class="line">c-&gt;max_b_frames = <span class="number">2</span>;<span class="comment">//b帧数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c-&gt;codec_id == AV_CODEC_ID_MPEG1VIDEO) &#123;</span><br><span class="line">c-&gt;mb_decision = <span class="number">2</span>;<span class="comment">//FF_MB_DECISION_RD 2///失帧率</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (oc-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)<span class="comment">//上下文需要全局头</span></span><br><span class="line">c-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open_video</span><span class="params">(AVFormatContext *oc, AVCodec *codec, OutputStream *ost, AVDictionary *opt_arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">AVCodecContext *c = ost-&gt;enc;</span><br><span class="line">AVDictionary *opt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">av_dict_copy(&amp;opt, opt_arg, <span class="number">0</span>);<span class="comment">//复制</span></span><br><span class="line">ret = avcodec_open2(c, codec, &amp;opt);<span class="comment">//根据codec初始化c</span></span><br><span class="line">av_dict_free(&amp;opt);<span class="comment">//释放</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ost-&gt;frame = alloc_picture(c-&gt;pix_fmt, c-&gt;width, c-&gt;height);<span class="comment">//分配大小</span></span><br><span class="line"><span class="keyword">if</span> (!ost-&gt;frame) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ost-&gt;tmp_frame = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (c-&gt;pix_fmt != AV_PIX_FMT_YUV420P) &#123;<span class="comment">//多存一个yuv420p用于转换</span></span><br><span class="line">ost-&gt;tmp_frame = alloc_picture(AV_PIX_FMT_YUV420P, c-&gt;width, c-&gt;height);</span><br><span class="line"><span class="keyword">if</span> (!ost-&gt;tmp_frame) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = avcodec_parameters_from_context(ost-&gt;st-&gt;codecpar, c);<span class="comment">//复制流参数到复用器</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> AVFrame *<span class="title">alloc_picture</span><span class="params">(<span class="keyword">enum</span> AVPixelFormat pix_fmt, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVFrame *picture;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">picture = av_frame_alloc();</span><br><span class="line"><span class="keyword">if</span> (!picture)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">picture-&gt;format = pix_fmt;</span><br><span class="line">picture-&gt;width = width;</span><br><span class="line">picture-&gt;height = height;</span><br><span class="line">ret = av_frame_get_buffer(picture, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open_audio</span><span class="params">(AVFormatContext *oc, AVCodec *codec, OutputStream *ost, AVDictionary *opt_arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVCodecContext *c;</span><br><span class="line"><span class="keyword">int</span> nb_samples;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">AVDictionary *opt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">c = ost-&gt;enc;</span><br><span class="line">av_dict_copy(&amp;opt, opt_arg, <span class="number">0</span>);</span><br><span class="line">ret = avcodec_open2(c, codec, &amp;opt);</span><br><span class="line">av_dict_free(&amp;opt);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ost-&gt;t = <span class="number">0</span>;</span><br><span class="line">ost-&gt;tincr = <span class="number">2</span> * M_PI * <span class="number">110.0</span> / c-&gt;sample_rate;<span class="comment">//每秒增长110HZ</span></span><br><span class="line">ost-&gt;tincr2 = <span class="number">2</span> * M_PI * <span class="number">110.0</span> / c-&gt;sample_rate / c-&gt;sample_rate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_VARIABLE_FRAME_SIZE)<span class="comment">//编码器是否支持每次不同数量的样本</span></span><br><span class="line">nb_samples = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nb_samples = c-&gt;frame_size;</span><br><span class="line"></span><br><span class="line">ost-&gt;frame = alloc_audio_frame(c-&gt;sample_fmt, c-&gt;channel_layout,</span><br><span class="line">c-&gt;sample_rate, nb_samples);</span><br><span class="line">ost-&gt;tmp_frame = alloc_audio_frame(AV_SAMPLE_FMT_S16, c-&gt;channel_layout,</span><br><span class="line">c-&gt;sample_rate, nb_samples);</span><br><span class="line"></span><br><span class="line">ret = avcodec_parameters_from_context(ost-&gt;st-&gt;codecpar, c);<span class="comment">//根据codec填充par</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;ost-&gt;swr_ctx = swr_alloc();</span><br><span class="line"><span class="keyword">if</span> (!ost-&gt;swr_ctx) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">av_opt_set_int(ost-&gt;swr_ctx, <span class="string">"in_channel_count"</span>, c-&gt;channels, <span class="number">0</span>);</span><br><span class="line">av_opt_set_int(ost-&gt;swr_ctx, <span class="string">"in_sample_rate"</span>, c-&gt;sample_rate, <span class="number">0</span>);</span><br><span class="line">av_opt_set_sample_fmt(ost-&gt;swr_ctx, <span class="string">"in_sample_fmt"</span>, AV_SAMPLE_FMT_S16, <span class="number">0</span>);</span><br><span class="line">av_opt_set_int(ost-&gt;swr_ctx, <span class="string">"out_channel_count"</span>, c-&gt;channels, <span class="number">0</span>);</span><br><span class="line">av_opt_set_int(ost-&gt;swr_ctx, <span class="string">"out_sample_rate"</span>, c-&gt;sample_rate, <span class="number">0</span>);</span><br><span class="line">av_opt_set_sample_fmt(ost-&gt;swr_ctx, <span class="string">"out_sample_fmt"</span>, c-&gt;sample_fmt, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ret = swr_init(ost-&gt;swr_ctx)) &lt; <span class="number">0</span>) &#123;<span class="comment">//根据设置初始化上下文</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> AVFrame *<span class="title">alloc_audio_frame</span><span class="params">(<span class="keyword">enum</span> AVSampleFormat sample_fmt,<span class="keyword">uint64_t</span> channel_layout, <span class="keyword">int</span> sample_rate, <span class="keyword">int</span> nb_samples)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVFrame *frame = av_frame_alloc();</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">if</span> (!frame) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">frame-&gt;format = sample_fmt;</span><br><span class="line">frame-&gt;channel_layout = channel_layout;</span><br><span class="line">frame-&gt;sample_rate = sample_rate;</span><br><span class="line">frame-&gt;nb_samples = nb_samples;</span><br><span class="line"><span class="keyword">if</span> (nb_samples) &#123;</span><br><span class="line">ret = av_frame_get_buffer(frame, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_video_frame</span><span class="params">(AVFormatContext *oc, OutputStream *ost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">AVCodecContext *c;</span><br><span class="line">AVFrame *frame;</span><br><span class="line"><span class="keyword">int</span> got_packet = <span class="number">0</span>;</span><br><span class="line">AVPacket pkt = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">c = ost-&gt;enc;</span><br><span class="line">frame = get_video_frame(ost);</span><br><span class="line">av_init_packet(&amp;pkt);<span class="comment">//初始化pkt</span></span><br><span class="line">ret = avcodec_encode_video2(c, &amp;pkt, frame, &amp;got_packet);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (got_packet) &#123;</span><br><span class="line">ret = write_frame(oc, &amp;c-&gt;time_base, ost-&gt;st, &amp;pkt);<span class="comment">//写帧到oc</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (frame || got_packet) ? <span class="number">0</span> : <span class="number">1</span>;<span class="comment">//1表示结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> AVFrame *<span class="title">get_video_frame</span><span class="params">(OutputStream *ost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVCodecContext *c = ost-&gt;enc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av_compare_ts(ost-&gt;next_pts, c-&gt;time_base,STREAM_DURATION, (AVRational) &#123; <span class="number">1</span>, <span class="number">1</span> &#125;) &gt;= <span class="number">0</span>)<span class="comment">//需要生成更多的帧</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (av_frame_make_writable(ost-&gt;frame) &lt; <span class="number">0</span>)<span class="comment">//确保帧可写</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (c-&gt;pix_fmt != AV_PIX_FMT_YUV420P) &#123;<span class="comment">//如果不是YUV420P进行转换</span></span><br><span class="line"><span class="keyword">if</span> (!ost-&gt;sws_ctx) &#123;<span class="comment">//重采样上下文</span></span><br><span class="line">ost-&gt;sws_ctx = sws_getContext(c-&gt;width, c-&gt;height,</span><br><span class="line">AV_PIX_FMT_YUV420P,</span><br><span class="line">c-&gt;width, c-&gt;height,</span><br><span class="line">c-&gt;pix_fmt,</span><br><span class="line">SCALE_FLAGS, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!ost-&gt;sws_ctx) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fill_yuv_image(ost-&gt;tmp_frame, ost-&gt;next_pts, c-&gt;width, c-&gt;height);</span><br><span class="line">sws_scale(ost-&gt;sws_ctx, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> * <span class="keyword">const</span> *)ost-&gt;tmp_frame-&gt;data,</span><br><span class="line">ost-&gt;tmp_frame-&gt;linesize, <span class="number">0</span>, c-&gt;height, ost-&gt;frame-&gt;data,</span><br><span class="line">ost-&gt;frame-&gt;linesize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">fill_yuv_image(ost-&gt;frame, ost-&gt;next_pts, c-&gt;width, c-&gt;height);</span><br><span class="line">&#125;</span><br><span class="line">ost-&gt;frame-&gt;pts = ost-&gt;next_pts++;</span><br><span class="line"><span class="keyword">return</span> ost-&gt;frame;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill_yuv_image</span><span class="params">(AVFrame *pict, <span class="keyword">int</span> frame_index,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><span class="comment">//生成一个frame</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y, i;</span><br><span class="line">i = frame_index;</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; height; y++)</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">pict-&gt;data[<span class="number">0</span>][y * pict-&gt;linesize[<span class="number">0</span>] + x] = x + y + i * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; height / <span class="number">2</span>; y++) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; width / <span class="number">2</span>; x++) &#123;</span><br><span class="line">pict-&gt;data[<span class="number">1</span>][y * pict-&gt;linesize[<span class="number">1</span>] + x] = <span class="number">128</span> + y + i * <span class="number">2</span>;</span><br><span class="line">pict-&gt;data[<span class="number">2</span>][y * pict-&gt;linesize[<span class="number">2</span>] + x] = <span class="number">64</span> + x + i * <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_audio_frame</span><span class="params">(AVFormatContext *oc, OutputStream *ost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVCodecContext *c;</span><br><span class="line">AVPacket pkt = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">AVFrame *frame;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> got_packet;</span><br><span class="line"><span class="keyword">int</span> dst_nb_samples;</span><br><span class="line"></span><br><span class="line">av_init_packet(&amp;pkt);</span><br><span class="line">c = ost-&gt;enc;</span><br><span class="line">frame = get_audio_frame(ost);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (frame) &#123;</span><br><span class="line">dst_nb_samples = av_rescale_rnd(swr_get_delay(ost-&gt;swr_ctx, c-&gt;sample_rate) + frame-&gt;nb_samples,c-&gt;sample_rate, c-&gt;sample_rate, AV_ROUND_UP);</span><br><span class="line">av_assert0(dst_nb_samples == frame-&gt;nb_samples);<span class="comment">//检查样本是否丢失</span></span><br><span class="line"></span><br><span class="line">ret = av_frame_make_writable(ost-&gt;frame);<span class="comment">//确保帧是可写的</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">ret = swr_convert(ost-&gt;swr_ctx,</span><br><span class="line">ost-&gt;frame-&gt;data, dst_nb_samples,</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> **)frame-&gt;data, frame-&gt;nb_samples);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">frame = ost-&gt;frame;</span><br><span class="line">frame-&gt;pts = av_rescale_q(ost-&gt;samples_count, (AVRational) &#123; <span class="number">1</span>, c-&gt;sample_rate &#125;, c-&gt;time_base);</span><br><span class="line">ost-&gt;samples_count += dst_nb_samples;</span><br><span class="line">&#125;</span><br><span class="line">ret = avcodec_encode_audio2(c, &amp;pkt, frame, &amp;got_packet);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (got_packet) &#123;</span><br><span class="line">ret = write_frame(oc, &amp;c-&gt;time_base, ost-&gt;st, &amp;pkt);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (frame || got_packet) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> AVFrame *<span class="title">get_audio_frame</span><span class="params">(OutputStream *ost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AVFrame *frame = ost-&gt;tmp_frame;</span><br><span class="line"><span class="keyword">int</span> j, i, v;</span><br><span class="line"><span class="keyword">int16_t</span> *q = (<span class="keyword">int16_t</span>*)frame-&gt;data[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av_compare_ts(ost-&gt;next_pts, ost-&gt;enc-&gt;time_base,</span><br><span class="line">STREAM_DURATION, (AVRational) &#123; <span class="number">1</span>, <span class="number">1</span> &#125;) &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;frame-&gt;nb_samples; j++) &#123;</span><br><span class="line">v = (<span class="keyword">int</span>)(<span class="built_in">sin</span>(ost-&gt;t) * <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ost-&gt;enc-&gt;channels; i++)</span><br><span class="line">*q++ = v;</span><br><span class="line">ost-&gt;t += ost-&gt;tincr;</span><br><span class="line">ost-&gt;tincr += ost-&gt;tincr2;</span><br><span class="line">&#125;</span><br><span class="line">frame-&gt;pts = ost-&gt;next_pts;</span><br><span class="line">ost-&gt;next_pts += frame-&gt;nb_samples;</span><br><span class="line"><span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">官方示例解复用和复用简析</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>19.官方示例硬件解码简析</title>
    <link href="http://bugnull.com/2019/12/30/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/19-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E7%A1%AC%E4%BB%B6%E8%A7%A3%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    <id>http://bugnull.com/2019/12/30/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/19-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E7%A1%AC%E4%BB%B6%E8%A7%A3%E7%A0%81%E7%AE%80%E6%9E%90/</id>
    <published>2019-12-30T06:54:39.000Z</published>
    <updated>2022-08-28T16:03:51.256Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @file</span></span><br><span class="line"><span class="comment">* HW-Accelerated decoding example.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @example hw_decode.c</span></span><br><span class="line"><span class="comment">* This example shows how to do HW-accelerated decoding with output</span></span><br><span class="line"><span class="comment">* frames from the HW video surfaces.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">av_hwdevice_find_type_by_name();<span class="comment">//根据字符串找驱动</span></span><br><span class="line"><span class="comment">/*列举所有驱动字符串</span></span><br><span class="line"><span class="comment">while ((type = av_hwdevice_iterate_types(type)) != AV_HWDEVICE_TYPE_NONE)</span></span><br><span class="line"><span class="comment">fprintf(stderr, " %s", av_hwdevice_get_type_name(type));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">avformat_open_input();<span class="comment">//打开封装上下文</span></span><br><span class="line">avformat_find_stream_info();<span class="comment">//查找流信息</span></span><br><span class="line">av_find_best_stream();<span class="comment">//查找匹配的流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> AVCodecHWConfig *config = avcodec_get_hw_config(decoder, i);<span class="comment">//根据decoder检索出config</span></span><br><span class="line"><span class="keyword">if</span> (!config) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Decoder %s does not support device type %s.\n"</span>,</span><br><span class="line">decoder-&gt;name, av_hwdevice_get_type_name(type));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (config-&gt;methods &amp; AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &amp;&amp;</span><br><span class="line">config-&gt;device_type == type) &#123;</span><br><span class="line">hw_pix_fmt = config-&gt;pix_fmt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">avcodec_alloc_context3();<span class="comment">//分配并初始化codecCtx</span></span><br><span class="line">avcodec_parameters_to_context();<span class="comment">//根据par填充codecCtx</span></span><br><span class="line">codecCtx-&gt;get_format = get_hw_format;<span class="comment">//提供回调</span></span><br><span class="line"></span><br><span class="line">av_hwdevice_ctx_create();<span class="comment">//创建驱动上下文</span></span><br><span class="line">codecCtx-&gt;hw_device_ctx = av_buffer_ref(deviceCtx);<span class="comment">//创建一个新的引用</span></span><br><span class="line"></span><br><span class="line">avcodec_open2();<span class="comment">//根据codec创建codecCtx</span></span><br><span class="line"><span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((ret = av_read_frame(input_ctx, &amp;packet)) &lt; <span class="number">0</span>)<span class="comment">//读包</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (video_stream == packet.stream_index)</span><br><span class="line">ret = decode_write(decoder_ctx, &amp;packet);<span class="comment">//解</span></span><br><span class="line">av_packet_unref(&amp;packet);<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br><span class="line">packet.data = <span class="literal">NULL</span>;</span><br><span class="line">packet.size = <span class="number">0</span>;</span><br><span class="line">ret = decode_write(decoder_ctx, &amp;packet);</span><br><span class="line">av_packet_unref(&amp;packet);</span><br><span class="line"></span><br><span class="line">avcodec_free_context();</span><br><span class="line">avformat_close_input();</span><br><span class="line">av_buffer_unref();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> AVPixelFormat <span class="title">get_hw_format</span><span class="params">(AVCodecContext *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">enum</span> AVPixelFormat *pix_fmts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> AVPixelFormat *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p = pix_fmts; *p != <span class="number">-1</span>; p++) &#123;</span><br><span class="line"><span class="keyword">if</span> (*p == hw_pix_fmt)</span><br><span class="line"><span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to get HW surface format.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> AV_PIX_FMT_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">decode_write</span><span class="params">(AVCodecContext *avctx, AVPacket *packet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ret = avcodec_send_packet(avctx, packet);<span class="comment">//发送到解码器</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(frame = av_frame_alloc()) || !(sw_frame = av_frame_alloc())) &#123;</span><br><span class="line">ret = AVERROR(ENOMEM);</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">ret = avcodec_receive_frame(avctx, frame);<span class="comment">//从解码器中读frame</span></span><br><span class="line"><span class="keyword">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) &#123;</span><br><span class="line">av_frame_free(&amp;frame);</span><br><span class="line">av_frame_free(&amp;sw_frame);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (frame-&gt;format == hw_pix_fmt) &#123;</span><br><span class="line"><span class="keyword">if</span> ((ret = av_hwframe_transfer_data(sw_frame, frame, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;<span class="comment">//从gpu读到cpu</span></span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">tmp_frame = sw_frame;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp_frame = frame;</span><br><span class="line">size = av_image_get_buffer_size(tmp_frame-&gt;format, tmp_frame-&gt;width,</span><br><span class="line">tmp_frame-&gt;height, <span class="number">1</span>);<span class="comment">//求数据大小</span></span><br><span class="line">buffer = av_malloc(size);<span class="comment">//申请空间</span></span><br><span class="line"><span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">ret = AVERROR(ENOMEM);</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">ret = av_image_copy_to_buffer(buffer, size,</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> * <span class="keyword">const</span> *)tmp_frame-&gt;data,</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">int</span> *)tmp_frame-&gt;linesize, tmp_frame-&gt;format,</span><br><span class="line">tmp_frame-&gt;width, tmp_frame-&gt;height, <span class="number">1</span>);<span class="comment">//将frame数据复制到buffer</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((ret = fwrite(buffer, <span class="number">1</span>, size, output_file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">fail:</span><br><span class="line">av_frame_free(&amp;frame);</span><br><span class="line">av_frame_free(&amp;sw_frame);</span><br><span class="line">av_freep(&amp;buffer);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">官方示例硬件解码简析</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>18.官方示例HTTP多连接发送文件简析</title>
    <link href="http://bugnull.com/2019/12/29/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/18-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8BHTTP%E5%A4%9A%E8%BF%9E%E6%8E%A5%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E7%AE%80%E6%9E%90/"/>
    <id>http://bugnull.com/2019/12/29/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/18-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8BHTTP%E5%A4%9A%E8%BF%9E%E6%8E%A5%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E7%AE%80%E6%9E%90/</id>
    <published>2019-12-29T09:13:12.000Z</published>
    <updated>2022-08-28T16:03:55.096Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @file</span></span><br><span class="line"><span class="comment">* libavformat multi-client network API usage example.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @example http_multiclient.c</span></span><br><span class="line"><span class="comment">* This example will serve a file without decoding or demuxing it over http.</span></span><br><span class="line"><span class="comment">* Multiple clients can connect and will receive the same file.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//out_url是服务器  in_url是文件</span></span><br><span class="line">av_format_network_init();<span class="comment">//初始化网络库 只在线程安全时或者GnuTLS或者OpenSSL</span></span><br><span class="line">av_dict_set();<span class="comment">//设置AVDictionary</span></span><br><span class="line">avio_open2();<span class="comment">//打开io上下文</span></span><br><span class="line">avio_accept();<span class="comment">//从s服务端读取上下文到c</span></span><br><span class="line">fork();<span class="comment">//分成两个同样的进程 父进程pid为正数 子进程pid为0</span></span><br><span class="line"><span class="comment">//pid==0 </span></span><br><span class="line"><span class="comment">//process_client();单独进程</span></span><br><span class="line"><span class="comment">//avio_close();关闭s上下文</span></span><br><span class="line"><span class="comment">//pid&gt;0</span></span><br><span class="line"><span class="comment">//avio_close();关闭c上下文</span></span><br><span class="line"></span><br><span class="line">avio_close();<span class="comment">//s</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_client</span><span class="params">(AVIOContext *client, <span class="keyword">const</span> <span class="keyword">char</span> *in_uri)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((ret = avio_handshake(client)) &gt; <span class="number">0</span>) &#123;<span class="comment">//通过握手协议获取一个新连接</span></span><br><span class="line">av_opt_get(client, <span class="string">"resource"</span>, AV_OPT_SEARCH_CHILDREN, &amp;resource);<span class="comment">//获取resource属性</span></span><br><span class="line"><span class="keyword">if</span> (resource &amp;&amp; <span class="built_in">strlen</span>(resource))<span class="comment">//不是 ""和null</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">av_freep(&amp;resource);<span class="comment">//释放掉</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">av_log(client, AV_LOG_TRACE, <span class="string">"resource=%p\n"</span>, resource);</span><br><span class="line"><span class="keyword">if</span> (resource &amp;&amp; resource[<span class="number">0</span>] == <span class="string">'/'</span> &amp;&amp; !<span class="built_in">strcmp</span>((resource + <span class="number">1</span>), in_uri)) &#123;<span class="comment">//检查链接合法性</span></span><br><span class="line">reply_code = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">reply_code = AVERROR_HTTP_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((ret = av_opt_set_int(client, <span class="string">"reply_code"</span>, reply_code, AV_OPT_SEARCH_CHILDREN)) &lt; <span class="number">0</span>) &#123;<span class="comment">//设置到一个子对象上的reply_code</span></span><br><span class="line">av_log(client, AV_LOG_ERROR, <span class="string">"Failed to set reply_code: %s.\n"</span>, av_err2str(ret));</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line">av_log(client, AV_LOG_TRACE, <span class="string">"Set reply code to %d\n"</span>, reply_code);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((ret = avio_handshake(client)) &gt; <span class="number">0</span>);<span class="comment">//正在握手 在这里等待</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Handshake performed.\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (reply_code != <span class="number">200</span>)</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Opening input file.\n"</span>);</span><br><span class="line"><span class="keyword">if</span> ((ret = avio_open2(&amp;input, in_uri, AVIO_FLAG_READ, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;<span class="comment">//通过url创建一个io上下文</span></span><br><span class="line">av_log(input, AV_LOG_ERROR, <span class="string">"Failed to open input: %s: %s.\n"</span>, in_uri,</span><br><span class="line">av_err2str(ret));</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">n = avio_read(input, buf, <span class="keyword">sizeof</span>(buf));<span class="comment">//读</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (n == AVERROR_EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">av_log(input, AV_LOG_ERROR, <span class="string">"Error reading from input: %s.\n"</span>,</span><br><span class="line">av_err2str(n));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">avio_write(client, buf, n);<span class="comment">//写</span></span><br><span class="line">avio_flush(client);<span class="comment">//刷新</span></span><br><span class="line">&#125;</span><br><span class="line">end:</span><br><span class="line">avio_flush();</span><br><span class="line">avio_close();</span><br><span class="line">avio_close();</span><br><span class="line">av_freep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">官方示例HTTP多连接发送文件简析</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>17.官方示例提取帧运动矢量简析</title>
    <link href="http://bugnull.com/2019/12/27/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/17-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E6%8F%90%E5%8F%96%E5%B8%A7%E8%BF%90%E5%8A%A8%E7%9F%A2%E9%87%8F%E7%AE%80%E6%9E%90/"/>
    <id>http://bugnull.com/2019/12/27/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/17-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E6%8F%90%E5%8F%96%E5%B8%A7%E8%BF%90%E5%8A%A8%E7%9F%A2%E9%87%8F%E7%AE%80%E6%9E%90/</id>
    <published>2019-12-27T11:08:59.000Z</published>
    <updated>2022-08-28T16:03:58.285Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//extract_mvs.c</span></span><br><span class="line">avformat_open_input();<span class="comment">//打开封装上下文</span></span><br><span class="line">avformat_find_stream_info();<span class="comment">//读取封装上下文的流信息</span></span><br><span class="line">open_codec_context();<span class="comment">//从ctx中找出stream codecCtx codec</span></span><br><span class="line">av_dump_format();<span class="comment">//输出封装信息</span></span><br><span class="line">av_frame_alloc();<span class="comment">//申请frame</span></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(fmt_ctx, &amp;pkt) &gt;= <span class="number">0</span>) &#123;<span class="comment">//读取一个Pkt</span></span><br><span class="line"><span class="keyword">if</span> (pkt.stream_index == video_stream_idx)</span><br><span class="line">ret = decode_packet(&amp;pkt);<span class="comment">//解码</span></span><br><span class="line">av_packet_unref(&amp;pkt);<span class="comment">//释放</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">decode_packet(<span class="literal">NULL</span>);<span class="comment">//缓存</span></span><br><span class="line"></span><br><span class="line">avcodec_free_context();<span class="comment">//释放codecCtx</span></span><br><span class="line">avformat_close_input();<span class="comment">//释放ctx</span></span><br><span class="line">av_frame_free();<span class="comment">//释放frame</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_codec_context</span><span class="params">(AVFormatContext *fmt_ctx, <span class="keyword">enum</span> AVMediaType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">AVStream *st;</span><br><span class="line">AVCodecContext *dec_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVCodec *dec = <span class="literal">NULL</span>;</span><br><span class="line">AVDictionary *opts = <span class="literal">NULL</span>;</span><br><span class="line">ret = av_find_best_stream(fmt_ctx, type, <span class="number">-1</span>, <span class="number">-1</span>, &amp;dec, <span class="number">0</span>);<span class="comment">//找出流index和编码器</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not find %s stream in input file '%s'\n"</span>,</span><br><span class="line">av_get_media_type_string(type), src_filename);<span class="comment">//返回AVMediaType的描述</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> stream_idx = ret;</span><br><span class="line">st = fmt_ctx-&gt;streams[stream_idx];</span><br><span class="line">dec_ctx = avcodec_alloc_context3(dec);<span class="comment">//申请编码上下文</span></span><br><span class="line"><span class="keyword">if</span> (!dec_ctx) &#123;</span><br><span class="line"><span class="keyword">return</span> AVERROR(EINVAL);</span><br><span class="line">&#125;</span><br><span class="line">ret = avcodec_parameters_to_context(dec_ctx, st-&gt;codecpar);<span class="comment">//根据codecpar的值填充ctx内</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">av_dict_set(&amp;opts, <span class="string">"flags2"</span>, <span class="string">"+export_mvs"</span>, <span class="number">0</span>);<span class="comment">//修改AVDictionary参数 因都是私有 需要通过函数修改</span></span><br><span class="line"><span class="keyword">if</span> ((ret = avcodec_open2(dec_ctx, dec, &amp;opts)) &lt; <span class="number">0</span>) &#123;<span class="comment">//将dec和ctx绑定</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to open %s codec\n"</span>,</span><br><span class="line">av_get_media_type_string(type));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">video_stream_idx = stream_idx;</span><br><span class="line">video_stream = fmt_ctx-&gt;streams[video_stream_idx];</span><br><span class="line">video_dec_ctx = dec_ctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">decode_packet</span><span class="params">(<span class="keyword">const</span> AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = avcodec_send_packet(video_dec_ctx, pkt);<span class="comment">//将压缩包交给解码器</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ret = avcodec_receive_frame(video_dec_ctx, frame);<span class="comment">//从解码器中返回数据</span></span><br><span class="line"><span class="keyword">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) &#123;<span class="comment">//输入错误 或者已经解码缓存中所有数据</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">AVFrameSideData *sd;<span class="comment">//保存AVFrame边缘的数据</span></span><br><span class="line">video_frame_count++;</span><br><span class="line">sd = av_frame_get_side_data(frame, AV_FRAME_DATA_MOTION_VECTORS);<span class="comment">//从frame中取出运动矢量数据 保存在sd</span></span><br><span class="line"><span class="keyword">if</span> (sd) &#123;</span><br><span class="line"><span class="keyword">const</span> AVMotionVector *mvs = (<span class="keyword">const</span> AVMotionVector *)sd-&gt;data;<span class="comment">//转成运动矢量</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sd-&gt;size / <span class="keyword">sizeof</span>(*mvs); i++) &#123;<span class="comment">//mvs是AVMotionVector数组指针 mv是一个数据指针</span></span><br><span class="line"><span class="keyword">const</span> AVMotionVector *mv = &amp;mvs[i];<span class="comment">//取出一组数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%2d,%2d,%2d,%4d,%4d,%4d,%4d,0x%"</span>PRIx64<span class="string">"\n"</span>,</span><br><span class="line">video_frame_count, mv-&gt;source,</span><br><span class="line">mv-&gt;w, mv-&gt;h, mv-&gt;src_x, mv-&gt;src_y,</span><br><span class="line">mv-&gt;dst_x, mv-&gt;dst_y, mv-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">av_frame_unref(frame);<span class="comment">//清掉frame缓存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct p &#123;</span></span><br><span class="line"><span class="comment">p(int aa,int bb):a(aa),b(bb)&#123;&#125;</span></span><br><span class="line"><span class="comment">int a;</span></span><br><span class="line"><span class="comment">int b;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">p aa[]=&#123;</span></span><br><span class="line"><span class="comment">p&#123; 1,2 &#125;, p&#123; 2,3 &#125;, p&#123; 3,4 &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">p * pa = aa;//pa即mvs</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; sizeof(aa) / sizeof(*pa); i++) &#123;</span></span><br><span class="line"><span class="comment">p *PPA = &amp;pa[i];//取出一个  &amp;pa[i]==pa+i</span></span><br><span class="line"><span class="comment">QMessageBox::about(nullptr, "", QString("%1 %2").arg(PPA-&gt;a).arg( PPA-&gt;b));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">官方示例提取帧运动矢量简析</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>16.官方示例解码音视频简析</title>
    <link href="http://bugnull.com/2019/12/27/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/16-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E7%A0%81%E9%9F%B3%E8%A7%86%E9%A2%91%E7%AE%80%E6%9E%90/"/>
    <id>http://bugnull.com/2019/12/27/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/16-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E7%A0%81%E9%9F%B3%E8%A7%86%E9%A2%91%E7%AE%80%E6%9E%90/</id>
    <published>2019-12-27T07:23:00.000Z</published>
    <updated>2022-08-28T16:04:02.247Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file</span></span><br><span class="line"><span class="comment"> * audio decoding with libavcodec API example</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @example decode_audio.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">av_packet_alloc();<span class="comment">//分配并初始化pkt</span></span><br><span class="line">avcodec_find_decoder();<span class="comment">//根据id找一个解码器codec</span></span><br><span class="line">av_parser_init();<span class="comment">//根据编码器id返回一个解析器上下文parserctx</span></span><br><span class="line">avcodec_alloc_context3();<span class="comment">//根据codec分配ctx</span></span><br><span class="line">avcodec_open2();<span class="comment">//用编码器打开上下文</span></span><br><span class="line"></span><br><span class="line">data = inbuf;<span class="comment">//一个数组</span></span><br><span class="line">data_size = fread(inbuf, <span class="number">1</span>, AUDIO_INBUF_SIZE, f);</span><br><span class="line"><span class="keyword">while</span> (data_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!frame) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(frame = av_frame_alloc())) &#123;<span class="comment">//分配和初始化完整包</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = av_parser_parse2(parser, c, &amp;pkt-&gt;data, &amp;pkt-&gt;size,data, data_size,</span><br><span class="line">AV_NOPTS_VALUE, AV_NOPTS_VALUE, <span class="number">0</span>);<span class="comment">//从上下文中解析一个压缩包</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">data += ret;<span class="comment">//指针移动</span></span><br><span class="line">data_size -= ret;<span class="comment">//缓存数量减少</span></span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;size)</span><br><span class="line">decode(c, frame, pkt, outfile);<span class="comment">//解码 并写到文件中去</span></span><br><span class="line"><span class="keyword">if</span> (data_size &lt; AUDIO_REFILL_THRESH) &#123;<span class="comment">//若数据少于AUDIO_REFILL_THRESH，就去文件中读取缺少的部分 直到达到AUDIO_INBUF_SIZE</span></span><br><span class="line">memmove(inbuf, data, data_size);<span class="comment">//将inbuf内容变为由data开始 连续data_size</span></span><br><span class="line">data = inbuf;</span><br><span class="line">len = fread(data + data_size, <span class="number">1</span>,AUDIO_INBUF_SIZE - data_size, f);</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">data_size += len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pkt-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">pkt-&gt;size = <span class="number">0</span>;</span><br><span class="line">decode(c, frame, pkt, outfile);<span class="comment">//有可能文件没解析完</span></span><br><span class="line">avcodec_free_context();<span class="comment">//关闭编码器上下文</span></span><br><span class="line">av_parser_close();<span class="comment">//关闭解析器</span></span><br><span class="line">av_frame_free();<span class="comment">//释放帧</span></span><br><span class="line">av_packet_free();<span class="comment">//释放压缩包</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file</span></span><br><span class="line"><span class="comment"> * video decoding with libavcodec API example</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @example decode_video.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">av_packet_alloc();<span class="comment">//初始化pkt</span></span><br><span class="line"><span class="built_in">memset</span>(inbuf + INBUF_SIZE, <span class="number">0</span>, AV_INPUT_BUFFER_PADDING_SIZE);<span class="comment">//初始化缓存数组 防止越界</span></span><br><span class="line">avcodec_find_decoder();<span class="comment">//查找一个解码器 codec</span></span><br><span class="line">av_parser_init();<span class="comment">//初始化parser</span></span><br><span class="line">avcodec_alloc_contex3();<span class="comment">//初始化ctx</span></span><br><span class="line">av_frame_alloc();<span class="comment">//初始化frame</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!feof(f)) &#123;</span><br><span class="line">data_size = fread(inbuf, <span class="number">1</span>, INBUF_SIZE, f);</span><br><span class="line"><span class="keyword">if</span> (!data_size)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">data = inbuf;</span><br><span class="line"><span class="keyword">while</span> (data_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = av_parser_parse2(parser, c, &amp;pkt-&gt;data, &amp;pkt-&gt;size,</span><br><span class="line">data, data_size, AV_NOPTS_VALUE, AV_NOPTS_VALUE, <span class="number">0</span>);<span class="comment">//根据parser拆分一个压缩包</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">data += ret;</span><br><span class="line">data_size -= ret;</span><br><span class="line"><span class="keyword">if</span> (pkt-&gt;size)</span><br><span class="line">decode(c, frame, pkt, outfilename);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">decode(c, frame, <span class="literal">NULL</span>, outfilename);<span class="comment">//缓存</span></span><br><span class="line">av_parser_close();</span><br><span class="line">avcodec_free_context();</span><br><span class="line">av_frame_free();</span><br><span class="line">av_packet_free();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(AVCodecContext *dec_ctx, AVFrame *frame, AVPacket *pkt,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = avcodec_send_packet(dec_ctx, pkt);<span class="comment">//将ctx中的一些字段保存到解码器中 去解码pkt</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ret = avcodec_receive_frame(dec_ctx, frame);<span class="comment">//返回解码后的数据到frame</span></span><br><span class="line"><span class="keyword">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/*video</span></span><br><span class="line"><span class="comment">        printf("saving frame %3d\n", dec_ctx-&gt;frame_number);</span></span><br><span class="line"><span class="comment">        fflush(stdout);  </span></span><br><span class="line"><span class="comment">        for (i = 0; i &lt; frame-&gt;height; i++)</span></span><br><span class="line"><span class="comment">        fwrite(frame-&gt;data[0] + i * frame-&gt;linesize[0], 1, frame-&gt;width, f);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*audio:</span></span><br><span class="line"><span class="comment">data_size = av_get_bytes_per_sample(dec_ctx-&gt;sample_fmt);//每个样本的字节数</span></span><br><span class="line"><span class="comment">if (data_size &lt; 0) &#123;</span></span><br><span class="line"><span class="comment">exit(1);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for (i = 0; i &lt; frame-&gt;nb_samples; i++)</span></span><br><span class="line"><span class="comment">for (ch = 0; ch &lt; dec_ctx-&gt;channels; ch++)</span></span><br><span class="line"><span class="comment">fwrite(frame-&gt;data[ch] + data_size*i, 1, data_size, f);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">官方示例解码音视频简析</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>15.官方示例AVIO读取源码简析</title>
    <link href="http://bugnull.com/2019/12/27/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/15-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8BAVIO%E8%AF%BB%E5%8F%96%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/"/>
    <id>http://bugnull.com/2019/12/27/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/15-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8BAVIO%E8%AF%BB%E5%8F%96%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/</id>
    <published>2019-12-27T06:45:38.000Z</published>
    <updated>2022-08-28T16:04:07.542Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//avio_dir_cmd.c</span></span><br><span class="line">av_log_set_level();<span class="comment">//设置日志等级</span></span><br><span class="line">avformat_network_init();<span class="comment">//GnuTLS和OpenSSL的线程安全考虑 否则就不需要再使用</span></span><br><span class="line"></span><br><span class="line">avpriv_io_move();<span class="comment">//移动或者重名</span></span><br><span class="line">avpriv_io_delete();<span class="comment">//删除</span></span><br><span class="line">avio_open_dir();<span class="comment">//打开目录</span></span><br><span class="line">avio_read_dir();<span class="comment">//从目录读取一个条目</span></span><br><span class="line">avio_free_directory_entry();<span class="comment">//关闭条目</span></span><br><span class="line"></span><br><span class="line">avformat_network_deinit();<span class="comment">//有avformat_network_init必须有这个进行关闭</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file</span></span><br><span class="line"><span class="comment"> * libavformat AVIOContext API example.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Make libavformat demuxer access media content through a custom</span></span><br><span class="line"><span class="comment"> * AVIOContext read callback.</span></span><br><span class="line"><span class="comment"> * @example avio_reading.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">av_file_map();<span class="comment">//读取文件到buffer和buffersize</span></span><br><span class="line">avformat_alloc_context();<span class="comment">//分配和初始化封装上下文ctx</span></span><br><span class="line">av_malloc();<span class="comment">//申请一块空间得到ctxbuffer</span></span><br><span class="line"><span class="comment">//bd结构体 包含buffer和buffersize</span></span><br><span class="line">avio_alloc_context(ctxbuffer, ctxbuffersize,<span class="number">0</span>, &amp;bd, &amp;read_packet, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//为比特流上下文申请空间 得到avio_ctx</span></span><br><span class="line">ctx-&gt;pb = avio_ctx;</span><br><span class="line">avformat_open_input();<span class="comment">//打开流</span></span><br><span class="line">avformat_find_stream_info();<span class="comment">//读文件流信息</span></span><br><span class="line">av_dump_format();<span class="comment">//打印封装上下文</span></span><br><span class="line">avformat_close_input();<span class="comment">//关闭封装上下文并指为NULL</span></span><br><span class="line">av_freep();<span class="comment">//av_malloc()</span></span><br><span class="line">av_context_free();<span class="comment">//关闭比特流上下文</span></span><br><span class="line">av_file_unmap();<span class="comment">//av_file_map()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read_packet</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> buf_size)</span><span class="comment">//从opaque中读取buf_size长的数据保存在buf</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_data</span> *<span class="title">bd</span> = (<span class="title">struct</span> <span class="title">buffer_data</span> *)<span class="title">opaque</span>;</span></span><br><span class="line">buf_size = FFMIN(buf_size, bd-&gt;size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!buf_size)</span><br><span class="line"><span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr:%p size:%zu\n"</span>, bd-&gt;ptr, bd-&gt;size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy internal buffer data to buf */</span></span><br><span class="line"><span class="built_in">memcpy</span>(buf, bd-&gt;ptr, buf_size);</span><br><span class="line">bd-&gt;ptr += buf_size;</span><br><span class="line">bd-&gt;size -= buf_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buf_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">官方示例AVIO读取源码简析</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>14.官方示例编码音视频简析</title>
    <link href="http://bugnull.com/2019/12/26/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/14-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E7%BC%96%E7%A0%81%E9%9F%B3%E8%A7%86%E9%A2%91%E7%AE%80%E6%9E%90/"/>
    <id>http://bugnull.com/2019/12/26/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/14-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E7%BC%96%E7%A0%81%E9%9F%B3%E8%A7%86%E9%A2%91%E7%AE%80%E6%9E%90/</id>
    <published>2019-12-26T09:35:33.000Z</published>
    <updated>2022-08-28T16:04:11.113Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file</span></span><br><span class="line"><span class="comment"> * audio encoding with libavcodec API example.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @example encode_audio.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">avcodec_find_encoder();<span class="comment">//查找一个编码器encodec</span></span><br><span class="line">avcodec_alloc_contex3();<span class="comment">//根据编码器 申请一个编码上下文ctx</span></span><br><span class="line">ctx-&gt;bit_rate;</span><br><span class="line">ctx-&gt;sample_fmt;<span class="comment">//根据encodec-&gt;sample_fmts查看是否支持</span></span><br><span class="line">ctx-&gt;sample_rate;<span class="comment">//根据encodec-&gt;supported_samplerates找一个最适合的</span></span><br><span class="line">ctx-&gt;channel_layout;<span class="comment">//根据const uint64_t *p=encodec-&gt;channel_layouts av_get_channel_layout_nb_channels(*p)找最大的通道</span></span><br><span class="line">ctx-&gt;channels;<span class="comment">//av_get_channel_layout_nb_channels(ctx-&gt;channel_layout)</span></span><br><span class="line">avcodec_open2();<span class="comment">//打开编码器与上下文绑定</span></span><br><span class="line">av_packet_alloc();<span class="comment">//分配并初始化一个pkt</span></span><br><span class="line">av_frame_alloc();<span class="comment">//分配并初始化一个frame</span></span><br><span class="line">frame-&gt;nb_samples=ctx-&gt;frame_size;</span><br><span class="line">frame-&gt;format=ctx-&gt;ctx-&gt;sample_fmt;</span><br><span class="line">frame-&gt;channel_layout=ctx-&gt;channel_layout;</span><br><span class="line">av_frame_get_buffer();<span class="comment">//为frame分配buff空间</span></span><br><span class="line">av_frame_make_writable();<span class="comment">//确定帧是可写的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ *</span><br><span class="line">以每秒<span class="number">110</span>Hz增加频率</span><br><span class="line">tincr = <span class="number">2</span> * M_PI * <span class="number">110.0</span> / c-&gt; sample_rate; </span><br><span class="line">tincr2 = <span class="number">2</span> * M_PI * <span class="number">110.0</span> / c-&gt; sample_rate / c-&gt; sample_rate; </span><br><span class="line">填充一段正弦波</span><br><span class="line">*/</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line">tincr = <span class="number">2</span> * M_PI * <span class="number">440.0</span> / ctx-&gt;sample_rate;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">ret = av_frame_make_writable(frame);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">samples = (<span class="keyword">uint16_t</span>*)frame-&gt;data[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;frame_size; j++) &#123;</span><br><span class="line">samples[<span class="number">2</span> * j] = (<span class="keyword">int</span>)(<span class="built_in">sin</span>(t) * <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; c-&gt;channels; k++)</span><br><span class="line">samples[<span class="number">2</span> * j + k] = samples[<span class="number">2</span> * j];</span><br><span class="line">t += tincr;</span><br><span class="line">&#125;</span><br><span class="line">encode(ctx, frame, pkt, f);<span class="comment">//avcodec_send_frame avcodec_receive_packet av_packet_unref</span></span><br><span class="line">&#125;</span><br><span class="line">encode(ctx, <span class="literal">NULL</span>, pkt, f);</span><br><span class="line"></span><br><span class="line">av_frame_free();<span class="comment">//释放fream</span></span><br><span class="line">av_packet_free();<span class="comment">//释放pkt</span></span><br><span class="line">avcodec_free_contex();<span class="comment">//释放编码上下文</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @file</span></span><br><span class="line"><span class="comment">* video encoding with libavcodec API example</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @example encode_video.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">avcodec_find_encoder_by_name();<span class="comment">//根据名字查找编码器encodec</span></span><br><span class="line">avcodec_alloc_context3();<span class="comment">//根据编码器 申请编码上下文ctx</span></span><br><span class="line">av_packet_alloc();<span class="comment">//分配pkt</span></span><br><span class="line">ctx-&gt;bit_rate;</span><br><span class="line">ctx-&gt;width;</span><br><span class="line">ctx-&gt;height;</span><br><span class="line">ctx-&gt;time_base;<span class="comment">//AVRational&#123;1,25&#125;   fps25</span></span><br><span class="line">ctx-&gt;framerate;<span class="comment">//AVRational&#123;25,1&#125;</span></span><br><span class="line">ctx-&gt;gop_size;<span class="comment">//多久一个关键帧</span></span><br><span class="line">ctx-&gt;max_b_frames;<span class="comment">//最多b帧</span></span><br><span class="line">ctx-&gt;pix_fmt;<span class="comment">//帧格式</span></span><br><span class="line"><span class="keyword">if</span> (codec-&gt;id == AV_CODEC_ID_H264) av_opt_set(ctx-&gt;priv_data, <span class="string">"preset"</span>, <span class="string">"slow"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*AVOption除了可以对常用的结构体AVFormatContext、AVCodecContext等进行设置之外，还可以对它们的私有数据priv_data进行赋值。这些字段里面通常存储了各种编码器特有的结构体。如使用libx264进行编码的时候，通过AVCodecContext的priv_data字段可以对X264Context（libavcodec\libx264.c）结构体中的变量进行赋值，设置preset、profile等*/</span></span><br><span class="line">avcodec_open2();<span class="comment">//打开编码器与上下文绑定</span></span><br><span class="line">av_frame_alloc();<span class="comment">//初始化frame</span></span><br><span class="line">frame-&gt;format=ctx-&gt;pix_fmt;</span><br><span class="line">frame-&gt;width=ctx-&gt;width;</span><br><span class="line">frame-&gt;height=ctx-&gt;height;</span><br><span class="line">av_frame_get_buffer();<span class="comment">//为frame申请内部空间</span></span><br><span class="line">av_frame_make_writable();<span class="comment">//确定帧是可写的</span></span><br><span class="line"></span><br><span class="line">填满frame-&gt;data;</span><br><span class="line">encodec();</span><br><span class="line"></span><br><span class="line">avcodec_free_context();</span><br><span class="line">av_frame_free();</span><br><span class="line">av_packet_free();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">encode(AVCodecContext *enc_ctx, AVFrame *frame, AVPacket *pkt,FILE *outfile)&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"><span class="comment">/* send the frame to the encoder */</span></span><br><span class="line"><span class="keyword">if</span> (frame)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Send frame %3"</span>PRId64<span class="string">"\n"</span>, frame-&gt;pts);</span><br><span class="line"></span><br><span class="line">ret = avcodec_send_frame(enc_ctx, frame);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error sending a frame for encoding\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ret = avcodec_receive_packet(enc_ctx, pkt);</span><br><span class="line"><span class="keyword">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error during encoding\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Write packet %3"</span>PRId64<span class="string">" (size=%5d)\n"</span>, pkt-&gt;pts, pkt-&gt;size);</span><br><span class="line">fwrite(pkt-&gt;data, <span class="number">1</span>, pkt-&gt;size, outfile);</span><br><span class="line">av_packet_unref(pkt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">官方示例编码音视频简析</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>13.官方示例解复用和解编码.c</title>
    <link href="http://bugnull.com/2019/12/25/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/13-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%92%8C%E8%A7%A3%E7%BC%96%E7%A0%81-c/"/>
    <id>http://bugnull.com/2019/12/25/%E8%A7%86%E9%A2%91%E5%9B%BE%E5%83%8F/13-%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E5%A4%8D%E7%94%A8%E5%92%8C%E8%A7%A3%E7%BC%96%E7%A0%81-c/</id>
    <published>2019-12-25T15:17:22.000Z</published>
    <updated>2022-08-28T16:04:15.171Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/imgutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/samplefmt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> AVCodecContext *video_dec_ctx = <span class="literal">NULL</span>, *audio_dec_ctx;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> width, height;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">enum</span> AVPixelFormat pix_fmt;</span><br><span class="line"><span class="keyword">static</span> AVStream *video_stream = <span class="literal">NULL</span>, *audio_stream = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *src_filename = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *video_dst_filename = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *audio_dst_filename = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> FILE *video_dst_file = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> FILE *audio_dst_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> *video_dst_data[<span class="number">4</span>] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>      video_dst_linesize[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> video_dst_bufsize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> video_stream_idx = <span class="number">-1</span>, audio_stream_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">static</span> AVFrame *frame = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> AVPacket pkt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> video_frame_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> audio_frame_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable or disable frame reference counting. You are not supposed to support</span></span><br><span class="line"><span class="comment">* both paths in your application but pick the one most appropriate to your</span></span><br><span class="line"><span class="comment">* needs. Look for the use of refcount in this example to see what are the</span></span><br><span class="line"><span class="comment">* differences of API usage between them. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> refcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">decode_packet</span><span class="params">(<span class="keyword">int</span> *got_frame, <span class="keyword">int</span> cached)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> decoded = pkt.size;</span><br><span class="line"></span><br><span class="line">*got_frame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pkt.stream_index == video_stream_idx) &#123;</span><br><span class="line"><span class="comment">/* decode video frame */</span></span><br><span class="line">ret = avcodec_decode_video2(video_dec_ctx, frame, got_frame, &amp;pkt);<span class="comment">//解码帧 已经弃用不再维护</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error decoding video frame (%s)\n"</span>, av_err2str(ret));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*got_frame) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (frame-&gt;width != width || frame-&gt;height != height ||</span><br><span class="line">frame-&gt;format != pix_fmt) &#123;<span class="comment">//帧大小不对</span></span><br><span class="line"><span class="comment">/* To handle this change, one could call av_image_alloc again and</span></span><br><span class="line"><span class="comment">* decode the following frames into another rawvideo file. */</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: Width, height and pixel format have to be "</span></span><br><span class="line"><span class="string">"constant in a rawvideo file, but the width, height or "</span></span><br><span class="line"><span class="string">"pixel format of the input video changed:\n"</span></span><br><span class="line"><span class="string">"old: width = %d, height = %d, format = %s\n"</span></span><br><span class="line"><span class="string">"new: width = %d, height = %d, format = %s\n"</span>,</span><br><span class="line">width, height, av_get_pix_fmt_name(pix_fmt),</span><br><span class="line">frame-&gt;width, frame-&gt;height,</span><br><span class="line">av_get_pix_fmt_name(frame-&gt;format));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"video_frame%s n:%d coded_n:%d\n"</span>,</span><br><span class="line">cached ? <span class="string">"(cached)"</span> : <span class="string">""</span>,</span><br><span class="line">video_frame_count++, frame-&gt;coded_picture_number);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy decoded frame to destination buffer:</span></span><br><span class="line"><span class="comment">* this is required since rawvideo expects non aligned data */</span></span><br><span class="line">av_image_copy(video_dst_data, video_dst_linesize,</span><br><span class="line">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> **)(frame-&gt;data), frame-&gt;linesize,</span><br><span class="line">pix_fmt, width, height);<span class="comment">//复制帧数据到video_dst_data和video_dst_linesize 因为是rawvideo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* write to rawvideo file */</span></span><br><span class="line">fwrite(video_dst_data[<span class="number">0</span>], <span class="number">1</span>, video_dst_bufsize, video_dst_file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pkt.stream_index == audio_stream_idx) &#123;</span><br><span class="line"><span class="comment">/* decode audio frame */</span></span><br><span class="line">ret = avcodec_decode_audio4(audio_dec_ctx, frame, got_frame, &amp;pkt);<span class="comment">//解码音频 已经放弃维护</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error decoding audio frame (%s)\n"</span>, av_err2str(ret));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Some audio decoders decode only part of the packet, and have to be</span></span><br><span class="line"><span class="comment">* called again with the remainder of the packet data.</span></span><br><span class="line"><span class="comment">* Sample: fate-suite/lossless-audio/luckynight-partial.shn</span></span><br><span class="line"><span class="comment">* Also, some decoders might over-read the packet. */</span></span><br><span class="line">decoded = FFMIN(ret, pkt.size);<span class="comment">//该帧的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*got_frame) &#123;</span><br><span class="line"><span class="keyword">size_t</span> unpadded_linesize = frame-&gt;nb_samples * av_get_bytes_per_sample(frame-&gt;format);<span class="comment">//采样数*采样样本大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"audio_frame%s n:%d nb_samples:%d pts:%s\n"</span>,</span><br><span class="line">cached ? <span class="string">"(cached)"</span> : <span class="string">""</span>,</span><br><span class="line">audio_frame_count++, frame-&gt;nb_samples,</span><br><span class="line">av_ts2timestr(frame-&gt;pts, &amp;audio_dec_ctx-&gt;time_base));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write the raw audio data samples of the first plane. This works</span></span><br><span class="line"><span class="comment">* fine for packed formats (e.g. AV_SAMPLE_FMT_S16). However,</span></span><br><span class="line"><span class="comment">* most audio decoders output planar audio, which uses a separate</span></span><br><span class="line"><span class="comment">* plane of audio samples for each channel (e.g. AV_SAMPLE_FMT_S16P).</span></span><br><span class="line"><span class="comment">* In other words, this code will write only the first audio channel</span></span><br><span class="line"><span class="comment">* in these cases.</span></span><br><span class="line"><span class="comment">* You should use libswresample or libavfilter to convert the frame</span></span><br><span class="line"><span class="comment">* to packed data. */</span></span><br><span class="line">fwrite(frame-&gt;extended_data[<span class="number">0</span>], <span class="number">1</span>, unpadded_linesize, audio_dst_file);<span class="comment">//对于plane是可以的 planar需要使用libswresample or libavfilter进行优化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we use frame reference counting, we own the data and need</span></span><br><span class="line"><span class="comment">* to de-reference it when we don't use it anymore */</span></span><br><span class="line"><span class="keyword">if</span> (*got_frame &amp;&amp; refcount)</span><br><span class="line">av_frame_unref(frame);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_codec_context</span><span class="params">(<span class="keyword">int</span> *stream_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">AVCodecContext **dec_ctx, AVFormatContext *fmt_ctx, <span class="keyword">enum</span> AVMediaType type)</span><span class="comment">//根据type从fmt_ctx中返回stream_idx和dec_ctx</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, stream_index;</span><br><span class="line">AVStream *st;</span><br><span class="line">AVCodec *dec = <span class="literal">NULL</span>;</span><br><span class="line">AVDictionary *opts = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ret = av_find_best_stream(fmt_ctx, type, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//根据type 查找流的下标</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not find %s stream in input file '%s'\n"</span>,</span><br><span class="line">av_get_media_type_string(type), src_filename);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">stream_index = ret;</span><br><span class="line">st = fmt_ctx-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* find decoder for the stream */</span></span><br><span class="line">dec = avcodec_find_decoder(st-&gt;codecpar-&gt;codec_id);<span class="comment">//根据流保存的编码id 找到解码器</span></span><br><span class="line"><span class="keyword">if</span> (!dec) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to find %s codec\n"</span>,</span><br><span class="line">av_get_media_type_string(type));</span><br><span class="line"><span class="keyword">return</span> AVERROR(EINVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a codec context for the decoder */</span></span><br><span class="line">*dec_ctx = avcodec_alloc_context3(dec);<span class="comment">//根据编解码器 为ctx分配空间和初始化</span></span><br><span class="line"><span class="keyword">if</span> (!*dec_ctx) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to allocate the %s codec context\n"</span>,</span><br><span class="line">av_get_media_type_string(type));</span><br><span class="line"><span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Copy codec parameters from input stream to output codec context */</span></span><br><span class="line"><span class="keyword">if</span> ((ret = avcodec_parameters_to_context(*dec_ctx, st-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;<span class="comment">//将codecpar的字段替换dec_ctx内相应的字段</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to copy %s codec parameters to decoder context\n"</span>,</span><br><span class="line">av_get_media_type_string(type));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Init the decoders, with or without reference counting */</span></span><br><span class="line">av_dict_set(&amp;opts, <span class="string">"refcounted_frames"</span>, refcount ? <span class="string">"1"</span> : <span class="string">"0"</span>, <span class="number">0</span>);<span class="comment">//设置AVDictionary属性 </span></span><br><span class="line"><span class="keyword">if</span> ((ret = avcodec_open2(*dec_ctx, dec, &amp;opts)) &lt; <span class="number">0</span>) &#123;<span class="comment">//根据AVcode初始化一个编解码上下文</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to open %s codec\n"</span>,</span><br><span class="line">av_get_media_type_string(type));</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">*stream_idx = stream_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_format_from_sample_fmt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **fmt,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">enum</span> AVSampleFormat sample_fmt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample_fmt_entry</span> &#123;</span></span><br><span class="line"><span class="keyword">enum</span> AVSampleFormat sample_fmt; <span class="keyword">const</span> <span class="keyword">char</span> *fmt_be, *fmt_le;</span><br><span class="line">&#125; sample_fmt_entries[] = &#123;</span><br><span class="line">&#123; AV_SAMPLE_FMT_U8,  <span class="string">"u8"</span>,    <span class="string">"u8"</span> &#125;,</span><br><span class="line">&#123; AV_SAMPLE_FMT_S16, <span class="string">"s16be"</span>, <span class="string">"s16le"</span> &#125;,</span><br><span class="line">&#123; AV_SAMPLE_FMT_S32, <span class="string">"s32be"</span>, <span class="string">"s32le"</span> &#125;,</span><br><span class="line">&#123; AV_SAMPLE_FMT_FLT, <span class="string">"f32be"</span>, <span class="string">"f32le"</span> &#125;,</span><br><span class="line">&#123; AV_SAMPLE_FMT_DBL, <span class="string">"f64be"</span>, <span class="string">"f64le"</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">*fmt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FF_ARRAY_ELEMS(sample_fmt_entries); i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample_fmt_entry</span> *<span class="title">entry</span> = &amp;<span class="title">sample_fmt_entries</span>[<span class="title">i</span>];</span></span><br><span class="line"><span class="keyword">if</span> (sample_fmt == entry-&gt;sample_fmt) &#123;</span><br><span class="line">*fmt = AV_NE(entry-&gt;fmt_be, entry-&gt;fmt_le);<span class="comment">//大小端</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line"><span class="string">"sample format %s is not supported as output format\n"</span>,</span><br><span class="line">av_get_sample_fmt_name(sample_fmt));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, got_frame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">4</span> &amp;&amp; argc != <span class="number">5</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s [-refcount] input_file video_output_file audio_output_file\n"</span></span><br><span class="line"><span class="string">"API example program to show how to read frames from an input file.\n"</span></span><br><span class="line"><span class="string">"This program reads frames from a file, decodes them, and writes decoded\n"</span></span><br><span class="line"><span class="string">"video frames to a rawvideo file named video_output_file, and decoded\n"</span></span><br><span class="line"><span class="string">"audio frames to a rawaudio file named audio_output_file.\n\n"</span></span><br><span class="line"><span class="string">"If the -refcount option is specified, the program use the\n"</span></span><br><span class="line"><span class="string">"reference counting frame system which allows keeping a copy of\n"</span></span><br><span class="line"><span class="string">"the data for longer than one decode call.\n"</span></span><br><span class="line"><span class="string">"\n"</span>, argv[<span class="number">0</span>]);<span class="comment">//refcount 引用计数帧系统，但是保存副本的时间比编码长</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">5</span> &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-refcount"</span>)) &#123;</span><br><span class="line">refcount = <span class="number">1</span>;</span><br><span class="line">argv++;</span><br><span class="line">&#125;</span><br><span class="line">src_filename = argv[<span class="number">1</span>];</span><br><span class="line">video_dst_filename = argv[<span class="number">2</span>];</span><br><span class="line">audio_dst_filename = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* open input file, and allocate format context */</span></span><br><span class="line"><span class="keyword">if</span> (avformat_open_input(&amp;fmt_ctx, src_filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;<span class="comment">//打开输入流，并且读取文件头 fmt_ctx为NULL时 不必再调用avformat_alloc_context</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open source file %s\n"</span>, src_filename);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* retrieve stream information */</span></span><br><span class="line"><span class="keyword">if</span> (avformat_find_stream_info(fmt_ctx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;<span class="comment">//查找流信息</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not find stream information\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (open_codec_context(&amp;video_stream_idx, &amp;video_dec_ctx, fmt_ctx, AVMEDIA_TYPE_VIDEO) &gt;= <span class="number">0</span>) &#123;<span class="comment">//查找视频流 并得到编码器</span></span><br><span class="line">video_stream = fmt_ctx-&gt;streams[video_stream_idx];</span><br><span class="line"></span><br><span class="line">video_dst_file = fopen(video_dst_filename, <span class="string">"wb"</span>);</span><br><span class="line"><span class="keyword">if</span> (!video_dst_file) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open destination file %s\n"</span>, video_dst_filename);</span><br><span class="line">ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate image where the decoded image will be put */</span></span><br><span class="line">width = video_dec_ctx-&gt;width;</span><br><span class="line">height = video_dec_ctx-&gt;height;</span><br><span class="line">pix_fmt = video_dec_ctx-&gt;pix_fmt;</span><br><span class="line">ret = av_image_alloc(video_dst_data, video_dst_linesize,</span><br><span class="line">width, height, pix_fmt, <span class="number">1</span>);<span class="comment">//根据width height pix_fmt分配video_dst_data和video_dst_linesize的一张图片</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate raw video buffer\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line">video_dst_bufsize = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (open_codec_context(&amp;audio_stream_idx, &amp;audio_dec_ctx, fmt_ctx, AVMEDIA_TYPE_AUDIO) &gt;= <span class="number">0</span>) &#123;<span class="comment">//查找音频流 并得到编码器</span></span><br><span class="line">audio_stream = fmt_ctx-&gt;streams[audio_stream_idx];</span><br><span class="line">audio_dst_file = fopen(audio_dst_filename, <span class="string">"wb"</span>);</span><br><span class="line"><span class="keyword">if</span> (!audio_dst_file) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not open destination file %s\n"</span>, audio_dst_filename);</span><br><span class="line">ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dump input information to stderr */</span></span><br><span class="line">av_dump_format(fmt_ctx, <span class="number">0</span>, src_filename, <span class="number">0</span>);<span class="comment">//打印输入输出封装上下文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!audio_stream &amp;&amp; !video_stream) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not find audio or video stream in the input, aborting\n"</span>);</span><br><span class="line">ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frame = av_frame_alloc();<span class="comment">//初始化帧</span></span><br><span class="line"><span class="keyword">if</span> (!frame) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate frame\n"</span>);</span><br><span class="line">ret = AVERROR(ENOMEM);</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize packet, set data to NULL, let the demuxer fill it */</span></span><br><span class="line">av_init_packet(&amp;pkt);<span class="comment">//初始化压缩包</span></span><br><span class="line">pkt.data = <span class="literal">NULL</span>;</span><br><span class="line">pkt.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (video_stream)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Demuxing video from file '%s' into '%s'\n"</span>, src_filename, video_dst_filename);</span><br><span class="line"><span class="keyword">if</span> (audio_stream)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Demuxing audio from file '%s' into '%s'\n"</span>, src_filename, audio_dst_filename);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* read frames from the file */</span></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(fmt_ctx, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">AVPacket orig_pkt = pkt;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">ret = decode_packet(&amp;got_frame, <span class="number">0</span>);<span class="comment">//解码一帧</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">pkt.data += ret;<span class="comment">//数据指针移动</span></span><br><span class="line">pkt.size -= ret;<span class="comment">//数据长度减少</span></span><br><span class="line">&#125; <span class="keyword">while</span> (pkt.size &gt; <span class="number">0</span>);</span><br><span class="line">av_packet_unref(&amp;orig_pkt);<span class="comment">//删掉缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* flush cached frames */</span></span><br><span class="line">pkt.data = <span class="literal">NULL</span>;</span><br><span class="line">pkt.size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">decode_packet(&amp;got_frame, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (got_frame);<span class="comment">//清除缓存中的帧</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Demuxing succeeded.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (video_stream) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Play the output video file with the command:\n"</span></span><br><span class="line"><span class="string">"ffplay -f rawvideo -pix_fmt %s -video_size %dx%d %s\n"</span>,</span><br><span class="line">av_get_pix_fmt_name(pix_fmt), width, height,</span><br><span class="line">video_dst_filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (audio_stream) &#123;</span><br><span class="line"><span class="keyword">enum</span> AVSampleFormat sfmt = audio_dec_ctx-&gt;sample_fmt;</span><br><span class="line"><span class="keyword">int</span> n_channels = audio_dec_ctx-&gt;channels;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av_sample_fmt_is_planar(sfmt)) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *packed = av_get_sample_fmt_name(sfmt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Warning: the sample format the decoder produced is planar "</span></span><br><span class="line"><span class="string">"(%s). This example will output the first channel only.\n"</span>,</span><br><span class="line">packed ? packed : <span class="string">"?"</span>);</span><br><span class="line">sfmt = av_get_packed_sample_fmt(sfmt);</span><br><span class="line">n_channels = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ret = get_format_from_sample_fmt(&amp;fmt, sfmt)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Play the output audio file with the command:\n"</span></span><br><span class="line"><span class="string">"ffplay -f %s -ac %d -ar %d %s\n"</span>,</span><br><span class="line">fmt, n_channels, audio_dec_ctx-&gt;sample_rate,</span><br><span class="line">audio_dst_filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">avcodec_free_context(&amp;video_dec_ctx);<span class="comment">//释放视频解码器</span></span><br><span class="line">avcodec_free_context(&amp;audio_dec_ctx);<span class="comment">//释放音频解码器</span></span><br><span class="line">avformat_close_input(&amp;fmt_ctx);<span class="comment">//释放封装上下文</span></span><br><span class="line"><span class="keyword">if</span> (video_dst_file)</span><br><span class="line">fclose(video_dst_file);</span><br><span class="line"><span class="keyword">if</span> (audio_dst_file)</span><br><span class="line">fclose(audio_dst_file);</span><br><span class="line">av_frame_free(&amp;frame);<span class="comment">//释放帧</span></span><br><span class="line">av_free(video_dst_data[<span class="number">0</span>]);<span class="comment">//释放图片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">官方示例解复用和解编码</summary>
    
    
    
    <category term="视频图像" scheme="http://bugnull.com/categories/视频图像/"/>
    
    
    <category term="FFmpeg" scheme="http://bugnull.com/tags/FFmpeg/"/>
    
  </entry>
  
</feed>
