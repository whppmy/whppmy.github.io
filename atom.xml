<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BugNull</title>
  
  <subtitle>纸上得来终觉浅，绝知此事要躬行</subtitle>
  <link href="http://bugnull.com/atom.xml" rel="self"/>
  
  <link href="http://bugnull.com/"/>
  <updated>2022-08-29T16:05:20.000Z</updated>
  <id>http://bugnull.com/</id>
  
  <author>
    <name>whppmy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是微服务架构</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</id>
    <published>2023-03-04T12:27:42.990Z</published>
    <updated>2022-08-29T16:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构是一种架构模式或者架构风格，<strong>它提倡将单一应用程序划分成一组小的服务</strong>，每个服务运行在其独立的<strong>进程中</strong>，服务间互相协调、互相配合，为用户提供最终价值。服务间采用轻量级通信机制（通常基于HTTP的RESTful API）。每个服务都围绕着具体业务进行构建，并且能独立部署到生产环境。应尽量避免统一的、集中式的服务管理机制，对具体的服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有非常轻量的集中式管理来协调这些服务，可以使用不同的语言，也可以使用不同的数据存储。</p><p>由All in one，拆分成不同的模块（进程），一个服务做一件事，进行解耦。</p>]]></content>
    
    
    <summary type="html">记录微服务的理解</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>运输层基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2023-03-04T12:27:42.930Z</published>
    <updated>2022-08-30T12:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/网络/运输层基本概念/运输层概念.png" alt="运输层"><br><img src="/网络/运输层基本概念/运输层概念小结.png" alt="运输层"><br><img src="/网络/运输层基本概念/端口号.png" alt="运输层"><br><img src="/网络/运输层基本概念/分用与复用.png" alt="运输层"><br><img src="/网络/运输层基本概念/应用层常用协议端口号.png" alt="运输层"></p><p>UDP无连接，TCP三次握手、四次挥手<br><img src="/网络/运输层基本概念/UDP与TCP对比1.png" alt="运输层"><br><img src="/网络/运输层基本概念/UDP与TCP对比2.png" alt="运输层"><br><img src="/网络/运输层基本概念/UDP与TCP对比3.png" alt="运输层"><br><img src="/网络/运输层基本概念/UDP与TCP对比4.png" alt="运输层"><br>TCP规定，即使接收窗口为0，也要接收零窗口探测报文、确认报文、带有紧急数据的报文<br><img src="/网络/运输层基本概念/TCP流量控制.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP流量控制过程1.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP流量控制例题.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP拥塞控制.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP拥塞控制过程.png" alt="运输层"></p><p>慢开始会以2倍数增长拥塞窗口，拥塞避免是线性增加1<br><img src="/网络/运输层基本概念/TCP的拥塞算法慢开始与拥塞避免.png" alt="运输层"><br>不等超时，就进行重传，需要接收连续三个确认<br><img src="/网络/运输层基本概念/TCP的拥塞算法慢开始与拥塞避免的不足.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP拥塞算法快重传.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP拥塞算法快恢复.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP拥塞控制综合.png" alt="运输层"></p><p><img src="/网络/运输层基本概念/TCP超时重传时间的选择.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP超时重传时间计算公式.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP超时重传往返时间.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP超时重传时间出错纠正方法.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP超时重传时间例题.png" alt="运输层"></p><p>不推荐发送窗口前沿收缩，有可能这些数据已经发送了<br><img src="/网络/运输层基本概念/TCP可靠传输的实现滑动窗口滑动.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP可靠传输的实现滑动窗口状态.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP可靠传输的实现滑动窗口过程.png" alt="运输层"></p><p><img src="/网络/运输层基本概念/TCP连接的三个阶段.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP连接建立解决的问题.png" alt="运输层"><br>建立连接前，服务器会先创建传输控制块（TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针、当前的发送和接收序号、。。。），然后进行LISTEN<br>客户端要发起连接时，也先创建传输控制块<br>第三次握手是为了防止多连接，而消耗掉服务器资源<br>SYN=1的报文段不能携带数据，但要消耗一个序号、普通确认报文如果不带数据，则不消耗序号<br>x客户端选择作为初始序号，y为服务端选择的初始序号<br><img src="/网络/运输层基本概念/TCP三次握手连接过程.png" alt="运输层"></p><p>FIN=1的报文段不能携带数据，但要消耗一个序号。v等于TCP客户进程之前收到的最后一个字节序号+1。u等于TCP客户进程之前已传送过数据的最后一个字节序号+1。<br><img src="/网络/运输层基本概念/TCP四次挥手过程.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP保活机制.png" alt="运输层"></p>]]></content>
    
    
    <summary type="html">运输层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>应用层基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2023-03-04T12:27:42.930Z</published>
    <updated>2022-08-30T12:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/网络/应用层基本概念/应用层概念.png" alt="应用层"><br><img src="/网络/应用层基本概念/CS方式.png" alt="应用层"><br><img src="/网络/应用层基本概念/P2P方式.png" alt="应用层"><br><img src="/网络/应用层基本概念/DHCP动态主机配置协议.png" alt="应用层"><br>请求中会带有《事务ID》，用带确保是自己发出而得到的回应<br><img src="/网络/应用层基本概念/DHCP过程.png" alt="应用层"><br>路由器不会转发广播，需要在上面配置DHCP服务器IP，才能进行单播传送<br><img src="/网络/应用层基本概念/DHCP中继代理.png" alt="应用层"><br><img src="/网络/应用层基本概念/DHCP小结.png" alt="应用层"></p><p>DNS服务器，用于查找域名-&gt;IP  使用UDP 端口53<br><img src="/网络/应用层基本概念/域名结构.png" alt="应用层"><br><img src="/网络/应用层基本概念/域名服务器类别.png" alt="应用层"><br><img src="/网络/应用层基本概念/域名查询方式.png" alt="应用层"><br><img src="/网络/应用层基本概念/域名缓存.png" alt="应用层"></p><p><img src="/网络/应用层基本概念/FTP概念.png" alt="应用层"><br>控制连接会保持打开，数据连接传输完成就关闭<br><img src="/网络/应用层基本概念/FTP工作原理.png" alt="应用层"></p><p>基于TCP<br><img src="/网络/应用层基本概念/电子邮件概念.png" alt="应用层"><br><img src="/网络/应用层基本概念/SMTP工作原理.png" alt="应用层"><br>STMP只能传输ASCII，因而引进了MIME，将图片、文件转为ASCII或者将ASCII进行逆转换。MIME同样应用于HTTP<br><img src="/网络/应用层基本概念/SMTP补充.png" alt="应用层"><br><img src="/网络/应用层基本概念/POP3邮局协议.png" alt="应用层"><br><img src="/网络/应用层基本概念/基于万维网的电子邮件.png" alt="应用层"></p><p><img src="/网络/应用层基本概念/WWW万维网概念.png" alt="应用层"><br><img src="/网络/应用层基本概念/URL的组成.png" alt="应用层"><br><img src="/网络/应用层基本概念/HTTP请求报文.png" alt="应用层"><br><img src="/网络/应用层基本概念/HTTP响应报文.png" alt="应用层"><br><img src="/网络/应用层基本概念/Cookie概念.png" alt="应用层"><br><img src="/网络/应用层基本概念/Cookie工作流程.png" alt="应用层"><br><img src="/网络/应用层基本概念/WWW缓存与代理服务器.png" alt="应用层"><br><img src="/网络/应用层基本概念/HTTP请求例题.png" alt="应用层"><br><img src="/网络/应用层基本概念/WWW小结.png" alt="应用层"></p>]]></content>
    
    
    <summary type="html">应用层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>网络层基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2023-03-04T12:27:42.910Z</published>
    <updated>2022-08-30T12:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/网络/网络层基本概念/网络层概述.png" alt="网络层概述"></p><p><img src="/网络/网络层基本概念/面向连接的虚电路服务.png" alt="网络层提供的两种服务"><br><img src="/网络/网络层基本概念/无连接的数据报服务.png" alt="网络层提供的两种服务"><br><img src="/网络/网络层基本概念/虚电路与数据报服务对比.png" alt="网络层提供的两种服务"></p><p>32比特的IPV4地址不便阅读、记录、输入，因此采用点分十进制表示方法，8个一组，用.分开<br><img src="/网络/网络层基本概念/IPV4地址概述.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4地址分类.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4-A类地址.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4-B类地址.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4-C类地址.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4编址例题.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4编址例题2.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4小结.png" alt="IPV4"></p><p>增加子网时候，需要申请新的网络号，等待时间和钱，增加路由路中路由表记录数量，浪费原网络中剩余的IP。此时需要引入子网掩码，通过与运算，取出IPV4地址所在子网的网络地址<br><img src="/网络/网络层基本概念/子网掩码.png" alt="IPV4"><br><img src="/网络/网络层基本概念/子网掩码例题.png" alt="IPV4"></p><p><img src="/网络/网络层基本概念/无分类编址的IPV4.png" alt="IPV4"><br><img src="/网络/网络层基本概念/无分类编址的IPV4_2.png" alt="IPV4"><br><img src="/网络/网络层基本概念/无分类编址的IPV4_3.png" alt="IPV4"><br><img src="/网络/网络层基本概念/无分类编址的IPV4小结.png" alt="IPV4"></p><p>定长即使用同一个子网掩码来划分子网，只能划分出2^n个子网，从主机号借用的。容易造成IP地址浪费。使用不同的子网掩码来划分子网，更灵活，按需分配，子网数量可以不同，减少浪费。<br><img src="/网络/网络层基本概念/定长的子网掩码FLSM.png" alt="IPV4"><br><img src="/网络/网络层基本概念/变长的子网掩码VLSM.png" alt="IPV4"></p><p>路由器收到出错的数据报，丢弃后，向源主机发送ICMP数据报。<br><img src="/网络/网络层基本概念/IP数据报的发送和转发.png" alt="路由器"></p><p>产生环路，会使用TTL进行计算，为零时抛弃，或者加入黑洞路由，使用默认路由后，当不知道转发给哪里就会转发到默认路由<br><img src="/网络/网络层基本概念/静态路由配置及路由环路.png" alt="路由器"></p><p><img src="/网络/网络层基本概念/静态路由选择和动态路由选择.png" alt="路由器"></p><p>在两个自治系统中，内部使用的是IGP或IRP内部网关（路由）协议，之间使用的是EGP或ERP外部网关（路由）协议，仅表示协议，不表示实际使用什么算法<br><img src="/网络/网络层基本概念/因特网路由选择协议特点.png" alt="路由器"><br><img src="/网络/网络层基本概念/常见路由选择协议.png" alt="路由器"><br>路由器会定期发送自己的路由信息<br><img src="/网络/网络层基本概念/路由器基本结构.png" alt="路由器"><br><img src="/网络/网络层基本概念/路由信息协议RIP工作原理.png" alt="路由器"><br><img src="/网络/网络层基本概念/RIP更新规则.png" alt="路由器"><br><img src="/网络/网络层基本概念/RIP坏消息传播慢问题.png" alt="路由器"><br><img src="/网络/网络层基本概念/RIP小结.png" alt="路由器"></p><p><img src="/网络/网络层基本概念/基于LSDB进行最短路径优先SPF计算.png" alt="路由器"><br><img src="/网络/网络层基本概念/OSPF五种分组类型.png" alt="路由器"><br><img src="/网络/网络层基本概念/OSPF工作过程.png" alt="路由器"><br><img src="/网络/网络层基本概念/OSPF多点网络路由器邻居关系建立.png" alt="路由器"><br>减少信息洪泛，一个区域一般最多200个路由<br><img src="/网络/网络层基本概念/OSPF把自治系统再划分为更小的区域.png" alt="路由器"><br><img src="/网络/网络层基本概念/OSPF小结.png" alt="路由器"></p><p><img src="/网络/网络层基本概念/边界网关协议BGP.png" alt="路由器"><br><img src="/网络/网络层基本概念/BGP发言人.png" alt="路由器"><br><img src="/网络/网络层基本概念/BCP发言人构造的连通图.png" alt="路由器"><br>BGP-4报文封装在TCP报文段中<br><img src="/网络/网络层基本概念/BGP-4的四种报文.png" alt="路由器"><br><img src="/网络/网络层基本概念/封装报文的协议.png" alt="路由器"><br><img src="/网络/网络层基本概念/BGP小结.png" alt="路由器"></p><p><img src="/网络/网络层基本概念/IPV4数据报分片.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPv4数据报首部格式.png" alt="IPV4"></p><p><img src="/网络/网络层基本概念/ICMP网际控制报文.png" alt="ICMP"><br><img src="/网络/网络层基本概念/ICMP小结.png" alt="ICMP"></p><p>R1与R2之间类似点对点，也称IP隧道技术<br><img src="/网络/网络层基本概念/VPN虚拟专用网.png" alt="VPN"></p><p><img src="/网络/网络层基本概念/NAP网络地址转换.png" alt="NAP"><br><img src="/网络/网络层基本概念/NAPT网络地址与端口号转换.png" alt="NAPT"><br><img src="/网络/网络层基本概念/VPN与NAT小结.png" alt="NAPT"></p>]]></content>
    
    
    <summary type="html">网络层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>集线器与交换机基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2023-03-04T12:27:42.900Z</published>
    <updated>2022-08-30T13:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>总线型使用大量机械接头和无源电缆并不可靠</p><p><img src="/网络/集线器与交换机基本概念/总线型以太网和集线器HUB的星型以太网.png" alt="总线型与星型"></p><p>可以使用集线器HUB在物理层扩展以太网，将多个碰撞域（冲突域）合并成一个更大的冲突域，在一系中的一台主机要发送给二系中一台主机，该帧信号会传输到整个网络的各个主机。</p><p>交换机会把单播帧转发到目的主机（忽略ARP过程，假设交换机的帧交换表已“学习好了”）<br><img src="/网络/集线器与交换机基本概念/集线器与交换机SWITCH的区别.png" alt="集线器与交换机"></p><p>集线器一般使用CSMA/CD争取总线资源，只能半双工，而交换机可以进行全双工，同时进行收发工作。<br><img src="/网络/集线器与交换机基本概念/交换机工作状态.png" alt="交换机工作状态"></p><p><img src="/网络/集线器与交换机基本概念/对比集线器和交换机.png" alt="交换机工作状态"></p><p>交换机工作在数据链路层（也包括物理层—），集线器工作在物理层，前者性能快<br><img src="/网络/集线器与交换机基本概念/集线器与交换机小结.png" alt="交换机工作状态"></p><p>以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。是即插即用设备，刚上电内部帧交换表是空的，随通信进行处学习算法，自动逐渐建立起帧交换表。</p><p>盲目泛洪类似广播，登录会在发送方时登记，每条记录都有时效，到期自动删除，MAC与交换机接口关系不是永久性的，更换主机、更换网卡。ARP高速缓存表中IP与MAC对应关系同样会到期自动删除。<br><img src="/网络/集线器与交换机基本概念/交换机自学习过程.png" alt="交换机自学习"></p><p><img src="/网络/集线器与交换机基本概念/交换机网络环路和广播风暴.png" alt="交换机自学习"></p><p>使用生成树协议，保证没有环路网络<br><img src="/网络/集线器与交换机基本概念/生成树协议STP.png" alt="交换机自学习"></p><p>当交换机以太网足够大时，进行广播会有很大的开销<br>路由器工作在网络层，一般不转发广播，可以将交换机以太网分割成小的广播域<br><img src="/网络/集线器与交换机基本概念/广播频繁.png" alt="虚拟VLAN"></p><p><img src="/网络/集线器与交换机基本概念/虚拟局域网VLAN.png" alt="虚拟VLAN"></p><p><img src="/网络/集线器与交换机基本概念/IEEE802-1Q帧.png" alt="虚拟局域网VLAN实现机制"></p><p>交换机端口类型有以下三种：Access Trunk Hybrid<br>交换机各端口的缺少VLAN ID  思科上称为Native VLAN 即本征VLAN  华为上称Port VLAN ID即端口VLAN ID,PVID</p><p><img src="/网络/集线器与交换机基本概念/Access端口打标签与去标签.png" alt="虚拟局域网VLAN实现机制"></p><p><img src="/网络/集线器与交换机基本概念/Trunk端口转发.png" alt="虚拟局域网VLAN实现机制"></p><p><img src="/网络/集线器与交换机基本概念/VLAN端口类型转发.png" alt="虚拟局域网VLAN实现机制"></p><p><img src="/网络/集线器与交换机基本概念/Hybrid端口转发.png" alt="虚拟局域网VLAN实现机制"></p>]]></content>
    
    
    <summary type="html">集线器与交换机概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>MAC、IP、ARP基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/mac%E3%80%81ip%E3%80%81arp%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/mac%E3%80%81ip%E3%80%81arp%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2023-03-04T12:27:42.880Z</published>
    <updated>2022-08-30T12:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/网络/mac、ip、arp基本概念/MAC、IP、ARP三者关系.png" alt="三者关系"><br><img src="/网络/mac、ip、arp基本概念/MAC地址定义.png" alt="三者关系"><br><img src="/网络/mac、ip、arp基本概念/MAC地址小结.png" alt="三者关系"><br>单播：表示只传给指定MAC地址，多播：表示该网络接口所在的多播地址，一个接口可以在多个多播地址，与帧的目的MAC地址符合，即接收该帧，广播：地址为FF:FF:FF:FF:FF:FF，所有人都接收<br><img src="/网络/mac、ip、arp基本概念/IP地址定义.png" alt="三者关系"><br><img src="/网络/mac、ip、arp基本概念/MAC与IP的关系与传输过程.png" alt="三者关系"></p><p><img src="/网络/mac、ip、arp基本概念/ARP地址解析协议过程.png" alt="三者关系"><br><img src="/网络/mac、ip、arp基本概念/ARP地址解析协议过程1.png" alt="三者关系"><br>ARP只能在同一个链路或者同一个网络上使用</p><p><img src="/网络/mac、ip、arp基本概念/MAC、IP、ARP三者关系小结.png" alt="三者关系"></p>]]></content>
    
    
    <summary type="html">MAC、IP、ARP基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2023-03-04T12:27:42.260Z</published>
    <updated>2022-08-30T12:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>封装成帧：在链路层会对IP数据报文添加帧头和帧尾</p><ul><li>帧头和帧尾包含重要的控制信息</li><li>帧头和帧尾作为帧定界，可以通过物理层交付的比特流中提取一个个的帧（PPP帧），并不是所有都包含帧定界标志（以太网V2 MAC帧），而物理层会在传输前增加8字节前导码（前7位是同步码，作为时钟同步，之后一字节作为定界符）再转为电信号发送，以太网规定帧间间隔（96比特时间）</li><li>透明传输，指数据链路层对上层交付的传输数据没有任何限制，若数据中存在帧尾字段，链路层会在该位置做字符标记（在前增加esc  ascill=27）做比特处理（每5位1后插入1个0）等，以防止在解析时提前结束帧（字符填充或者零比特填充）</li></ul><p>差错检测：比特在实际传输过程中可能会产生差错，称为比特差错或误码。一段时间内，传输错误的比特占总传输比特的比率为误码率BER。检错后一般进行重传来纠正传输中的差错或者仅仅是德育检测到差错的帧，取决于是可靠传输还是不可靠传输</p><ul><li>在以太网V2 MAC帧中，帧尾包含4字节的帧检验序列FCS字段，检测是否有误码</li><li>在PPP帧中，帧尾包含2字节FCS</li><li>奇偶校验，在待发送数据后面添加1位奇偶校验，使整个数据（包括校验位）中1的个数为奇数或者偶数，漏检率高</li><li>循环冗余校验，约定一个生成多项式，基于数据和多项式计算出冗余码，添加到数据后面一起传输，漏检率非常低，易于硬件实现，广泛用于数据链路层<br><img src="/网络/数据链路层基本概念/循环冗余校验.png" alt="循环冗余检验CRC"><br><img src="/网络/数据链路层基本概念/循环冗余计算过程.png" alt="循环冗余检验CRC"></li><li>检测码只能检测出是否出错，不能定位，无法纠正错误，可以使用冗余信息更多的纠错码进行前向纠错，开销较大</li></ul><p>可靠传输：根据数据链路层向上层提供的服务类型，其可靠性不一定由数据链路层实现，其它各层均可选择实现可靠传输</p><ul><li>不可靠传输服务：仅仅丢弃有误码的帧</li><li>可靠传输服务：想办法实现发送端发送什么，接收端就收到什么</li><li>有线误码率低，不要求数据链路层向上提供可靠传输。即使出现误码，可靠传输的问题由其上层处理。</li><li>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</li><li><p>传输差错类型，比特差错、分组丢失、分组失序、分组重复，分组表示的是帧<br><img src="/网络/数据链路层基本概念/各层对可靠及不可靠传输类型.png" alt="各层可靠性类型"></p><p>可靠传输实现机制的原理，不仅限于数据链路层</p></li><li>停止-等待协议SW（自动请求重传ARQ）<br><img src="/网络/数据链路层基本概念/停止-等待.png" alt="传输机制"><br><img src="/网络/数据链路层基本概念/停止-等待信道利用率.png" alt="传输机制"></li><li>回退N帧协议GBN（连续ARQ，滑动窗口协议）<ul><li>制定比特给分组编号，发送窗口尺寸，表示一次发多个组，尺寸不能大于分组号-1，接收窗口尺寸为1，（若发送尺寸==分组数，则会接口窗口检测不到错误，依然把0号放置于0号，认为正确，实际是忽略了一个组），接收窗口只能等于1，只能按序接收，数据分组内出现误码后面的分组都会丢弃。</li><li>由停止-等待发送1个改为多个，串行改并行</li><li>累积确认，在接收到前N组时，可以直接发送ACKn表示已经接收到N组数据，减少资源占用</li><li>当多个到达接收方时，出现误码，不仅会丢弃该帧，还会把序号不匹配的丢弃，重新发送多个已经接收到最大序号的ACKn<br><img src="/网络/数据链路层基本概念/回退N帧定义.png" alt="传输机制"><br><img src="/网络/数据链路层基本概念/回退N帧，发送与接收工作机制.png" alt="传输机制"></li></ul></li><li>选择重传协议SR<ul><li>对回退N帧进行扩展，发送滑动窗口&gt;=接收窗口&gt;=1，可进行多组分别确认，但是取消累积确认<br><img src="/网络/数据链路层基本概念/选择重传协议定义.png" alt="传输机制"><br><img src="/网络/数据链路层基本概念/选择重传协议工作机制.png" alt="传输机制"></li></ul></li></ul><p>点对点协议PPP：目前使用最广泛的点对点数据链路层协议，向上不提供可靠传输<br>  <img src="/网络/数据链路层基本概念/点对点协议定义.png" alt="点对点协议"><br>  <img src="/网络/数据链路层基本概念/PPP帧格式.png" alt="点对点协议"></p><ul><li><p>实现透明传输，面向字节的异步链路，字节填充法，对特殊字符前插入转义字符，转义字符再插入转义字符。面向比特的同步链路，比特填充法，对于连续5位1的后面插入一个0。<br><img src="/网络/数据链路层基本概念/PPP工作状态.png" alt="点对点协议"></p><p><img src="/网络/数据链路层基本概念/媒体接入控制.png" alt="媒体接入控制"></p><p>信道复用：</p></li><li>频分复用FDM：根据频带划分出多个了频带（信道），频带间需要有隔离频带</li><li>时分复用TDM：将传输带宽资源按时隙轮流分配给不同用户，用户只能在对应的时隙进行通信，周期性出现，一周期就是一个TDM帧</li><li>波分复用WDM：即光的频分复用，将每路（1310nm波长，2.5Gb/s）变换到1550~1561.2nm，共8路，相隔1.6nm，在同一根光纤传输，光传输会损失，中间需要掺铒光纤放大器EDFA。</li><li><p>码分复用CDM：</p><p><img src="/网络/数据链路层基本概念/码分复用例子.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/静态划分信道小结.png" alt="媒体接入控制"></p><p>动态接入控制：<br>CSMA-CD适用于有线<br><img src="/网络/数据链路层基本概念/CSMA-CD概念.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD争用期.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD最小帧长.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD最大帧长.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD退避算法.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD信道利用率.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD发送流程.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD接收流程.png" alt="媒体接入控制"><br>CSMA/CA适用于无线<br><img src="/网络/数据链路层基本概念/CSMA-CA与CD区别.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CA与CD应用.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CA帧间间隔IFS.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CA工作原理.png" alt="媒体接入控制"><br>等待DIFS表示有高优先级让其先传。等待SIFS表示最短帧间间隔，用来分隔属于一次对话的各帧。<br><img src="/网络/数据链路层基本概念/CSMA-CA退避算法.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CA退避算法例子.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CA信道预约.png" alt="媒体接入控制"><br>请求发送RTS:帧包括源地址、目的地址及所需要时间 允许发送CTS:也包括此次通信时间<br><img src="/网络/数据链路层基本概念/CSMA-CA虚拟载波监听.png" alt="媒体接入控制"><br>解决A C互为隐蔽站的问题，C通过CTS知道B被占用的时间</p></li></ul>]]></content>
    
    
    <summary type="html">数据链路层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2023-03-04T12:27:42.240Z</published>
    <updated>2022-08-30T12:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>三种电路交换优缺点对比：<br>电路交换（比特流直达）<br>优点：通信时延小、有序、没有冲突、适用范围广、实时性强、控制简单<br>缺点：建立连接时间长、线路独占，使用效率低、灵活性差、难以规格化<br>报文交换（整组报文转发）<br>优点：无需建立连接、动态分配线路、线路可靠性、线路利用率高、多目标服务<br>缺点：转发时延、较大存储缓存空间、传输额外的信息量<br>分组交换<br>优点：无需建立连接、线路利用率高、简化存储管理、加速传输、减少出错和重发数据量<br>缺点：转发时延、传输额外的信息量、采用数据报服务时存在失序、丢失或者重复分组的问题；对于虚电路服务，存在呼叫建立、数据传输和虚电路释放三个过程。</p><p>时延=发送时延（分组长度/发送数率）+传播时延（信道长度/电磁波传播速率）+处理时延（硬件相关）</p><p>时延带宽积=传播时延*带宽</p><p>利用率：<br>信道利用率 用来表示信道百分之几的时间是有数据通过<br>网络利用率 全网络的信道利用率的加权平均<br>当前时延=空闲时延/(1-利用率)  当得用率达到50%以上时，则时延会增大，可以考虑扩容，增大线路的带宽。<br>尽量动态控制通信量，保持在合理范围内。</p><p>丢包：<br>接口、结点、链路、路径、网络丢包。<br>分组丢失：分组在传输过程中出现误码，被结点丢弃；到达一台队列已满的分组交换机时被丢弃。</p><p>OSI体系结构，七层协议<br>物理、数据链路、网络、运输、会话、表示、应用层<br>TCP/IP体系结构、四层协议<br>网络接口 网络接口<br>网际 IP将网络接口互联、向TCP、UDP提供网络互联服务(IP over everythins、Everything over IP)<br>运输 TCP(在IP服务的基础上，向应用层提供可靠性传输服务) UDP(…不可靠传输服务)<br>应用层 HTTP SMTP DNS RTP</p><p>原理体系结构（适用教学）<br>应用 解决通过应用进程的交互来实现特定网络应用的问题 应用进程间交互来完成特定的网络应用<br>运输 解决进程之间基于网络的通信问题 解决进程间、传输错误处理<br>网络 解决分组在多个网络上传输（路由）的问题 路由功能，如使用IP<br>数据链路 解决分组在一个网络（或链路）上传输的问题 如使用MAC标记主机<br>物理层 解决使用何种信号来传输比特的问题 硬件如网络网口、传输方式</p><p>由应用层向物理层转变 http（报文） -&gt; http+TCP（TCP报文段） -&gt; http+TCP+IP（IP数据报） -&gt; ETH+http+TCP+IP+ETH（帧） -&gt;  ….+前导码（比特流）</p><p>协议的三要素<br>语法 定义所交换信息的格式<br>语义 定义收发双方所要完成的操作<br>同步 定义收发双方的时序关系</p><p>协议数据单元PDU 对等层次之间传送的数据包称为该层的协议数据单元<br>服务数据单元SDU 同一系统内，层与层之间交换的数据包称为服务数据单元<br>多个SDU可以合成一个PDU，一个SDU可以划分为几个PDU</p>]]></content>
    
    
    <summary type="html">计算机网络基础小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>物理层基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2023-03-04T12:27:42.240Z</published>
    <updated>2022-08-30T12:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流<br>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么</p><p>物理层协议主要任务：<br>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置<br>电气特性：指明在接口电缆的各条线上出现的电压范围<br>功能特性：指明某条线上出现的某一电平的电压表示何种意义<br>过程特性：指明对于不同功能的各种可能事的出现顺序</p><p>传输媒体（不同媒体对应不同的物理层协议）：<br>1、导引型：双绞线（网线）、同轴电缆、光纤、电力线<br>2、非导引型：微波通信（2~40GHz)、无线电波、红外线、可见光</p><p>传输方式<br>1、串行（远距离传输，如计算机网络）。并行（CPU与内存之间，通过总线进行传输）<br>2、同步：以稳定的比特流传输，字节间没有间隔，接收端在中间时刻进行检测0或1，此时会有时钟累计误差。需要保持时钟同步。外同步：在收发双方间添加一条单独的时钟信号线。内同步：发送端将时钟同步信号编码到发送数据中一起传输（曼彻斯特编码）。异步：以一个字节为单位传输，字节间异步，在字节前后增加头和尾作为判断。<br>3、单工：单向通信（收音机）。半双工：双向交替通信，可以相互通信但不能同时（对讲机）。全双工：双向同时通信（电话）</p><p><img src="/网络/物理层基本概念/调制与编码.png" alt="编码与调制"></p><p>常用编码：不归零编码（存在同步问题，需要额外传输时钟，不常用），归零编码（自同步，编码效率低，用零电频做隔断），曼彻斯特编码（用码元间跳变表示时钟，又表示数据），差分曼彻斯特编码</p><p><img src="/网络/物理层基本概念/常用编码.png" alt="常用编码方法"></p><p><img src="/网络/物理层基本概念/常用调制.png" alt="常用调制方法"></p><p>频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位中的一个。相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。</p><p>信号在信道中传输会存在失帧的可能，其中因素娄：码元传输速率，信号传输距离，噪声干扰，传输媒体质量。</p><p><img src="/网络/物理层基本概念/信道极限容量.png" alt="奈氏准则和香农公式"></p>]]></content>
    
    
    <summary type="html">物理层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://bugnull.com/%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bugnull.com/%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-04T12:27:40.440Z</published>
    <updated>2022-08-31T02:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h1><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h3><p>根据参数，如字符串、枚举等，反回创建的类。不属于Gof所说的。</p><h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h3><p>抽象一层，选择一个需要的工厂，工厂有一个获取产品的方法，再从工厂取要的东西。</p><p><img src="/无处安放/设计模式/工厂方法模式UML图.png" alt=""></p><h3 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3.抽象工厂"></a>3.抽象工厂</h3><p>对工厂抽象和产品抽象，创建一个产品族工厂，从产品族工厂中取东西。理论上每个工厂都能取到同类型的东西，但是属性不一样。</p><p><img src="/无处安放/设计模式/抽象工厂模式UML图.png" alt=""></p><h3 id="4-构建者模式"><a href="#4-构建者模式" class="headerlink" title="4.构建者模式"></a>4.构建者模式</h3><p>抽象一个item做衍生，以此做为产品，里面有公共的方法。使用一个builder，选装Item，把东西存起来。产品可以动态增删。</p><p><img src="/无处安放/设计模式/builder.svg" alt=""></p><h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h3><p>使用当前已经存在的类，给予一个clone接口，用于克隆一份一样的、独立存在的类。</p><p><img src="/无处安放/设计模式/prototype.png" alt=""></p><h3 id="6-单例模式"><a href="#6-单例模式" class="headerlink" title="6.单例模式"></a>6.单例模式</h3><p>一个对象，只有一个实例，私有创建的方法。大家共用同一个。<br>懒汉式，在第一次使用时才创建<br>饿汉式，编译构建时就创建,static成员</p><p><img src="/无处安放/设计模式/singleton.jpg" alt=""></p><hr><h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7.适配器模式"></a>7.适配器模式</h3><p>由底部根据需求实现匹配，自动返回适应的类型或者执行某些动作。</p><p><img src="/无处安放/设计模式/adapter.png" alt=""></p><h3 id="8-桥接模式"><a href="#8-桥接模式" class="headerlink" title="8.桥接模式"></a>8.桥接模式</h3><p>根据不同的上层产品，给入不同的内部数据，通过上层产品操作间接使用数据，展示的效果会不一样。</p><p><img src="/无处安放/设计模式/桥接模式UML实例图.png" alt=""></p><h3 id="9-组合模式"><a href="#9-组合模式" class="headerlink" title="9.组合模式"></a>9.组合模式</h3><p>把东西按关系进行划分，构成一棵树级结构。</p><p><img src="/无处安放/设计模式/组合模式UML图.png" alt=""></p><h3 id="10-装饰者模式"><a href="#10-装饰者模式" class="headerlink" title="10.装饰者模式"></a>10.装饰者模式</h3><p>大家都会一个动作，但是又可以相互包装，A会画圆，B会画方，C的画画方法可以是让A、B一起来画，还可以加别的。</p><p><img src="/无处安放/设计模式/decorator.svg" alt=""></p><h3 id="11-外观模式"><a href="#11-外观模式" class="headerlink" title="11.外观模式"></a>11.外观模式</h3><p>使用一个上层包装，把多个具有某个关系的类放到一起。</p><p><img src="/无处安放/设计模式/外观模式实例UML图.png" alt=""></p><h3 id="12-享元模式"><a href="#12-享元模式" class="headerlink" title="12.享元模式"></a>12.享元模式</h3><p>大家共享某部分数据，在没有的时候进行创建，下次再要这个类型时返回该值，减少创建。</p><p><img src="/无处安放/设计模式/享元模式UML图.png" alt=""></p><h3 id="13-代理模式"><a href="#13-代理模式" class="headerlink" title="13.代理模式"></a>13.代理模式</h3><p>给一个类做一层包装，做一层扩展，做为代理人进行控制。</p><p><img src="/无处安放/设计模式/proxy.svg" alt=""></p><hr><h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><h3 id="14-职责链模式"><a href="#14-职责链模式" class="headerlink" title="14.职责链模式"></a>14.职责链模式</h3><p>根据类关系，构建一条关系链，在上层需要处理数据时，可能需要和下层进行交互，可以达到相互传递，以完成处理。</p><p><img src="/无处安放/设计模式/职责链模式UML实例图.png" alt=""></p><h3 id="15-命令模式"><a href="#15-命令模式" class="headerlink" title="15.命令模式"></a>15.命令模式</h3><p>把需要做的事情包装成一个事件，通过一个中心控制，命令事件执行。</p><p><img src="/无处安放/设计模式/命令模式实例UML图.png" alt=""></p><h3 id="16-解释器模式"><a href="#16-解释器模式" class="headerlink" title="16.解释器模式"></a>16.解释器模式</h3><p>通过特定的功能分类，拆成一个一个解析器，使用不同的解析器去处理对应的数据，达到整体划分。</p><p><img src="/无处安放/设计模式/解释器实例UML图.png" alt=""></p><h3 id="17-迭代器模式"><a href="#17-迭代器模式" class="headerlink" title="17.迭代器模式"></a>17.迭代器模式</h3><p>常见于Stl中，用于高效遍历内容。</p><p><img src="/无处安放/设计模式/iterator.png" alt=""></p><h3 id="18-中介者模式"><a href="#18-中介者模式" class="headerlink" title="18.中介者模式"></a>18.中介者模式</h3><p>大家根据某个关系，注册在一个中心。然后都可以通过中心给的接口，查询到别人的信息和被别人找到。</p><p><img src="/无处安放/设计模式/中介者模式UML图.png" alt=""></p><h3 id="19-备忘录模式"><a href="#19-备忘录模式" class="headerlink" title="19.备忘录模式"></a>19.备忘录模式</h3><p>处理一个事件，在需要的时候保存一下（新建一份数据）存起来，使用者后面可以根据索引去找到这份保存的数据。</p><p><img src="/无处安放/设计模式/备忘录模式UML图.png" alt=""></p><h3 id="20-观察者模式"><a href="#20-观察者模式" class="headerlink" title="20.观察者模式"></a>20.观察者模式</h3><p>大家往一个地方注册，当发生事件时，注册了的类会收到需要的信息。参考QT信号槽。</p><p><img src="/无处安放/设计模式/observer.jpg" alt=""></p><h3 id="21-状态模式"><a href="#21-状态模式" class="headerlink" title="21.状态模式"></a>21.状态模式</h3><p>给一个物体塑造多个外表，根据需要设置外表，用该外表做为当前的状态，可随时切换。</p><p><img src="/无处安放/设计模式/state.png" alt=""></p><h3 id="22-策略模式"><a href="#22-策略模式" class="headerlink" title="22.策略模式"></a>22.策略模式</h3><p>当前有一组数据，但是可以有多个处理的方法，其方法可能可以进行组合，把方法单独做为策略。组合出需要的场景。</p><p><img src="/无处安放/设计模式/strategy.jpg" alt=""></p><h3 id="23-模板模式"><a href="#23-模板模式" class="headerlink" title="23.模板模式"></a>23.模板模式</h3><p>抽象一个模板，模板会有很多动作调用。实体可以选择实现某些动作，不需要的可以空实现。</p><p><img src="/无处安放/设计模式/template.jpg" alt=""></p><h3 id="24-访问者模式"><a href="#24-访问者模式" class="headerlink" title="24.访问者模式"></a>24.访问者模式</h3><p>每个事物关注同一个东西的角度都不同。通过元素的回调或者访问者主动查看，可以做不同的动作。</p><p><img src="/无处安放/设计模式/visitor.jpg" alt=""></p><p><strong>以上为Gof(Gang of Four)四人组提出的</strong></p><hr><h3 id="25-pimpl"><a href="#25-pimpl" class="headerlink" title="25.pimpl"></a>25.pimpl</h3><p>qt源码实现方式，将成员藏在cpp，不对外暴露。</p><h3 id="26-业务代表"><a href="#26-业务代表" class="headerlink" title="26.业务代表"></a>26.业务代表</h3><p>其中包含client、Delegate、lookup、service。使用者通过代理缓存，查找需要的服务。通过这样将业务进行分层解耦。</p><p><img src="/无处安放/设计模式/businessDelegate.svg" alt=""></p><h3 id="27-组合实体模式"><a href="#27-组合实体模式" class="headerlink" title="27.组合实体模式"></a>27.组合实体模式</h3><blockquote><p>组合实体太学术化了，不通俗。组合实体是个对象，是个管理者，管家，掌柜的，经理，它是直接面向客户的。组合实体下面是几个小组，也就是假如说它是个经理的话，那么它下面管理着几个小组长。小组长下面就是组员了呗，也就是真正干活的人了。所以组合实体是个层层管理的机制，并且下层的生命周期决定于上层的生命周期。就这么简单。我想它的作用只不过是简化了每一环的复杂程度而已。</p></blockquote><p><strong><a href="https://www.it610.com/article/1177358433989488640.htm" target="_blank" rel="noopener">https://www.it610.com/article/1177358433989488640.htm</a></strong></p><p><img src="/无处安放/设计模式/420a453041f64bd1aea9cef4e2a1c5e1.jpg" alt=""></p><h3 id="28-过滤器模式"><a href="#28-过滤器模式" class="headerlink" title="28.过滤器模式"></a>28.过滤器模式</h3><p>字面意思，通过一个过滤器，把输入的数据过滤掉不合理的，然后得到结果。</p><p><img src="/无处安放/设计模式/criteria.svg" alt=""></p><h3 id="29-空模式"><a href="#29-空模式" class="headerlink" title="29.空模式"></a>29.空模式</h3><p>对于不些不合理的数据，给予一个空的对象，而不是空值。</p><p><img src="/无处安放/设计模式/null.jpg" alt=""></p><h3 id="30-mvc"><a href="#30-mvc" class="headerlink" title="30.mvc"></a>30.mvc</h3><p>model，存数据，更新时告诉C,view将数据做显示，controller作为中间传递数据和中间处理的一方。Qt中是MVD D是代理，包括C的功能，还有告诉V怎么去定制和绘制。</p><p><img src="/无处安放/设计模式/mvc.svg" alt=""></p><h3 id="31-数据访问对象模式"><a href="#31-数据访问对象模式" class="headerlink" title="31.数据访问对象模式"></a>31.数据访问对象模式</h3><p>将一些不好使用的接口包装进来，通过更上一层封装，使用时更便捷。</p><p><img src="/无处安放/设计模式/dao.jpg" alt=""></p><h3 id="32-前端控制器模式"><a href="#32-前端控制器模式" class="headerlink" title="32.前端控制器模式"></a>32.前端控制器模式</h3><p>通过一个前端，把请求进行汇总再分发给特定的处理器。</p><p><img src="/无处安放/设计模式/frontController.jpg" alt=""></p><h3 id="33-拦截过滤器模式"><a href="#33-拦截过滤器模式" class="headerlink" title="33.拦截过滤器模式"></a>33.拦截过滤器模式</h3><p>通过实现多个过滤器，在发生事件时，使用注册了的过滤器对事件进行处理，通过后再去做相应的操作，否则拦截。</p><p><img src="/无处安放/设计模式/interceptingFilter.svg" alt=""></p><h3 id="34-服务定位器模式"><a href="#34-服务定位器模式" class="headerlink" title="34.服务定位器模式"></a>34.服务定位器模式</h3><p>根据一个中心缓存，去查找或者说定位之前使用过的东西。</p><p><img src="/无处安放/设计模式/serviceLocator.svg" alt=""></p><h3 id="35-传输对象模式"><a href="#35-传输对象模式" class="headerlink" title="35.传输对象模式"></a>35.传输对象模式</h3><p>把对象打包传送与接收。</p><p><img src="/无处安放/设计模式/transfer.svg" alt=""></p>]]></content>
    
    
    <summary type="html">设计模式小记</summary>
    
    
    
    <category term="无处安放" scheme="http://bugnull.com/categories/无处安放/"/>
    
    
    <category term="设计模式" scheme="http://bugnull.com/tags/设计模式/"/>
    
  </entry>
  
  <entry>
    <title>GTest接口测试</title>
    <link href="http://bugnull.com/%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE/gtest%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    <id>http://bugnull.com/%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE/gtest%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</id>
    <published>2023-03-04T12:27:40.330Z</published>
    <updated>2022-09-04T14:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Gtest运行参数"><a href="#Gtest运行参数" class="headerlink" title="Gtest运行参数"></a>Gtest运行参数</h3><p>可以通过系统环境变量设置GTEST_FLAG，可以通过内部代码testing::GTEST_FLAG(output)=””设定，后设置的生效。</p><ul><li>–gtest_list_tests 输出所有用例</li><li>–gtest_filter 过滤用例，支持通配符<ul><li>?*-:(:”是或)</li></ul></li><li>–gtest_repeat=[COUNT] 用例执行次数<ul><li>-1为一直执行，默认出错依然执行，但是增加</li></ul></li><li>–gtest_color=(yes/no/auto) 输出颜色</li><li>–gtest_print_time 打印执行时间</li><li>–gtest_output=后缀:路径\文件名</li><li>–gtest_break_on_failure 则出错后停止</li><li>–gtest_throw_on_failure 失败抛异常</li><li>–gtest_catch_exceptions 是否捕捉异常，只在Win有效</li></ul><h3 id="Gtest断言"><a href="#Gtest断言" class="headerlink" title="Gtest断言"></a>Gtest断言</h3><p>ASSERT_系列：如果当前点检测失败则退出当前测试<br>EXPECT_系列：如果当前点检测失败则继续往下执行</p><ul><li>*_TRUE(condition) 条件为true则通过</li><li>*_FALSE(condition) 条件为false则通过</li><li>*_EQ(expected, actual) ==</li><li>*_NE(val1, val2) !=</li><li>*_LT(val1, val2) &lt;</li><li>*_LE(val1, val2) &lt;=</li><li>*_GT(val1, val2) &gt;</li><li>*_GE(val1, val2) &gt;=</li><li><em>_STREQ(expected_str, actual_str) == 接收char </em>  wchar *</li><li>*_STRNE(str1, str2) !=</li><li><em>_STRCASEEQ(expected_str, actual_str) 忽略大小写== ,只接收char </em></li><li><p><em>_STRCASENE(str1, str2) 忽略大小写!= ,只接收char </em></p></li><li><p>*_THROW(statement, exception_type) 语句抛出指定类型的异常</p></li><li>*_ANY_THROW(statement) 抛出任何异常</li><li><p>*_NO_THROW(statement) 不抛出</p></li><li><p>*_FLOAT_EQ(expected, actual) 浮点对比</p></li><li>*_DOUBLE_EQ(expected, actual)</li><li><p>*_NEAR(val1, val2, abs_error) 近似对比</p></li><li><p>*_PRED1(pred1, val1) pred1表示函数名，val1是参数，验证返回值，最多可以到5，传5个参数。</p></li><li><p>*_PRED_FORMAT1(pred_format1, val1) 错误时可自定义输出，函数返回值 return testing::AssertionFailure(testring::Message())</p></li><li><p>*_HRESULT_SUCCEEDED(expression) 表达式是成功的</p></li><li><p>*_HRESULT_FAILED(expression)</p></li><li><p>SUCCEED() 用例成功，不往下走</p></li><li>FAIL() 用例失败，不往下走</li><li>ADD_FAILURE() 失败，但是往下走</li><li><p>testing::StaticAssertTypeEq&lt;int, T&gt; 判断模板是否为int</p></li><li><p><em>_DEATH(statement, regex) 语句crash，其regex匹配stderr中内容，实现其实就是调用了 </em>_EXIT</p></li><li>*_DEATH_IF_SUPPORTED 系统不支持则不执行</li><li>*_EXIT(statement, predicate, regex) 其中predicate必须是接收int返回bool，可用系统<ul><li>testing::ExitedWithCode(exit_code)如果程序正常退出并且退出码与exit_code相同则返回true</li><li>testing::KilledBySignal(signal_number) 被signal_number杀掉则为true</li></ul></li><li><em>_DEBUG_DEATH(statement, regex) 在Debug中 实际是调用 </em>_DEATH，否则只是执行statement</li></ul><h5 id="死亡测试注意"><a href="#死亡测试注意" class="headerlink" title="死亡测试注意"></a>死亡测试注意</h5><ul><li>可以在main中设置，也可以在用例中设置，用例完成会复原。<ul><li>testing::FLAGS_gtest_death_test_style = “fast”;</li><li>testing::FLAGS_gtest_death_test_style = “threadsafe”;</li></ul></li><li>不要在死亡测试用例释放内存，在父进程释放内存，不要在程序中使用内存堆检查</li></ul><h3 id="Gtest事件"><a href="#Gtest事件" class="headerlink" title="Gtest事件"></a>Gtest事件</h3><ul><li>全局事件<ul><li>全局事件需要继承testing::Environment类，实现SetUp和TearDown，类似构造与析构，然后在main中使用testing::AddGlobalTestEnvironment进行注册</li></ul></li><li>TestSuite 每一组用例前后<ul><li>需要继承testing::Test类，实现SetUpTestCase和TearDownTestCase，在该组用例前和结束执行</li></ul></li><li>TestCase 每个用例前后<ul><li>同上，实现SetUp()和TearDown()即可，在每个用例前后执行</li></ul></li></ul><h3 id="Gtest测试宏"><a href="#Gtest测试宏" class="headerlink" title="Gtest测试宏"></a>Gtest测试宏</h3><h4 id="TEST-test-suite-name-test-name-宏"><a href="#TEST-test-suite-name-test-name-宏" class="headerlink" title="TEST(test_suite_name,test_name)宏"></a>TEST(test_suite_name,test_name)宏</h4><p>一个测试特例，套件名和样例名，构成一个测试用例，不能有_,因为会将其设置为专有的类名</p><h4 id="TEST-F-test-fixture-test-name-宏"><a href="#TEST-F-test-fixture-test-name-宏" class="headerlink" title="TEST_F(test_fixture,test_name)宏"></a>TEST_F(test_fixture,test_name)宏</h4><p>结合testing::Test使用</p><h4 id="TEST-P宏"><a href="#TEST-P宏" class="headerlink" title="TEST_P宏"></a>TEST_P宏</h4><p>配合继承testing::TestWithParam<t>的类使用,其中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestWithParam</span>:</span><span class="keyword">public</span> Test,<span class="keyword">public</span> WithParamInterface&lt;T&gt;&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> T&amp; <span class="title">GetParam</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部的参数由友元类修改，所以Getparam()可以获得新属性</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>&gt;  <span class="title">friend</span> <span class="title">class</span> <span class="title">internal</span>:</span>:ParameterizedTestFactor;</span><br><span class="line"></span><br><span class="line">INSTANTIATE_TEST_CASE_P(test_pre_name,继承TestWithParam的类名,testing::Values());</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中第三个可以使用Range(begin,end[,step])</span></span><br><span class="line"><span class="comment">//Values(v1,v2...,vN)</span></span><br><span class="line"><span class="comment">//ValuesIn(container) and ValuesIn(begin,end) 从容器或者迭代器取</span></span><br><span class="line"><span class="comment">//Bool() true和false</span></span><br><span class="line"><span class="comment">//Combine(g1,g2,...,gN) 排列组合传入，参数是Tuple</span></span><br></pre></td></tr></table></figure></t></p><h4 id="模板参数化"><a href="#模板参数化" class="headerlink" title="模板参数化"></a>模板参数化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateClass</span> :</span> <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> testing::Types&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; MyTypes;</span><br><span class="line">TYPED_TEST_SUITE(TemplateClass, MyTypes);<span class="comment">//验证TemplateClass是否支持MyTypes这些类型</span></span><br><span class="line">TYPED_TEST(TemplateClass,TestName)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">TYPED_TEST_CASE_P(TemplateClass)</span><br><span class="line">TYPED_TEST_P(TemplateClass,TestName)</span><br><span class="line">REGISTER_TYPED_TEST_CASE_P(TemplateClass,TestName,...)</span><br><span class="line">INSTANTIATE_TYPED_TEST_CASE_P(test_pre_name, TemplateClass, MyTypes)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">GTest接口使用小结</summary>
    
    
    
    <category term="无处安放" scheme="http://bugnull.com/categories/无处安放/"/>
    
    
    <category term="Cpp基础" scheme="http://bugnull.com/tags/Cpp基础/"/>
    
    <category term="Library" scheme="http://bugnull.com/tags/Library/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://bugnull.com/uncategorized/"/>
    <id>http://bugnull.com/uncategorized/</id>
    <published>2023-03-04T12:27:40.310Z</published>
    <updated>2022-11-06T15:33:20.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>CMake小结</title>
    <link href="http://bugnull.com/%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE/cmake%E5%B0%8F%E7%BB%93/"/>
    <id>http://bugnull.com/%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE/cmake%E5%B0%8F%E7%BB%93/</id>
    <published>2023-03-04T12:27:40.300Z</published>
    <updated>2022-09-11T08:23:06.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmake -B build -DCMAKE_BUILD_TYPE=Release</span><br><span class="line">cmake --build build -j4</span><br><span class="line">cmake --build build --<span class="keyword">target</span> <span class="keyword">install</span></span><br><span class="line"></span><br><span class="line">如上设置了-D 当不清除Cache时，下次不加-D，也是Release</span><br><span class="line">-G 指定构建系统生成器 在cmake --help里面可以看到</span><br><span class="line">动态库链接静态库，需要开启PIC  <span class="keyword">set</span>(CMAKE_POSITION_INDEPENDENT_CODE <span class="keyword">ON</span>)</span><br><span class="line">或者 <span class="keyword">set_property</span>(TRGET lib PROPERTY POSITION_INDEPENDENT_CODE <span class="keyword">ON</span>)</span><br><span class="line">设定<span class="keyword">find_package</span>路径，把路径加入CMAKE_MODULE_PATH、查看包搜索路径，如Qt会找Qt5_DIR，把路径放这里也好使、环境变量的Qt5_DIR也行</span><br><span class="line">生成器表达式语法：$&lt;$&lt;类型:值&gt;:为真时的表达式&gt;</span><br><span class="line">比如 $&lt;$&lt;PLATFORM_ID:Windows,ABC&gt;:MY_NAME=<span class="string">"Bill Gates"</span>&gt;</span><br><span class="line">在 Windows或者ABC 平台上会变为 MY_NAME=<span class="string">"Bill Gates"</span></span><br><span class="line"><span class="keyword">set</span>(abc HELLO)</span><br><span class="line"><span class="keyword">set</span>(HELLO ccc)</span><br><span class="line"><span class="keyword">if</span>(abc MATCH HELLO)  done</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;abc&#125;</span> MATCH HELLO)  no  其会展开为HELLO变量 再变成ccc</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"$&#123;abc&#125;"</span> MATCH HELLO) done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__declspec(dllexport) 导出</span><br><span class="line">__declspec(dllimport) 导入</span><br><span class="line"></span><br><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;) <span class="comment">#搜索dir目录内文件所有源文件，将列表写到var里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>()  <span class="comment">#对列表操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(&lt;<span class="keyword">file</span>|module&gt; [OPTIONAL] [RESULT_VARIABLE &lt;var&gt;]</span><br><span class="line">                      [NO_POLICY_SCOPE]) <span class="comment">#导入CMake代码。OPTIONAL，文件不存在不报错，RESULT_VARIABLE &lt;var&gt;，var将设置为完整文件名，失败为NOTFOUND。</span></span><br><span class="line">                      <span class="comment"># 若指定为module则在CMAKE_MODULE_PATH中找&lt;modulename&gt;.cmake，再去CMake模块路径找。除非文件在CMake内置模块路径中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE]) <span class="comment">#value可以是0或多个，0即unset，多个时使用；分割。PARENT_SCOPE会向上一层传递，当在function中时，会向调用者传递，但是在当前层不生效，不加则会取时生效并向下传递。</span></span><br><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]) <span class="comment">#默认情况下值不会被覆盖，除非使用了FORCE。可以通过GUI界面add entry添加，类似环境变量。</span></span><br><span class="line">    <span class="comment">#BOOL复选框、FILEPATH文件选择框、PATH目录选择框、STRING文本框、STRINGS下拉框、INTERNAL不对外呈现，主要用于运行过程存储，该type意味着使用FORCE</span></span><br><span class="line">    <span class="comment">#docstring文本表示选项摘要</span></span><br><span class="line">    <span class="comment">#缓存值是无法覆盖已经存同名的，除非设置了FORCE。如果条目是通过-Dvar=val创建，则会给其指定类型，而set命令会给予类型。若val是相对路径，set会将其转为绝对路径。</span></span><br><span class="line"><span class="keyword">set</span>(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;]) <span class="comment">#设置环境变量，只影响当前进程，不修改调用者进程和系统变量。CMake中的 [环境变量](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html) 也可以修改。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(read &lt;filename&gt; &lt;variable&gt; [OFFSET &lt;offset&gt;] [LIMIT &lt;max-in&gt;] [HEX]) <span class="comment">#将文件读到var变量中，偏移量、读取长度、16进度读。</span></span><br><span class="line"><span class="keyword">file</span>(STRINGS &lt;filename&gt; &lt;variable&gt; [&lt;options&gt; ...]) <span class="comment">#以ASCII读取到var中，将忽略二进度、回车和\r。LENGTH_MAXMUN &lt;max-len&gt;、LENGTH_MINIMUN &lt;min-len&gt;、LIMIT_COUNT &lt;max-num&gt;限制字符串数量、LIMIT_OUTPUT &lt;max-out&gt;限制var总长度、NEWLINE_CONSUME不忽略换行、NO_HEX_CONVERSION不对16进度转换、REGX &lt;regex&gt;、ENCODING &lt;encoding-type&gt;。</span></span><br><span class="line"><span class="keyword">file</span>(&lt;HASH&gt; &lt;filename&gt; &lt;variable&gt;) <span class="comment">#将文件加密读入到var，HASH支持MD5、SHA!、SHA224、SHA256、SHA384、SHA512、SHA3_224、SHA3_256、SHA3_384、SHA3_512等。</span></span><br><span class="line"><span class="keyword">file</span>(TIMESTAMP &lt;filename&gt; &lt;variable&gt; [&lt;format&gt;] [UTC]) <span class="comment">#读取文件最后修改时间搓，format指定格式。</span></span><br><span class="line"><span class="keyword">file</span>(WRITE &lt;filename&gt; &lt;content&gt; ... ) <span class="comment">#可创建，覆盖定入</span></span><br><span class="line"><span class="keyword">file</span>(APPEND  &lt;filename&gt; &lt;content&gt; ... ) <span class="comment">#可创建，追加</span></span><br><span class="line"><span class="keyword">file</span>(TOUCH [&lt;files&gt; ...]) <span class="comment">#创建空白文件，文件存在只刷新修改时间</span></span><br><span class="line"><span class="keyword">file</span>(TOUCH_NOCREATE [&lt;files&gt; ...]) <span class="comment">#文件不存在，不创建</span></span><br><span class="line"><span class="keyword">file</span>（GENERATE OUTPUT output-<span class="keyword">file</span> &lt;INPUT input-<span class="keyword">file</span>|CONTENT content&gt; [CONDITION expression]) <span class="comment">#在构建时将信息写到文件中，保证是本次构建的内容，仅当CONDITION &lt;expression&gt;为true时，才输出到文件 </span></span><br><span class="line"><span class="keyword">file</span>(GLOB &lt;variable&gt;</span><br><span class="line">     [LIST_DIRECTORIES <span class="keyword">true</span>|<span class="keyword">false</span>] [RELATIVE &lt;path&gt;]</span><br><span class="line">     [&lt;globbing-expressions&gt;...]) <span class="comment">#将当前目录内符合expressions的写到var里，LIST_D...表示是否输出文件夹名，RELATIVE &lt;path&gt;表示是否以相对path为相对路径输出</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE &lt;variable&gt; [FOLLOW_SYMLINKS]</span><br><span class="line">     [LIST_DIRECTORIES <span class="keyword">true</span>|<span class="keyword">false</span>] [RELATIVE &lt;path&gt;]</span><br><span class="line">     [&lt;globbing-expressions&gt;...]) <span class="comment">#FOLLOW_SYMLINKS设定和LIST_DIRECTORIES为true可以遍历子文件夹</span></span><br><span class="line"><span class="keyword">file</span>(RENAME &lt;oldname&gt; &lt;newname&gt;</span><br><span class="line">     [RESULT &lt;result&gt;]</span><br><span class="line">     [NO_REPLACE]) <span class="comment">#重命名</span></span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">REMOVE</span> [&lt;files&gt;...]) <span class="comment">#删除文件</span></span><br><span class="line"><span class="keyword">file</span>(REMOVE_RECURSE [&lt;files&gt;...]) <span class="comment">#会删除指定的文件及子目录，包括非空文件夹</span></span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> [&lt;directories&gt; ...]) <span class="comment">#创建目录</span></span><br><span class="line"><span class="keyword">file</span>(COPY_FILE &lt;oldname&gt; &lt;newname&gt;</span><br><span class="line">     [RESULT &lt;result&gt;]</span><br><span class="line">     [ONLY_IF_DIFFERENT])</span><br><span class="line"><span class="keyword">file</span>(&lt;COPY|<span class="keyword">INSTALL</span>&gt; &lt;files&gt;... DESTINATION &lt;dir&gt;</span><br><span class="line">     [FILE_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">     [DIRECTORY_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">     [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS]</span><br><span class="line">     [FILES_MATCHING]</span><br><span class="line">     [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">     [EXCLUDE] [PERMISSIONS &lt;permissions&gt;...]] [...]) <span class="comment">#OWNER_READO、WNER_WRITE、OWNER_EXECUTE、GROUP_READ、GROUP_WRITE、GROUP_EXECUTE、WORLD_READ、WORLD_WRITE、WORLD_EXECUTE</span></span><br><span class="line"><span class="keyword">file</span>(SIZE &lt;filename&gt; &lt;variable&gt;)</span><br><span class="line"><span class="keyword">file</span>(READ_SYMLINK &lt;linkname&gt; &lt;variable&gt;) <span class="comment">#获取符号文件的路径</span></span><br><span class="line"><span class="keyword">file</span>(CREATE_LINK &lt;original&gt; &lt;linkname&gt;</span><br><span class="line">     [RESULT &lt;result&gt;] [COPY_ON_ERROR] [SYMBOLIC]) <span class="comment">#创建符号链接，默认是硬连接</span></span><br><span class="line"><span class="keyword">file</span>(CHMOD|CHMOD_RECURSE &lt;files&gt;... &lt;directories&gt;...</span><br><span class="line">    [PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">    [FILE_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">    [DIRECTORY_PERMISSIONS &lt;permissions&gt;...]) <span class="comment">#设置权限</span></span><br><span class="line"><span class="keyword">file</span>(REAL_PATH &lt;path&gt; &lt;out-var&gt; [BASE_DIRECTORY &lt;dir&gt;] [EXPAND_TILDE]) <span class="comment">#计算已解析符号链接的现有文件或目录的绝对路径</span></span><br><span class="line"><span class="keyword">file</span>(RELATIVE_PATH &lt;variable&gt; &lt;directory&gt; &lt;<span class="keyword">file</span>&gt;) <span class="comment">#根据file推出相对dir的相对路径</span></span><br><span class="line"><span class="keyword">file</span>(TO_CMAKE_PATH <span class="string">"&lt;path&gt;"</span> &lt;variable&gt;) <span class="comment">#转为CMake格式的路径</span></span><br><span class="line"><span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">"&lt;path&gt;"</span> &lt;variable&gt;) <span class="comment">#转换为特定平台格式的路径</span></span><br><span class="line"><span class="keyword">file</span>(DOWNLOAD &lt;url&gt; [&lt;<span class="keyword">file</span>&gt;] [&lt;options&gt;...]) <span class="comment">#从指定URL下载文件</span></span><br><span class="line"><span class="keyword">file</span>(UPLOAD   &lt;<span class="keyword">file</span>&gt; &lt;url&gt; [&lt;options&gt;...]) <span class="comment">#上传</span></span><br><span class="line"><span class="keyword">file</span>(LOCK &lt;path&gt; [DIRECTORY] [RELEASE]</span><br><span class="line">     [GUARD &lt;<span class="keyword">FUNCTION</span>|<span class="keyword">FILE</span>|PROCESS&gt;]</span><br><span class="line">     [RESULT_VARIABLE &lt;variable&gt;]</span><br><span class="line">     [TIMEOUT &lt;seconds&gt;]) <span class="comment">#对指定文件上锁</span></span><br><span class="line"><span class="keyword">file</span>(ARCHIVE_CREATE OUTPUT &lt;archive&gt;</span><br><span class="line">  PATHS &lt;paths&gt;...</span><br><span class="line">  [FORMAT &lt;format&gt;]</span><br><span class="line">  [COMPRESSION &lt;compression&gt; [COMPRESSION_LEVEL &lt;compression-level&gt;]]</span><br><span class="line">  [MTIME &lt;mtime&gt;]</span><br><span class="line">  [VERBOSE]) <span class="comment">#根据 &lt;paths&gt; 中的文件或目录 创建归档文件 &lt;archive&gt;。FORMAT 指定归档格式，支持的值为 7zip、gnutar、pax、paxr、raw 和 zip，默认格式为 paxr</span></span><br><span class="line"><span class="keyword">file</span>(ARCHIVE_EXTRACT INPUT &lt;archive&gt;</span><br><span class="line">  [DESTINATION &lt;dir&gt;]</span><br><span class="line">  [PATTERNS &lt;patterns&gt;...]</span><br><span class="line">  [LIST_ONLY]</span><br><span class="line">  [VERBOSE]</span><br><span class="line">  [TOUCH]) <span class="comment">#提取归档文件 &lt;archive&gt;，并输出到 DESTINATION 目录中，如果目录不存在，它将被创建，默认情况下输出目录为 CMAKE_CURRENT_BINARY_DIR</span></span><br></pre></td></tr></table></figure><p><img src="/无处安放/cmake小结/Snipaste_2022-09-04_11-47-58.png" alt=" [file GENERATE图片引用](https://blog.csdn.net/weixin_42730667/article/details/122568165) "></p><p><img src="/无处安放/cmake小结/Snipaste_2022-09-04_19-26-33.png" alt=" [file DownLoad图片引用](https://www.jianshu.com/p/ed151fdcf473) "></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUED_FROM_ALL] [&lt;source&gt;...]) <span class="comment">#使用指定的source生成对应平台的库。static、shared、module则表示类型，module则是在使用时使用dlopen动态加载的模块。</span></span><br><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; OBJECT [&lt;source&gt;...]) <span class="comment">#添加OBJECT库，可以使用$&lt;TARGET_OBJECTS:objlib&gt;方式使用，感觉就是一个集合</span></span><br><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; INTERFACE) <span class="comment">#其不编译也不生成东西，一般用于携带属性传递</span></span><br><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; &lt;type&gt; IMPORTED [GLOBAL]) <span class="comment">#导入一个已经存在的库，type为STATIC, SHARED, MODULE, UNKNOWN其一，通过IMPORTED导入的类，其属性以IMPORTED_开头，否则为INTERFACE_开头。IMPORTED_LOCATION标明library硬盘位置，可加DEBUG/RELEASE进行具体；IMPORTED_OBJECTS标明对象Library在硬盘的位置，也可加...。PUBLIC_HEADER保存install头文件目录</span></span><br><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; ALIAS &lt;<span class="keyword">target</span>&gt;) <span class="comment">#设置别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]</span><br><span class="line">               [EXCLUDE_FROM_ALL]</span><br><span class="line">               [source1] [source2 ...]) <span class="comment">#WIN32将WIN32_EXECUTABLE设置为true，其会创建一个使用WinMain()入口的GUI可执行文件，而不是控制台应用程序。MACOSX_BUNDLE将在macOS或者iOS设置为true，使其可以在Finder启动GUI可执行文件。EXCLUDE_FORM_ALL表示可执行文件会排除在alltarget列表外，当执行默认的make或者nmake时，不会编译，需要make name手动指明才会编译。</span></span><br><span class="line"><span class="keyword">add_executable</span>(&lt;name&gt; IMPORTED [GLOBAL]) <span class="comment">#从外部导入可执行文件，不指定GLOBAL则只向下传递，其属性IMPORTED会设置为true。</span></span><br><span class="line"><span class="keyword">add_executable</span>(&lt;name&gt; ALIAS &lt;<span class="keyword">target</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_sources</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) <span class="comment">#给target添加编译文件 按执行顺序添加文件</span></span><br><span class="line"><span class="keyword">target_sources</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt;</span><br><span class="line">   [FILE_SET &lt;<span class="keyword">set</span>&gt; [TYPE &lt;type&gt;] [BASE_DIRS &lt;dirs&gt;...] [FILES &lt;files&gt;...]]...</span><br><span class="line">  ]...) <span class="comment">#每个target有多个文件集，文件集有自己的属性。会给PRIVATE和PUBLIC的文件设置为源文件，HEADERS文件设置HEADER_FILE_ONLY为true。FILE_SET &lt;set&gt;，文件集名，有预留的是HEADERS，然后不能以_和大写字母开头。TYPE &lt;type&gt;，若为HEADERS则可省，否则加。BASE_DIRS &lt;dirs&gt;...，文件集目录列表，首次创建可填CMAKE_CURRENT_SOURCE_DIR。FILES &lt;files&gt;...，文件列表，文件要位于目录列表中。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) <span class="comment">#给target添加编译定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; [SYSTEM] [AFTER|BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) <span class="comment">#AFTER、BEFORE 添加到列表的前面或者后面，默认后面，CMAKE_INCLUDE_DIRECTORIES_BEFORE可以修改默认值；SYSTEM则表示指定目录为系统目录，仅当前CMakeList.txt生效</span></span><br><span class="line">  <span class="comment">#INTERFACE、PUBLIC填充INTERFACE_INCLUDE_DIRECTORIES属性，而PRIVATE和PUBLIC填充填充INCLUDE_DIRECTORIES属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) <span class="comment">#添加头文件搜索目录 相当于-l 从当前文件开始向下传递</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">link_directories</span>([AFTER|BEFORE] directory1 [directory2 ...]) <span class="comment">#添加库搜索目录 相当于-L  用在add_executable之前</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">link_libraries</span>([item1 [item2 [...]]]</span><br><span class="line">               [[debug|optimized|general] &lt;item&gt;] ...) <span class="comment">#添加库文件路径 全路径包括库名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt; ... &lt;item&gt;... ...) <span class="comment">#用在add_executable之后</span></span><br><span class="line"><span class="comment">#item 可能是library target name、full path to a library file、plain library name、link flag、generator expression、A debug, optimized, or general keyword immediately followed by another &lt;item&gt;。 ex:  hello libhello.a libhello.so -lhello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">get_filename_component</span>(&lt;var&gt; &lt;FileName&gt; &lt;mode&gt; [CACHE]) <span class="comment">#根据mode获取文件路径中指定项到var中 3.20以后被cmake_path取代</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(&lt;variable&gt; <span class="string">"&lt;help_text&gt;"</span> [value]) <span class="comment">#提供用户可选的布尔选项，若var已经定义或者在CACHE里，则不生效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">configure_file</span>(&lt;input&gt; &lt;output&gt;</span><br><span class="line">               [NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS |</span><br><span class="line">                FILE_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]</span><br><span class="line">               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ]) 将文件复制到其它位置并修改内容，将input文件中@var@或者<span class="variable">$&#123;var&#125;</span>替换为cmake指定的值，<span class="comment">#cmakedefine var关键字替换成#define var或者#undef var，取决是否定义了var；input，一定是要文件；output，可以是路径，那就会使用intput的名字；COPYONLY，直接拷贝，啥也不干；ESCAPE_QUOTES，不转义；@ONLY，只替换@，不替换$；NEWLINE_STYLE，指定Output换行风格。</span></span><br><span class="line"></span><br><span class="line">需要先<span class="keyword">include</span>(CheckCXXCompilerFlag)</span><br><span class="line">check_cxx_compiler_flag(&lt;flag&gt; &lt;var&gt;) 检测编译器是否支持CXX，结果在var里</span><br><span class="line"></span><br><span class="line"><span class="keyword">mark_as_advanced</span>([CLEAR|FORCE] &lt;var1&gt; ...) <span class="comment">#清除或者标记var变量为advanced变量，advance变量不会显示在GUI中，除非advanced选项开启</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">source_group</span>(&lt;name&gt; [FILES &lt;src&gt;...] [REGULAR_EXPRESSION &lt;regex&gt;])</span><br><span class="line"><span class="keyword">source_group</span>(TREE &lt;root&gt; [PREFIX &lt;prefix&gt;] [FILES &lt;src&gt;...]) <span class="comment">#给IDE的源码分组，TREE，会根据root路径将src转为相对路径，自动的将文件结构分出来。PREFIX，TREE会放在该group里，可以使用\\指定子group。REGULAR_EXPRESSION，一个文件只会加入最后一个符合条件的group，如果没有则优先与最后一个组。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set_property</span>(&lt;GLOBAL                      |</span><br><span class="line">              DIRECTORY [&lt;dir&gt;]           |</span><br><span class="line">              <span class="keyword">TARGET</span>    [&lt;target1&gt; ...]   |</span><br><span class="line">              SOURCE    [&lt;src1&gt; ...]</span><br><span class="line">                        [DIRECTORY &lt;dirs&gt; ...]</span><br><span class="line">                        [TARGET_DIRECTORY &lt;targets&gt; ...] |</span><br><span class="line">              <span class="keyword">INSTALL</span>   [&lt;file1&gt; ...]     |</span><br><span class="line">              <span class="keyword">TEST</span>      [&lt;test1&gt; ...]     |</span><br><span class="line">              CACHE     [&lt;entry1&gt; ...]    &gt;</span><br><span class="line">             [APPEND] [APPEND_STRING]</span><br><span class="line">             PROPERTY &lt;name&gt; [&lt;value1&gt; ...]) <span class="comment">#GLOBAL，属性全局有效；DIRECTORY，在指定目录有效，类似set_directory_proerties；TARGET，设置target属性，类似set_target_properties；SOURCE，指定属性对应多个源文件，默认仅对同一目录中的目标可见，类似set_source_files_properties，DIRECTORY，源文件在每个dirs有效，dirs必须已知，TARGET_DIRECTORY在指定的targets中有效，targets必须有效；INSTALL，属性对应多个安装文件路径；TEST，对应多个测试，类似set_tests_properties；CACHE，对应缓存条目。APPEND，以列表形式附加到属性后面。APPEND_STRING，以字符串形式添加到属性后面。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">get_property</span>(&lt;variable&gt;</span><br><span class="line">             &lt;GLOBAL             |</span><br><span class="line">              DIRECTORY [&lt;dir&gt;]  |</span><br><span class="line">              <span class="keyword">TARGET</span>    &lt;<span class="keyword">target</span>&gt; |</span><br><span class="line">              SOURCE    &lt;source&gt;</span><br><span class="line">                        [DIRECTORY &lt;dir&gt; | TARGET_DIRECTORY &lt;<span class="keyword">target</span>&gt;] |</span><br><span class="line">              <span class="keyword">INSTALL</span>   &lt;<span class="keyword">file</span>&gt;   |</span><br><span class="line">              <span class="keyword">TEST</span>      &lt;<span class="keyword">test</span>&gt;   |</span><br><span class="line">              CACHE     &lt;entry&gt;  |</span><br><span class="line">              VARIABLE           &gt;</span><br><span class="line">             PROPERTY &lt;name&gt;</span><br><span class="line">             [<span class="keyword">SET</span> | <span class="keyword">DEFINED</span> | BRIEF_DOCS | FULL_DOCS]) <span class="comment">#VARIABLE，范围内唯一，不接收名字。SET，变量设为布尔，表示是否设置了属性；DEFINED，变量设置为布尔，表示属性是否定义；BRIEF_DOCS | FULL_DOCS，设置为字符串，包含请示的属性，没有会写NOTFOUND。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(target1 target2 ...</span><br><span class="line">                      PROPERTIES prop1 value1</span><br><span class="line">                      prop2 value2 ...) <span class="comment">#同时设置多个target的多个属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">get_target_property</span>(&lt;VAR&gt; <span class="keyword">target</span> property) <span class="comment">#获取target属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) <span class="comment">#添加子目录进行构建，source_dir，子目录CMakeList.txt的位置；binary_dir，输出目录；EXCLUDE_FROM_ALL，是否排除自动构建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(&lt;<span class="keyword">option</span>&gt; ...) <span class="comment">#添加选项到编译源文件，对当前目录的targets和向下有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_compile_options</span>(&lt;<span class="keyword">target</span>&gt; [BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...]) <span class="comment">#给target添加编译参数，BEFORE，放到所有属性前，默认是追加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_definitions</span>(-DFOO -DBAR ...) <span class="comment">#将定义添加到编译器命令行，不管写在前后都生效，并向下目录传递，相当于-D</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_dependencies</span>(&lt;<span class="keyword">target</span>&gt; [&lt;<span class="keyword">target</span>-dependency&gt;]...) <span class="comment">#确保依赖的target在自己前生成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>([&lt;mode&gt;] <span class="string">"message text"</span> ...) <span class="comment">#FATAL_ERROR，会中断编译；SEND_ERROR，继续处理，但是会跳过生成；WARNING，发出警告，继续处理。AUTHOR_WARNING，警告dev，继续处理；DEPRECATION，根据CMAKE_ERROR_DEPRECATED或者CMAKE_WARN_DEPRECATED状态决定是警告还是错误；(none) or NOTICE，重要标准错误；STATUS，信息；VERBOSE，更详细的信息；DEBUG，项目开发人员；TRACE，临时信息。</span></span><br><span class="line"><span class="keyword">message</span>(&lt;checkState&gt; <span class="string">"message text"</span> ...) <span class="comment">#CHECK_START，记录将要执行检查的消息；CHECK_PASS，记录一个成功结果；CHECK_FAIL，记录一个失败结果。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt; [&lt;language-name&gt;...]) <span class="comment">#指定cmake工程名，&lt;language-name&gt; 语言</span></span><br><span class="line"><span class="keyword">project</span>(&lt;<span class="keyword">PROJECT</span>-NAME&gt;</span><br><span class="line">        [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class="line">        [DESCRIPTION &lt;<span class="keyword">project</span>-description-<span class="keyword">string</span>&gt;]</span><br><span class="line">        [HOMEPAGE_URL &lt;url-<span class="keyword">string</span>&gt;]</span><br><span class="line">        [LANGUAGES &lt;language-name&gt;...]) <span class="comment">#VERSION，版本；DESCRIPTION，描述；HOMEPAGE_URL，主页URL；LANGUAGES，语言。</span></span><br><span class="line">当指定了<span class="keyword">project</span>，会自动定义如下变量，则PROJECT_NAME工程名；PROJECT_SOURCE_DIR源码路径；&lt;<span class="keyword">PROJECT</span>-NAME&gt;_SOURCE_DIR源码路径，与前者区别就是后者是指定工程的，前者是当前工程的；PROJECT_BINARY_DIR二进制路径；&lt;<span class="keyword">PROJECT</span>-NAME&gt;_BINARY_DIR同意思；CMAKE_PROJECT_NAME顶层工程名。 指定了VERSION，会定义出一堆PROJECT_VERSION*和&lt;<span class="keyword">PROJECT</span>-NAME&gt;_VERSION*。其它两个也一样。目前支持C、CXX、CUDA、OBJC、OBJCXX、Fortran、ASM，不指定则是C和CXX，指定为NONE或者LANGUAGES则表示不支持任何语言。检测CMAKE_&lt;LANGUAGES&gt;_COMPILER指定编译器是否存在。多次调用，则以最近一次为准。</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_target</span>(Name [ALL] [command1 [args1...]]</span><br><span class="line">                  [<span class="keyword">COMMAND</span> command2 [args2...] ...]</span><br><span class="line">                  [DEPENDS depend depend depend ... ]</span><br><span class="line">                  [BYPRODUCTS [files...]]</span><br><span class="line">                  [WORKING_DIRECTORY dir]</span><br><span class="line">                  [COMMENT comment]</span><br><span class="line">                  [JOB_POOL job_pool]</span><br><span class="line">                  [VERBATIM] [USES_TERMINAL]</span><br><span class="line">                  [COMMAND_EXPAND_LISTS]</span><br><span class="line">                  [SOURCES src1 [src2...]]) <span class="comment">#根据命令生成一个target，且默认不在all target中，目标没有输出文件。ALL，加入all target；DEPENDS，依赖其它target或者文件；COMMAND，执行的命令，可以使用configure_file或者GENERATE生成脚本再执行；BYPRODUCTS，声明target随之生成的文件，需要有COMMAND命令否则报错；WORKING_DIRECTORY，修改当前COMMAND执行命令的目录；COMMENT，构建时执行COMMAND前的消息；JOB_POOL，指定一个池给Ninja生成器，VERBATIM，所有参数都根据构建工具转义，以保证COMMAND正确接收参数，否则行为依赖平台行为；USES_TERMINAL，直接访问终端的权限；COMMAND_EXPAND_LISTS，参数列表将展开，包括生成器表达式列表；SOURCES，将文件附加到目标中，在IDE中显示。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_command</span>(OUTPUT output1 [output2 ...]</span><br><span class="line">                   <span class="keyword">COMMAND</span> command1 [ARGS] [args1...]</span><br><span class="line">                   [<span class="keyword">COMMAND</span> command2 [ARGS] [args2...] ...]</span><br><span class="line">                   [MAIN_DEPENDENCY depend]</span><br><span class="line">                   [DEPENDS [depends...]]</span><br><span class="line">                   [BYPRODUCTS [files...]]</span><br><span class="line">                   [IMPLICIT_DEPENDS &lt;lang1&gt; depend1</span><br><span class="line">                                    [&lt;lang2&gt; depend2] ...]</span><br><span class="line">                   [WORKING_DIRECTORY dir]</span><br><span class="line">                   [COMMENT comment]</span><br><span class="line">                   [DEPFILE depfile]</span><br><span class="line">                   [JOB_POOL job_pool]</span><br><span class="line">                   [VERBATIM] [APPEND] [USES_TERMINAL]</span><br><span class="line">                   [COMMAND_EXPAND_LISTS]) <span class="comment">#在生成的构建系统中添加自定义构建规则，当没有output1或者DEPENDS的东西发生变化时，则生成；MAIN_DEPENDENCY，指定主要输入文件，源文件只能作为一个命令的主依赖项；IMPLICIT_DEPENDS，请求扫描输入文件的隐式依赖关系；DEPFILE，为Ninja生成器制定一个depfile文件；APPEND将其追加到第一个自定义输出命令；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> &lt;<span class="keyword">target</span>&gt;</span><br><span class="line">                   PRE_BUILD | PRE_LINK | POST_BUILD</span><br><span class="line">                   <span class="keyword">COMMAND</span> command1 [ARGS] [args1...]</span><br><span class="line">                   [<span class="keyword">COMMAND</span> command2 [ARGS] [args2...] ...]</span><br><span class="line">                   [BYPRODUCTS [files...]]</span><br><span class="line">                   [WORKING_DIRECTORY dir]</span><br><span class="line">                   [COMMENT comment]</span><br><span class="line">                   [VERBATIM] [USES_TERMINAL]</span><br><span class="line">                   [COMMAND_EXPAND_LISTS]) <span class="comment">#为目标添加自定义命令，目标构建时执行，PRE_BUILD | PRE_LINK | POST_BUILD表示命令执行相对构建的时机</span></span><br><span class="line"></span><br><span class="line">&gt; 当<span class="keyword">add_custom_target</span>所要生成的<span class="keyword">target</span>依赖<span class="keyword">add_custom_command</span>所生成的文件时，这个文件就是一个纽带；<span class="keyword">add_custom_command</span>命令输出的OUTPUT文件和命令里的<span class="keyword">command</span>之间的关系是：每当这个文件需要被重新生成时，都会执行这段<span class="keyword">command</span>；开始构建<span class="keyword">target</span>，依赖<span class="keyword">add_custom_command</span>的输出文件，再查看其是否构建，其构建就会执行<span class="keyword">COMMAND</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> &lt;cmd1&gt; [&lt;arguments&gt;]</span><br><span class="line">                [<span class="keyword">COMMAND</span> &lt;cmd2&gt; [&lt;arguments&gt;]]...</span><br><span class="line">                [WORKING_DIRECTORY &lt;directory&gt;]</span><br><span class="line">                [TIMEOUT &lt;seconds&gt;]</span><br><span class="line">                [RESULT_VARIABLE &lt;variable&gt;]</span><br><span class="line">                [RESULTS_VARIABLE &lt;variable&gt;]</span><br><span class="line">                [OUTPUT_VARIABLE &lt;variable&gt;]</span><br><span class="line">                [ERROR_VARIABLE &lt;variable&gt;]</span><br><span class="line">                [INPUT_FILE &lt;<span class="keyword">file</span>&gt;]</span><br><span class="line">                [OUTPUT_FILE &lt;<span class="keyword">file</span>&gt;]</span><br><span class="line">                [ERROR_FILE &lt;<span class="keyword">file</span>&gt;]</span><br><span class="line">                [OUTPUT_QUIET]</span><br><span class="line">                [ERROR_QUIET]</span><br><span class="line">                [COMMAND_ECHO &lt;where&gt;]</span><br><span class="line">                [OUTPUT_STRIP_TRAILING_WHITESPACE]</span><br><span class="line">                [ERROR_STRIP_TRAILING_WHITESPACE]</span><br><span class="line">                [ENCODING &lt;name&gt;]</span><br><span class="line">                [ECHO_OUTPUT_VARIABLE]</span><br><span class="line">                [ECHO_ERROR_VARIABLE]</span><br><span class="line">                [COMMAND_ERROR_IS_FATAL &lt;ANY|LAST&gt;]) <span class="comment">#命令作为管道同时执行，其输出管道作为下个管道的输入，共享一个错误管道。COMMAND，子进程命令行，CMake使用API直接执行子进程，中间不能使用shell脚本，像重定义等操作符都当普通参数；WORKING_DIRECTORY，指定子进程的工作目录；TIMEOUT，超时时间；RESULT_VARIABLE，执行进程的返回结果，最后一个子进程整数或者错误描述字符串；RESULTS_VARIABLE，接收第条命令返回结果；OUTPUT_VARIABLE，ERROR_VARIABLE，设置为输出管道和错误管道的内容，若命名相同，则输出将按生成的顺序合并；INPUT_FILE, OUTPUT_FILE, ERROR_FILE，第一个标准输入名，最后一个标准输出名，所有的标准错误名；OUTPUT_QUIET, ERROR_QUIET，输出和错误将忽略；COMMAND_ECHO &lt;where&gt;重置命令到指定标准输出，如STDERR、STDOUT、NONE；OUTPUT_STRIP_TRAILING_WHITESPACE、ERROR_STRIP_TRAILING_WHITESPACE删除输出空白符；ENCODING &lt;name&gt;，在win上指定解码方式，NONE、AUTO、ANSI、OEM、UTF8、UTF-8；ECHO_OUTPUT_VARIABLE, ECHO_ERROR_VARIABLE，不会专门重定向到配置的变量，将发送到配置的变量中和标准输出或错误中；COMMAND_ERROR_IS_FATAL &lt;ANY|LAST&gt;，决定出错时的行为ANY出错则停止报错，LAST则只看最后一个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span></span><br><span class="line">目的是帮助我们调用对应的cmake文件，导入某个库，这个cmake文件是官方、安装、自行编写的，其格式为Find&lt;lib_name&gt;.cmake、。一般会产生&lt;lib_name&gt;_FOUND、&lt;lib_name&gt;_INCLUDE_DIR、&lt;lib_name&gt;_INCLUDES、&lt;lib_name&gt;_LIBRARY、&lt;lib_name&gt;_LIBRARIES，需要根据cmake文件中实现决定，并不统一。其引入模式分为两种，Module和Config，其中Module是从CMAKE_MODULE_PATH和cmake安装路径/Modules中，找的是Find&lt;lib_name&gt;.cmake；Config找的是&lt;lib_name&gt;Config.cmake或&lt;lib_name&gt;-config.cmake，其一般是通过安装添加到/usr/local/lib/cmake/...目录的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(&lt;PackageName&gt; [version] [EXACT] [QUIET] [MODULE]</span><br><span class="line">             [REQUIRED] [[COMPONENTS] [components...]]</span><br><span class="line">             [OPTIONAL_COMPONENTS components...]</span><br><span class="line">             [REGISTRY_VIEW  (<span class="number">64</span>|<span class="number">32</span>|<span class="number">64</span>_32|<span class="number">32</span>_64|HOST|<span class="keyword">TARGET</span>|BOTH)]</span><br><span class="line">             [GLOBAL]</span><br><span class="line">             [NO_POLICY_SCOPE]</span><br><span class="line">             [BYPASS_PROVIDER]) <span class="comment">#MODULE，只在该模式找；version，找的版本；EXACT，查找的版本要精确匹配；QUIET，找到包时，不输出信息；REQUIRED，找不到会终止；COMPONENTS，要查找的子组件；OPTIONAL_COMPONENTS，可选组件；REGISTRY_VIEW，在win中怎么查询注册表；GLOBAL，将找到的目标设为全局可见；NO_POLICY_SCOPE；BYPASS_PROVIDER，可以直接调用find_package内置的实现，防止自调用；</span></span><br><span class="line">             CONFIG|NO_MODULE，指定搜索模式；NAMES使用该名为lib_name名；PATHS/HINTS，Config模式下，搜索的路径；NO_XXX_PATH，Config模式下，忽略的路径。</span><br><span class="line">默认优先用MODULE模式，CMAKE_FIND_PACKAGE_PREFER_CONFIG可以更换。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CMake语法小记</summary>
    
    
    
    <category term="无处安放" scheme="http://bugnull.com/categories/无处安放/"/>
    
    
    <category term="CMake" scheme="http://bugnull.com/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>Git小结</title>
    <link href="http://bugnull.com/%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE/git%E5%B0%8F%E7%BB%93/"/>
    <id>http://bugnull.com/%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE/git%E5%B0%8F%E7%BB%93/</id>
    <published>2023-03-04T12:27:40.300Z</published>
    <updated>2022-11-06T15:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git小结"><a href="#Git小结" class="headerlink" title="Git小结"></a>Git小结</h3><h4 id="集中式版本控制"><a href="#集中式版本控制" class="headerlink" title="集中式版本控制"></a>集中式版本控制</h4><p>SVN所有东西都存在服务器，不连网不能同步和切换，需要定期备份。</p><h4 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h4><p>Git，每个人保存的都是所有版本</p><h4 id="git组成部分"><a href="#git组成部分" class="headerlink" title="git组成部分"></a>git组成部分</h4><p>工作区 –add-&gt; 暂存区 –commit-&gt; 本地仓库 –push-&gt; 远程<br>工作区 &lt;-checkout– 暂存区 &lt;-reset– 本地仓库 &lt;-fetch/clone– 远程<br>工作区 &lt;-checkout HEAD– 本地仓库<br>工作区 &lt;-pull– 远程</p><h4 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git config </span><br><span class="line"></span><br><span class="line">--local --global --system  配置影响的范围，本仓库、本用户、本系统</span><br><span class="line"></span><br><span class="line">不加后面具体值表示查看</span><br><span class="line">--list 查看config信息</span><br><span class="line">user.name &quot;&quot; 用户名</span><br><span class="line">user.email &quot;&quot; 用户邮箱</span><br><span class="line">core.autocrlf true\input\false 提交为lf取出改为crlf、提交改为lf、什么也不改</span><br><span class="line">core.safecrlf true\false\warn 拒绝包含混合的文件、允许、给予警告</span><br><span class="line">credential.helper store --file .m_credentials 保存密码存证，Push到https连接时，可不输入密码，--file后面是目录地址</span><br><span class="line">alias 别名 alias.ci &apos;commit&apos; 以后可以用ci表示commit  后面不是git命令 可以用!表示，如&apos;!gitk&apos;</span><br><span class="line">https.proxy http://127.0.0.1:1080 和 --unset https.proxy 设置和取消代理</span><br></pre></td></tr></table></figure><h4 id="git常用"><a href="#git常用" class="headerlink" title="git常用"></a>git常用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HEAD 最后的提交</span><br><span class="line">HEAD^ 倒数第二提交</span><br><span class="line">HEAD^^或者HEAD~2 倒数第三</span><br><span class="line"></span><br><span class="line">init 在工作目录创建主分支</span><br><span class="line">clone 克隆 -b 分支名 --depth 次数（不想把记录也搞下来可以为1） 地址</span><br><span class="line">stash 暂存 save &quot;信息&quot; 暂存且指定名字 list 查看暂存 pop 弹出暂存 apply 类似pop，但是pop会删除暂存 drop 名称 移除 show -p 查看差异，p是详细</span><br></pre></td></tr></table></figure><h4 id="git查看"><a href="#git查看" class="headerlink" title="git查看"></a>git查看</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log 查看日志 --stat 显示简短内容 --name-only 仅显示文件清单 --name-status 仅显示增删改的文件清单 --author=&quot;author&quot; 列出该用户 --grep=&quot;&quot; 过滤，可加--all--match表示同时满足 file 可以指定文件，查看某文件</span><br><span class="line">status 当前状态</span><br><span class="line">blame -L &lt;start&gt;,&lt;end&gt; 文件名 查看文件历史，从第start行到end行</span><br><span class="line">diff 查看工作与暂存的差异 --cached &lt;reference&gt; 查看暂存和某次提交的差异，默认是HEAD</span><br><span class="line">show &lt;reference&gt;/标签名 查看某提交信息</span><br><span class="line">tag 给提交或者仓库打标签 名/名 &lt;reference&gt; 给当前仓库/提交打标签 -d 名 删除标签 -m &quot;&quot; 注释信息</span><br></pre></td></tr></table></figure><h4 id="git删除"><a href="#git删除" class="headerlink" title="git删除"></a>git删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean 清除没有被跟踪的文件 -n 查看要清除什么 -f 执行清除 -x 连ingore的都删除 -X 只删除ignore -d 删除目录 path 指定目录，不加则为整仓库</span><br><span class="line">rm 文件名 将文件移除 --cached 从暂存区移除</span><br><span class="line">reset [--soft | --mixed | --hard] [HEAD]  --soft 工作区不变，暂存区不变，本地仓库回滚 --mixed 默认参数，工作区不变，暂存区回滚，本地仓库回滚，需重新add --hard 三个区都回滚</span><br></pre></td></tr></table></figure><h4 id="git拉取提交"><a href="#git拉取提交" class="headerlink" title="git拉取提交"></a>git拉取提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add 文件名 添加文件，用.表示所有</span><br><span class="line">commit --amend 结合上次提交一起 -m &quot;&quot; 注释 -a 跳过暂存区，直接到本地仓库</span><br><span class="line">pull &lt;远程主机名&gt;(origin) &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程主机，分支与本地分支合并  --rebase 执行rebase不执行merge  实际该指令大概可以理解为fetch + merge</span><br><span class="line">push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;  -u 名 指定默认主机 --force 强制推送，冲掉差异 --tags 推送标签</span><br><span class="line">fetch &lt;远程主机名&gt; &lt;分支名&gt; 从远程获取最新版本，不指定分支名即全部</span><br><span class="line">merge 分支名 合并该分支到当前分支</span><br><span class="line">rebase 分支名 将另一分支合并到当前，不留痕迹，不像merge那样，将提交合并成patch，然后转到当前分支apply，当有冲突时，解决完用add后，执行--continue则继续执行apply，或者用--abort结束</span><br></pre></td></tr></table></figure><h4 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">branch 列出本地所有分支；分支名 创建分支；-b 分支名 创建并切换分支；-a 列出所有分支；-m 名1 名2 将名1改为名2；-d 名 删除分支</span><br><span class="line">checkout 文件名；分支名 切换分支；-b 名 [commit id] 创建并切换；commit id 切换到某提交； </span><br><span class="line">chrry-pick &lt;commit id&gt;【..&lt;commit id&gt;】 将提交应用到其它分支</span><br><span class="line">remote</span><br></pre></td></tr></table></figure><h4 id="git补丁"><a href="#git补丁" class="headerlink" title="git补丁"></a>git补丁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">format-patch &lt;commit id&gt; -n 打包id和之前n-1个到patch，patch是一个提交一个；&lt;id&gt;..&lt;id&gt; 打包之间的；--stdout &gt; fiilename.patch 指定名字</span><br><span class="line">diff &lt;id&gt; &lt;id&gt; &gt; filename.diff 打包到diff，只有一个</span><br><span class="line">apply --check filename  应用 但是不创建提交</span><br><span class="line">am filename 应用且创建提交</span><br></pre></td></tr></table></figure><h4 id="git文件"><a href="#git文件" class="headerlink" title="git文件"></a>git文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.gitignore</span><br><span class="line">    filename 忽略指定文件</span><br><span class="line">    filepath 忽略指定文件夹</span><br><span class="line">    *   统配符</span><br><span class="line">    !xxx 这xxx文件不忽略</span><br><span class="line">    /xxx 表示忽略最上层的xxx</span><br><span class="line">git check-ignore检查</span><br><span class="line"></span><br><span class="line">..gitmodules</span><br><span class="line">git submodule add &lt;url&gt; &lt;path&gt; 添加子模块，path为保存路径</span><br><span class="line">git submodule update --init --recursive 拉取子模块</span><br><span class="line"></span><br><span class="line">移除子模块-&gt;移除目录、移除.gitmodules信息、移除.git/config信息、移除.git/module/ 对应信息</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Git语法小记</summary>
    
    
    
    <category term="无处安放" scheme="http://bugnull.com/categories/无处安放/"/>
    
    
    <category term="Git" scheme="http://bugnull.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL视图</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E8%A7%86%E5%9B%BE/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E8%A7%86%E5%9B%BE/</id>
    <published>2023-03-04T12:27:40.060Z</published>
    <updated>2022-08-30T14:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表，通过表动态生成的数据</p><p>视图和表的区别：</p><pre><code>        使用方式    占用物理空间视图    完全相同    不占用，仅仅保存的是sql逻辑表      完全相同    占用</code></pre><p>视图的好处：</p><pre><code>1、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性</code></pre><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><pre><code>语法：CREATE VIEW 视图名AS查询语句;</code></pre><h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><pre><code>对视图增删改，也会修改原表1、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&apos;Partners&apos;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&apos;虚竹&apos;,90);3、修改视图的数据UPDATE my_v4 SET last_name =&apos;梦姑&apos; WHERE last_name=&apos;虚竹&apos;;4、删除视图的数据DELETE FROM my_v4;</code></pre><h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><pre><code>包含以下关键字的    sql语句：分组函数、distinct、group  by、having、union或者union all    常量视图    Select中包含子查询    join    from一个不能更新的视图    where子句的子查询引用了from子句中的表</code></pre><h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><pre><code>#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7;</code></pre><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><pre><code>DROP VIEW test_v1,test_v2,test_v3;</code></pre><h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><pre><code>DESC test_v7;SHOW CREATE VIEW test_v7;</code></pre>]]></content>
    
    
    <summary type="html">MySQL视图小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL流量控制</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</id>
    <published>2023-03-04T12:27:40.050Z</published>
    <updated>2022-08-30T14:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre><code>一、if函数语法：    if(表达式1，表达式2，表达式3)    1成立则返回2，否则返回3特点：    可以用在任何位置二、case语句语法：    情况一：类似于switch-case    case 变量|表达式|字段    when 值1 then 值1|表达式1;    when 值2 then 值2|表达式2;    ...    else 值n|表达式n;    end [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）    情况二：类似于多重if    case     when 条件1 then 值1|表达式1;    when 条件2 then 值2|表达式2;    ...    else 值n|表达式n;    end [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）特点：    可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，可以放在任何地方；可以作为独立语句去使用，只能放begin end中    所有条件不满足有ELSE则执行，无ELSE则返回NULL三、if elseif语句语法：    if 条件1 then 语句1;    elseif 条件2 then 语句2;    ...    else 语句n;    end if;特点：    只能用在begin end中！！！！！！！！！！！！！！！</code></pre><h3 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h3><pre><code>            应用场合if函数      简单双分支case结构    等值判断 的多分支if结构      区间判断 的多分支</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code>语法：    [标签：]WHILE 循环条件DO        循环体    END WHILE [标签];    leave 标签; //像break    iterate 标签; //像continue特点：    只能放在BEGIN END里面    如果要搭配leave跳转语句，需要使用标签，否则可以不用标签    [标签：]loop        循环体    END loop [标签];    [标签：]repeat        循环体    untile 结束循环的条件    END repeat [标签];    //像do while</code></pre>]]></content>
    
    
    <summary type="html">MySQL流量控制小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库概念</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5/</id>
    <published>2023-03-04T12:27:40.030Z</published>
    <updated>2022-08-30T14:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><pre><code>1.持久化数据到本地2.可以实现结构化查询，方便管理</code></pre><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><pre><code>1、DB：Database数据库，保存一组有组织的数据的容器2、DBMS：Database Management System数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据3、SQL：Structure Query Language结构化查询语言，用于和DBMS通信的语言</code></pre><h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><pre><code>1、将数据放到表中，表再放到库中2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。3、表具有一些特性，这些特性定义了数据在表中如何存储。4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的。5、表中的数据是按行存储的。</code></pre><h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><pre><code>1、计算机——右击管理——服务2、通过管理员身份运行    net start 服务名（启动服务）    net stop 服务名（停止服务）</code></pre><h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><pre><code>1、通过mysql自带的客户端    只限于root用户2、通过windows自带的客户端    登录：        mysql 【-h主机名 -P端口号 】-u用户名 -p密码    退出：        exit或ctrl+C</code></pre><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库    show databases;2.打开指定的库    use 库名3.查看当前库的所有表    show tables;4.查看其它库的所有表    show tables from 库名;5.创建表    create table 表名(        列名 列类型,        列名 列类型，        ...    );6.查看表结构    desc 表名;7.显示表中的所有数据    select * from 表名;7.查看服务器的版本    登录到mysql服务端        select version();    没有登录到mysql服务端        mysql --version 或 mysql --V</code></pre><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><pre><code>1.不区分大小写,但建议关键字大写，表名、列名小写2.每条命令最好用分号结尾3.每条命令根据需要，可以进行缩进 或换行4.注释    单行注释：#注释文字    单行注释：-- 注释文字    多行注释：/* 注释文字  */</code></pre><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><pre><code>DQL（Data Query Language）：数据查询语言    select DML(Data Manipulate Language):数据操作语言    insert 、update、deleteDDL（Data Define Languge）：数据定义语言    create、drop、alterTCL（Transaction Control Language）：事务控制语言    commit、rollback</code></pre>]]></content>
    
    
    <summary type="html">MySQL数据库概念小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用函数</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-04T12:27:40.010Z</published>
    <updated>2022-08-30T14:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><pre><code>一、单行函数1、字符函数    concat拼接    substr截取子串 索引从1开始    upper转换成大写    lower转换成小写    trim去前后指定的空格和字符 trim(&apos;a&apos; from &apos;aaababbaaa&apos;) 输出babb    ltrim去左边空格    rtrim去右边空格    replace替换    lpad左填充    rpad右填充    instr返回子串第一次出现的索引    length 获取字节个数2、数学函数    round 四舍五入    rand 随机数    floor向下取整    ceil向上取整    mod取余    truncate截断3、日期函数    now()当前系统日期+时间        year(now()) 截取年 month()    curdate()当前系统日期    curtime()当前系统时间    str_to_date(&apos;时间&apos;,&apos;如何解析&apos;) 返回合规的时间    date_format(&apos;时间&apos;,&apos;如何输出&apos;) 返回想要的时间4、流程控制函数    1. if(条件,true_ret,false_ret)    2. case key        when val then 处理        when val then 处理        ...        else 处理        end        * key可以不写，有时val与key要合规，无时则val为条件5、其他函数    version版本    database当前库    user当前连接用户二、分组函数        sum 求和        max 最大值        min 最小值        avg 平均值        count 计数        特点：        1、以上五个分组函数都忽略null值，除了count(*)        2、sum和avg一般用于处理数值型            max、min、count可以处理任何数据类型        3、都可以搭配distinct使用，用于统计去重后的结果        4、count的参数可以支持：            字段、*、常量值，一般放1，都是求表中有多少行        建议使用 count(*)，在MYISAM中，count(*)有缓存，效率高，INNODB中，count(*)和count(1)类似        5、分组函数一般要求是group by后的字段，否则没有意义</code></pre>]]></content>
    
    
    <summary type="html">MySQL常用函数小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用类型与约束</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BA%A6%E6%9D%9F/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BA%A6%E6%9D%9F/</id>
    <published>2023-03-04T12:27:40.010Z</published>
    <updated>2022-08-30T14:30:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h1><h3 id="整型："><a href="#整型：" class="headerlink" title="整型："></a>整型：</h3><pre><code>Tinyint 1ByteSmallint 2BMediumint 3BInt、integer 4BBigint 8B* 加上unsigned会表示无符号* 超过会报out of range value，但是会插入边界值不设置长度，那会有默认的长度，表示显示宽度，加上ZEROFILL约束后，自动变成unsigned，显示时不够长用0补充</code></pre><h3 id="小数："><a href="#小数：" class="headerlink" title="小数："></a>小数：</h3><pre><code>浮点型    float(M,D) 4B    double(M,D) 8B定点型，下面两者是一样的    DEC(M,D) M+2    DECIMAL(M,D) M+2* D表示小数点位数，M表示小数+整数一共多少位，但是都可以省略不写，DECIMAL(10,0)默认，float和double会根据精度决定* 精度要求高的用DEC</code></pre><h3 id="字符型："><a href="#字符型：" class="headerlink" title="字符型："></a>字符型：</h3><pre><code>较短    char(M)    0~255 比varchara效率高    varchar(M) 0~65535 会根据实际给内存    binary 类似上面的，保存二进制    varbinary较长    text    blob(较长的二进制数据)ENUM  v的值只能是a或者b，不然为空    CREATE TABLE T (        v ENUM(&apos;a&apos;,&apos;b&apos;)    );SET   v的值由set内容组成，不分大小写，多个用逗号分开a,B    CREATE TABLE T (        v SET(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)    );* M表示字符数，中文也只算个，char可以省略，为1，varchar不可以</code></pre><h3 id="日期型："><a href="#日期型：" class="headerlink" title="日期型："></a>日期型：</h3><pre><code>data 4 只有日期 datatime 8 有日期和时间timestamp 4 时刻 受时区影响time 3 只有时间year 1 只有年</code></pre><h3 id="Blob类型："><a href="#Blob类型：" class="headerlink" title="Blob类型："></a>Blob类型：</h3><h1 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h1><p>一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p><pre><code>CREATE TABLE 表名(    字段名 字段类型 约束)NOT NULL 非空，用于保证该字段的值不能为空DEFAULT 默认，用于保证该字段有默认值UNIQUE 唯一，值具有唯一性，可以为空CHECK 检查约束【mysql中不支持，但是不报错】PRIMARY KEY 主键，值具有唯一性且非空FOREIGN KEY 外键，用于限制两个表的关系，保证该字段的值必须来自于主表的关联列的值。就是该值能在别的表中找到。在从表添加外键约束，用于引用主表中某列的值。（数据在主表中，从表只有个编号）如 员工表的部门编号，学生表的专业编号主键和唯一：    都有唯一性    唯一只可以有一个null，主键不可以有；一个表只能有一个主键    **可使用多个值共同作为主键**，唯一也可以由多个值组成外键    在从表中设置外键关系    从表的外键列的类型和主表的关联列类型一致或兼容    主表的关联列必须唯一性（主键或者唯一）    插入数据时，先插入主表，再插入从表，删除则相反</code></pre><p>约束的类型：</p><pre><code>CREATE TABLE 表名(        名 类型 列级约束,        表级约束)列级约束    六大约束语法上都支持，但外键约束没有效果    CREATE TABLE 表名(        id int primary key,        stuname varchar(20) not null,        gender char(1) check(gender=&apos;b&apos; or gender=&apos;g&apos;),        seat int unique,        age int default 18,        majorid int references major(id)  //无效    )    CREATE TABLE major(        id int primary key,        majorname varchar(20)    )表级约束    除了非空、默认，其它都支持    [CONSTRAINT name] 这是可选的    CREATE TABLE 表名(        id int,        stuname varchar(20),        gender char(1) ,        seat int,        age int,        majorid int，        CONSTRAINT pk primary key(id),        CONSTRAINT uq unique(seat),        CONSTRAINT ck CHECK(gender=&apos;b&apos; or gender=&apos;g&apos;),        CONSTRAINT fk_表名_major foreign key(majorid) references major(id)    )</code></pre><p>添加约束的时机：</p><pre><code>创建表时修改表时    ALTER TABLE T MODIFY COLUMN 字段名 字段类型 新约束    只要支持列级约束    ALTER TABLE T ADD COLUMN [constraint 约束名] 约束    只要支持表级约束    ALTER TABLE T DROP PRIMARY KEY    ALTER TABLE T DROP INDEX 唯一键名    ALTER TABLE T DROP FOREIGN KEY 外键名</code></pre><h1 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h1><p>又称自增长列，可以不用手动的插入值，系统提供默认的序列值</p><pre><code>创建表时    CREATE TABLE T(        id int primary key auto_increment,        name varchar(20)    )    插入时，id这一位传入null就行，或者直接省略    必须配合唯一性的键使用    一个表只能有一个标识列，一个auto_increment关键字    标识列只能是数字型     auto_increment_increment 步行 这是系统的值 用SET ...=n 修改    auto_increment_offset 起始    也可以插入一行，修改offset当前值修改表时    ALTER TABLE T MODIFY COLUMN 字段名 字段类型 约束 auto_increment;</code></pre>]]></content>
    
    
    <summary type="html">MySQL常用类型与约束小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储过程和函数</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-04T12:27:40.000Z</published>
    <updated>2022-08-30T14:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率，简化操作3、减少编译次数和连接次数</code></pre><p>分类：</p><pre><code>1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)begin    存储过程体end</code></pre><p>注意</p><pre><code>1、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)BEGIN    sql语句1;    sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in：该参数只能作为输入（该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出</code></pre><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><pre><code>call 存储过程名(实参列表)</code></pre><p><img src="/数据库/mysql存储过程和函数/function_call.png" alt=""></p><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><pre><code>drop procedure 存储过程名</code></pre><h3 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h3><pre><code>show create procedure 存储过程名</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p><pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN    函数体END</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code>SELECT 函数名（实参列表）</code></pre><h3 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h3><pre><code>drop function 存储过程名</code></pre><h3 id="查看函数"><a href="#查看函数" class="headerlink" title="查看函数"></a>查看函数</h3><pre><code>show create function 存储过程名</code></pre><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><pre><code>        关键字        调用语法        返回值        应用场景函数        FUNCTION    SELECT 函数()    有且仅有一个    一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程        PROCEDURE    CALL 存储过程()    可以有0个或多个    一般用于增删改、批量操作</code></pre>]]></content>
    
    
    <summary type="html">MySQL存储过程和函数小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
