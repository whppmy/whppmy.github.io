<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BugNull</title>
  
  <subtitle>纸上得来终觉浅，绝知此事要躬行</subtitle>
  <link href="http://bugnull.com/atom.xml" rel="self"/>
  
  <link href="http://bugnull.com/"/>
  <updated>2022-08-31T09:01:26.076Z</updated>
  <id>http://bugnull.com/</id>
  
  <author>
    <name>whppmy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>右值引用与完美转发</title>
    <link href="http://bugnull.com/C/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    <id>http://bugnull.com/C/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</id>
    <published>2022-08-31T09:00:26.676Z</published>
    <updated>2022-08-31T09:01:26.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="右值引用与完美转发"><a href="#右值引用与完美转发" class="headerlink" title="右值引用与完美转发"></a>右值引用与完美转发</h1><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><blockquote><p>左值（l-value - locator value）是指存储在内存中、有明确存储地址（可取地址）的数据；<br>右值（r -value - read value）是指可以提供数据值的数据（不可取地址）<br>可以对其取地址（&amp;）就是左值，否则为右值 。所有有名字的变量或对象都是左值，而右值是匿名的。</p></blockquote><p>右值分两种</p><blockquote><p>纯右值：非引用返回的临时变量、运算产生的临时变量、原始字面量和 lambda 等<br>将亡值：与右值引用相关的，比如，T&amp;&amp; 类型函数的返回值、 std::move 的返回值等。</p></blockquote><blockquote><p>右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用的方式找到它。无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; v = <span class="number">10</span>; <span class="comment">//v 是对字面量 10 这个右值的引用</span></span><br><span class="line"><span class="function">OBJ <span class="title">getObj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> OBJ(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i1; </span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; i2 = i1; <span class="comment">// error 左值不能赋值给右值 </span></span><br><span class="line">    OBJ&amp; o = getObj(); <span class="comment">// error 左值引用不能接将亡值</span></span><br><span class="line">    OBJ&amp;&amp; o1 = getObj(); <span class="comment">//右值引用可以接收将亡值</span></span><br><span class="line">    <span class="keyword">const</span> OBJ&amp; o2 = getObj();  <span class="comment">//会进行构造，常量左值是万能的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJ(<span class="keyword">const</span> OBJ&amp; a);</span><br><span class="line">OBJ t = getObj();</span><br></pre></td></tr></table></figure><p>t进行拷贝构造，根据将亡值创建、且将亡值会进行析构，效率不高。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJ(OBJ&amp;&amp; a);</span><br><span class="line">OBJ t = getObj();</span><br></pre></td></tr></table></figure><p>因为getObj返回的是将亡值，编译器自动进行右值处理，可以理解为添加了个std::move进行类型转换。调用移动构造。</p><h3 id="amp-amp-在模板中"><a href="#amp-amp-在模板中" class="headerlink" title="&amp;&amp;在模板中"></a>&amp;&amp;在模板中</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;  <span class="comment">//并不一定表示右值引用，若f(左值)则为左值引用</span></span><br></pre></td></tr></table></figure><h3 id="amp-amp-在auto中"><a href="#amp-amp-在auto中" class="headerlink" title="&amp;&amp;在auto中"></a>&amp;&amp;在auto中</h3><ul><li>&amp;&amp;在auto中，auto&amp;&amp; v = 左值，则v表示左值引用。</li><li>decltype(x)&amp;&amp;，表示一个确切的类型，没有auto灵活。此时用左值赋值会报错。</li></ul><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward&lt;&gt;()   <span class="comment">//因为参数为&amp;&amp;时，不知道是左值引用还是右值引用</span></span><br><span class="line"><span class="comment">//所以使用forward帮助传递参数，会按实际情况进行转发</span></span><br></pre></td></tr></table></figure><blockquote><p>有时候右值会转为左值，左值会转为右值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">move</span><span class="params">(T&amp; val)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(val); <span class="comment">//std::move实际上是个类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt; </span><br><span class="line">B(T1&amp;&amp; t1, T2&amp;&amp; t2, T3&amp;&amp; t3) : </span><br><span class="line">    a1_&#123;<span class="built_in">std</span>::forward&lt;T1&gt;(t1)&#125;, </span><br><span class="line">    a2_&#123;<span class="built_in">std</span>::forward&lt;T2&gt;(t2)&#125;, </span><br><span class="line">    a3_&#123;<span class="built_in">std</span>::forward&lt;T3&gt;(t3)&#125; </span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="class"><span class="keyword">class</span>... <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="built_in">unique_ptr</span>&lt;T&gt; make_unique1(U&amp;&amp;... u)&#123;</span><br><span class="line">    <span class="comment">//return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;U&gt;(u)...));  //右 左 右</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T(<span class="built_in">std</span>::move(u)...));  <span class="comment">//右 右 右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    make_unique1&lt;B&gt;(<span class="number">1</span>,i,<span class="number">2</span>); <span class="comment">//右 左 右</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无论是T&amp;&amp;、左值引用、右值引用，std::forward都会依照原来的类型完美转发</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C++左值与右值引用</summary>
    
    
    
    <category term="C++" scheme="http://bugnull.com/categories/C/"/>
    
    
    <category term="C++基础" scheme="http://bugnull.com/tags/C-基础/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://bugnull.com/%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bugnull.com/%E6%97%A0%E5%A4%84%E5%AE%89%E6%94%BE/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-31T02:07:20.205Z</published>
    <updated>2022-08-31T02:08:38.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h1><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h3><p>根据参数，如字符串、枚举等，反回创建的类。不属于Gof所说的。</p><h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h3><p>抽象一层，选择一个需要的工厂，工厂有一个获取产品的方法，再从工厂取要的东西。</p><p><img src="/无处安放/设计模式/工厂方法模式UML图.png" alt=""></p><h3 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3.抽象工厂"></a>3.抽象工厂</h3><p>对工厂抽象和产品抽象，创建一个产品族工厂，从产品族工厂中取东西。理论上每个工厂都能取到同类型的东西，但是属性不一样。</p><p><img src="/无处安放/设计模式/抽象工厂模式UML图.png" alt=""></p><h3 id="4-构建者模式"><a href="#4-构建者模式" class="headerlink" title="4.构建者模式"></a>4.构建者模式</h3><p>抽象一个item做衍生，以此做为产品，里面有公共的方法。使用一个builder，选装Item，把东西存起来。产品可以动态增删。</p><p><img src="/无处安放/设计模式/builder.svg" alt=""></p><h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h3><p>使用当前已经存在的类，给予一个clone接口，用于克隆一份一样的、独立存在的类。</p><p><img src="/无处安放/设计模式/prototype.png" alt=""></p><h3 id="6-单例模式"><a href="#6-单例模式" class="headerlink" title="6.单例模式"></a>6.单例模式</h3><p>一个对象，只有一个实例，私有创建的方法。大家共用同一个。<br>懒汉式，在第一次使用时才创建<br>饿汉式，编译构建时就创建,static成员</p><p><img src="/无处安放/设计模式/singleton.jpg" alt=""></p><hr><h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7.适配器模式"></a>7.适配器模式</h3><p>由底部根据需求实现匹配，自动返回适应的类型或者执行某些动作。</p><p><img src="/无处安放/设计模式/adapter.png" alt=""></p><h3 id="8-桥接模式"><a href="#8-桥接模式" class="headerlink" title="8.桥接模式"></a>8.桥接模式</h3><p>根据不同的上层产品，给入不同的内部数据，通过上层产品操作间接使用数据，展示的效果会不一样。</p><p><img src="/无处安放/设计模式/桥接模式UML实例图.png" alt=""></p><h3 id="9-组合模式"><a href="#9-组合模式" class="headerlink" title="9.组合模式"></a>9.组合模式</h3><p>把东西按关系进行划分，构成一棵树级结构。</p><p><img src="/无处安放/设计模式/组合模式UML图.png" alt=""></p><h3 id="10-装饰者模式"><a href="#10-装饰者模式" class="headerlink" title="10.装饰者模式"></a>10.装饰者模式</h3><p>大家都会一个动作，但是又可以相互包装，A会画圆，B会画方，C的画画方法可以是让A、B一起来画，还可以加别的。</p><p><img src="/无处安放/设计模式/decorator.svg" alt=""></p><h3 id="11-外观模式"><a href="#11-外观模式" class="headerlink" title="11.外观模式"></a>11.外观模式</h3><p>使用一个上层包装，把多个具有某个关系的类放到一起。</p><p><img src="/无处安放/设计模式/外观模式实例UML图.png" alt=""></p><h3 id="12-享元模式"><a href="#12-享元模式" class="headerlink" title="12.享元模式"></a>12.享元模式</h3><p>大家共享某部分数据，在没有的时候进行创建，下次再要这个类型时返回该值，减少创建。</p><p><img src="/无处安放/设计模式/享元模式UML图.png" alt=""></p><h3 id="13-代理模式"><a href="#13-代理模式" class="headerlink" title="13.代理模式"></a>13.代理模式</h3><p>给一个类做一层包装，做一层扩展，做为代理人进行控制。</p><p><img src="/无处安放/设计模式/proxy.svg" alt=""></p><hr><h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><h3 id="14-职责链模式"><a href="#14-职责链模式" class="headerlink" title="14.职责链模式"></a>14.职责链模式</h3><p>根据类关系，构建一条关系链，在上层需要处理数据时，可能需要和下层进行交互，可以达到相互传递，以完成处理。</p><p><img src="/无处安放/设计模式/职责链模式UML实例图.png" alt=""></p><h3 id="15-命令模式"><a href="#15-命令模式" class="headerlink" title="15.命令模式"></a>15.命令模式</h3><p>把需要做的事情包装成一个事件，通过一个中心控制，命令事件执行。</p><p><img src="/无处安放/设计模式/命令模式实例UML图.png" alt=""></p><h3 id="16-解释器模式"><a href="#16-解释器模式" class="headerlink" title="16.解释器模式"></a>16.解释器模式</h3><p>通过特定的功能分类，拆成一个一个解析器，使用不同的解析器去处理对应的数据，达到整体划分。</p><p><img src="/无处安放/设计模式/解释器实例UML图.png" alt=""></p><h3 id="17-迭代器模式"><a href="#17-迭代器模式" class="headerlink" title="17.迭代器模式"></a>17.迭代器模式</h3><p>常见于Stl中，用于高效遍历内容。</p><p><img src="/无处安放/设计模式/iterator.png" alt=""></p><h3 id="18-中介者模式"><a href="#18-中介者模式" class="headerlink" title="18.中介者模式"></a>18.中介者模式</h3><p>大家根据某个关系，注册在一个中心。然后都可以通过中心给的接口，查询到别人的信息和被别人找到。</p><p><img src="/无处安放/设计模式/中介者模式UML图.png" alt=""></p><h3 id="19-备忘录模式"><a href="#19-备忘录模式" class="headerlink" title="19.备忘录模式"></a>19.备忘录模式</h3><p>处理一个事件，在需要的时候保存一下（新建一份数据）存起来，使用者后面可以根据索引去找到这份保存的数据。</p><p><img src="/无处安放/设计模式/备忘录模式UML图.png" alt=""></p><h3 id="20-观察者模式"><a href="#20-观察者模式" class="headerlink" title="20.观察者模式"></a>20.观察者模式</h3><p>大家往一个地方注册，当发生事件时，注册了的类会收到需要的信息。参考QT信号槽。</p><p><img src="/无处安放/设计模式/observer.jpg" alt=""></p><h3 id="21-状态模式"><a href="#21-状态模式" class="headerlink" title="21.状态模式"></a>21.状态模式</h3><p>给一个物体塑造多个外表，根据需要设置外表，用该外表做为当前的状态，可随时切换。</p><p><img src="/无处安放/设计模式/state.png" alt=""></p><h3 id="22-策略模式"><a href="#22-策略模式" class="headerlink" title="22.策略模式"></a>22.策略模式</h3><p>当前有一组数据，但是可以有多个处理的方法，其方法可能可以进行组合，把方法单独做为策略。组合出需要的场景。</p><p><img src="/无处安放/设计模式/strategy.jpg" alt=""></p><h3 id="23-模板模式"><a href="#23-模板模式" class="headerlink" title="23.模板模式"></a>23.模板模式</h3><p>抽象一个模板，模板会有很多动作调用。实体可以选择实现某些动作，不需要的可以空实现。</p><p><img src="/无处安放/设计模式/template.jpg" alt=""></p><h3 id="24-访问者模式"><a href="#24-访问者模式" class="headerlink" title="24.访问者模式"></a>24.访问者模式</h3><p>每个事物关注同一个东西的角度都不同。通过元素的回调或者访问者主动查看，可以做不同的动作。</p><p><img src="/无处安放/设计模式/visitor.jpg" alt=""></p><p><strong>以上为Gof(Gang of Four)四人组提出的</strong></p><hr><h3 id="25-pimpl"><a href="#25-pimpl" class="headerlink" title="25.pimpl"></a>25.pimpl</h3><p>qt源码实现方式，将成员藏在cpp，不对外暴露。</p><h3 id="26-业务代表"><a href="#26-业务代表" class="headerlink" title="26.业务代表"></a>26.业务代表</h3><p>其中包含client、Delegate、lookup、service。使用者通过代理缓存，查找需要的服务。通过这样将业务进行分层解耦。</p><p><img src="/无处安放/设计模式/businessDelegate.svg" alt=""></p><h3 id="27-组合实体模式"><a href="#27-组合实体模式" class="headerlink" title="27.组合实体模式"></a>27.组合实体模式</h3><blockquote><p>组合实体太学术化了，不通俗。组合实体是个对象，是个管理者，管家，掌柜的，经理，它是直接面向客户的。组合实体下面是几个小组，也就是假如说它是个经理的话，那么它下面管理着几个小组长。小组长下面就是组员了呗，也就是真正干活的人了。所以组合实体是个层层管理的机制，并且下层的生命周期决定于上层的生命周期。就这么简单。我想它的作用只不过是简化了每一环的复杂程度而已。</p></blockquote><p><strong><a href="https://www.it610.com/article/1177358433989488640.htm" target="_blank" rel="noopener">https://www.it610.com/article/1177358433989488640.htm</a></strong></p><p><img src="/无处安放/设计模式/420a453041f64bd1aea9cef4e2a1c5e1.jpg" alt=""></p><h3 id="28-过滤器模式"><a href="#28-过滤器模式" class="headerlink" title="28.过滤器模式"></a>28.过滤器模式</h3><p>字面意思，通过一个过滤器，把输入的数据过滤掉不合理的，然后得到结果。</p><p><img src="/无处安放/设计模式/criteria.svg" alt=""></p><h3 id="29-空模式"><a href="#29-空模式" class="headerlink" title="29.空模式"></a>29.空模式</h3><p>对于不些不合理的数据，给予一个空的对象，而不是空值。</p><p><img src="/无处安放/设计模式/null.jpg" alt=""></p><h3 id="30-mvc"><a href="#30-mvc" class="headerlink" title="30.mvc"></a>30.mvc</h3><p>model，存数据，更新时告诉C,view将数据做显示，controller作为中间传递数据和中间处理的一方。Qt中是MVD D是代理，包括C的功能，还有告诉V怎么去定制和绘制。</p><p><img src="/无处安放/设计模式/mvc.svg" alt=""></p><h3 id="31-数据访问对象模式"><a href="#31-数据访问对象模式" class="headerlink" title="31.数据访问对象模式"></a>31.数据访问对象模式</h3><p>将一些不好使用的接口包装进来，通过更上一层封装，使用时更便捷。</p><p><img src="/无处安放/设计模式/dao.jpg" alt=""></p><h3 id="32-前端控制器模式"><a href="#32-前端控制器模式" class="headerlink" title="32.前端控制器模式"></a>32.前端控制器模式</h3><p>通过一个前端，把请求进行汇总再分发给特定的处理器。</p><p><img src="/无处安放/设计模式/frontController.jpg" alt=""></p><h3 id="33-拦截过滤器模式"><a href="#33-拦截过滤器模式" class="headerlink" title="33.拦截过滤器模式"></a>33.拦截过滤器模式</h3><p>通过实现多个过滤器，在发生事件时，使用注册了的过滤器对事件进行处理，通过后再去做相应的操作，否则拦截。</p><p><img src="/无处安放/设计模式/interceptingFilter.svg" alt=""></p><h3 id="34-服务定位器模式"><a href="#34-服务定位器模式" class="headerlink" title="34.服务定位器模式"></a>34.服务定位器模式</h3><p>根据一个中心缓存，去查找或者说定位之前使用过的东西。</p><p><img src="/无处安放/设计模式/serviceLocator.svg" alt=""></p><h3 id="35-传输对象模式"><a href="#35-传输对象模式" class="headerlink" title="35.传输对象模式"></a>35.传输对象模式</h3><p>把对象打包传送与接收。</p><p><img src="/无处安放/设计模式/transfer.svg" alt=""></p>]]></content>
    
    
    <summary type="html">设计模式小记</summary>
    
    
    
    <category term="无处安放" scheme="http://bugnull.com/categories/无处安放/"/>
    
    
    <category term="设计模式" scheme="http://bugnull.com/tags/设计模式/"/>
    
  </entry>
  
  <entry>
    <title>MySQL TCL事务控制语言</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-tcl%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-tcl%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80/</id>
    <published>2022-08-30T14:23:44.830Z</published>
    <updated>2022-08-30T14:36:56.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><pre><code>通过一组逻辑操作单元（一组sql语句），将数据从一种状态切换到另外一种状态。事务中操作的数据，需要根据隔离级别进行体现</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><pre><code>（ACID）原子性：要么都执行，要么都回滚。事务不可分割的工作单元。一致性：保证数据的状态操作前和操作后保持一致隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</code></pre><p>相关步骤：</p><pre><code>1、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务</code></pre><h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p><pre><code>比如insert、update、delete语句本身就是一个事务</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p><pre><code>1、开启事务    取消自动提交事务的功能    set autocommit=0;    2、编写事务的一组逻辑操作单元（多条sql语句）    select    insert    update    delete    //DDL语言不具有事务性3、提交事务或回滚事务</code></pre><h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><pre><code>set autocommit=0;start transaction;commit;rollback;savepoint  断点commit to 断点rollback to 断点</code></pre><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h3><p>事务并发问题如何发生？</p><pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre><p>事务的并发问题有哪些？</p><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据，一般是别的事务插入数据提交后</code></pre><p>如何避免事务的并发问题？</p><pre><code>通过设置事务的隔离级别1、READ UNCOMMITTED 允许事务读取未被其它事物提交的变更2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE 可以避免脏读、不可重复读和幻读Oracle只支持2和4，默认是2，而Myql都支持，默认是3</code></pre><p>设置隔离级别：</p><pre><code>set session|global transaction isolation level 隔离级别名;</code></pre><p>查看隔离级别：</p><pre><code>select @@tx_isolation;</code></pre>]]></content>
    
    
    <summary type="html">MySQL TCL事务控制语言小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL DQL数据查询语言</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-dql%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-dql%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</id>
    <published>2022-08-30T14:23:44.497Z</published>
    <updated>2022-08-30T14:33:56.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><pre><code>语法：SELECT 要查询的东西【FROM 表名】;特点：* 通过select查询完的结果 ，是一个虚拟的表格，不是真实存在* 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre><h4 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h4><pre><code>* SELECT last_name AS 姓 FROM info;* SELECT last_name 姓 FROM info;便于理解查询字段第一名情况，使用别名可以区分开来</code></pre><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><pre><code>SELECT CONCAT(last_name,first_name) AS 姓名 FROM info;+会把字符串转数字，不成功则为0，然后相加若其中一方为NULL，则结果为NULL，可以使用IFNULL(name,default)，若name为NULL，则返回default</code></pre><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><pre><code>SELECT DISTINCT last_name 姓 FROM info;</code></pre><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><pre><code>条件查询：根据条件过滤原始表的数据，查询到想要的数据语法：select     要查询的字段|表达式（计算+-*/%等）|常量值|函数（输出函数返回值）from     表where     条件 ;    关键字名作字段使用``包装    分类：    一、条件表达式        示例：salary&gt;10000        条件运算符：        &gt; &lt; &gt;= &lt;= = != &lt;&gt;        **&lt;=&gt; 安全等于，可以用在NULL，上面的不行**    二、逻辑表达式        示例：salary&gt;10000 &amp;&amp; salary&lt;20000        逻辑运算符：            and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false            or(||)：两个条件只要有一个成立，结果为true，否则为false            not(!)：如果条件成立，则not后为false，否则为true    三、模糊查询        like：            where last_name like &apos;a%&apos; ESCAPE &apos;#&apos;;  字符形要加引号，%表示任意多个字符，_表示一个，默认是\转义，可以使用ESCAPE指定        between and：            where a BETWEEN 20 AND 30; 包含两端，不可交换位置        in：            where last_name IN(&apos;&apos;,&apos;&apos;,...); 不支持通配符        is null：            where lastt_name IS [NOT] NULL;</code></pre><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><pre><code>语法：select    要查询的东西from    表where     条件order by 排序的字段|表达式|函数|别名 【asc|desc】，...* 可以用,进行多个条件复合</code></pre><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><pre><code>语法：select 分组函数,查询的字段from 表【where】group by 查询的字段【order by】【having】特点：    1、可以按单个字段分组    2、和分组函数一同查询的字段最好是分组后的字段    3、分组筛选针对的表位置关键字    分组前筛选： 原始表        group by的前面 where    分组后筛选： 分组后的结果集    group by的后面 having    4、可以按多个字段分组，字段之间用逗号隔开    5、可以支持排序    6、having后可以支持别名</code></pre><h2 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h2><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件</code></pre><p>一、传统模式下的连接 ：等值连接、非等值连接<br>    1.等值连接的结果 = 多个表的交集<br>    2.n表连接，至少需要n-1个连接条件<br>    3.多个表不分主次，没有顺序要求<br>    4.一般为表起别名，提高阅读性和性能，用了原表名就不能用了</p><p>二、sql99语法：通过join关键字实现连接<br>    含义：1999年推出的sql语法<br>    支持：<br>    等值连接、非等值连接 （内连接）<br>    外连接<br>        左外<br>        右外<br>        全外<br>    交叉连接</p><pre><code>语法：select 字段，...from 表1【inner|left outer|right outer|full outer|cross】join 表2 别名on 连接条件【inner|left outer|right outer|full outer|cross】join 表3 别名on  连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】outer和inner可以省略1. 内连接，找不到对应的，就不显示2. 外连接，查询结果为主表中的所有记录。用于一个表有，另外一个表找不到对应的情况。主表中每行都显示出来，若找不到匹配的值用null。等于内连接结果+没匹配到的行和null3. 左右连接，左连接表示左边是主表，右连接表示右边是主表4. 全外连接，等于内连结果+主表没匹配到的行和null+从表没匹配到的行和null5. 交叉连接，等于笛卡尔乘积</code></pre><p>三、自连接<br>    同一个表有多个意义，如员工表也可以表示为领导表，但是又不能用一个表就完成，需要自连接自己</p><p>案例：查询员工名和直接上级的名称<br>sql99</p><pre><code>SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre><p>sql92</p><pre><code>SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`;</code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>含义：</p><pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询</code></pre><p>特点：</p><pre><code>1、子查询都放在小括号内，一般放在条件的右侧2、子查询优先于主查询执行，主查询使用了子查询的执行结果    非法使用子查询的情况：        a、子查询的结果与对应的操作符不符        b、子查询的结果为空    3、子查询可以放在    select后面 仅标量子查询    from后面 支持表子查询，需要给查询一个表名    where、having后面 标量、列、行子查询    exists后面 表子查询，结果是1或0，表示子查询是否有结果集4、子查询根据结果集不同分为以下几类：    * 标量子查询        结果集只有一行一列        一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=     * 列子查询        结果集只有一列多行        一般搭配多行操作符使用：any、all、in、not in        in： 属于子查询结果中的任意一个就行        any和all往往可以用其他查询代替        * 行子查询        结果集有一行多列，或多行多列（较少）        例 where (name,age) = (            selece name,age from info;        )    * 表子查询        结果集一般为多行多列</code></pre><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>应用场景：</p><pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre><p>语法：</p><pre><code>select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【offset】size;</code></pre><p>特点：</p><pre><code>1.offset从0开始2.limit子句放在查询语句的最后3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage    假如:    每页显示条目数sizePerPage    要显示的页数 page</code></pre><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><p>引入：<br>    union 联合、合并。将多条查询语句的结果合并成一个结果。要查询的结果来自多个表，且多个表没有直接的关联，且查询的信息类似。</p><p>语法： </p><pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre><p>特点：</p><pre><code>1、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型和顺序几乎相同3、union代表去重，union all代表不去重</code></pre>]]></content>
    
    
    <summary type="html">MySQL DQL数据查询语言小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL DML数据操作语言</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-dml%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-dml%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/</id>
    <published>2022-08-30T14:23:44.367Z</published>
    <updated>2022-08-30T14:34:10.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法一：支持多列、子查询<br>    insert into 表名(字段名，…)<br>    values(值1，…);<br>语法二：<br>    inset into 表名<br>    set 列名=值,列名=值…<br>特点：</p><pre><code>1、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p><pre><code>update 表名 set 字段=新值,字段=新值【where 条件】</code></pre><p>修改多表语法：</p><pre><code>update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p><p>单表的删除： ★<br>    delete from 表名 【where 筛选条件】</p><p>多表的删除：<br>    delete 别名1，别名2<br>    from 表1 别名1，表2 别名2<br>    where 连接条件<br>    and 筛选条件;</p><p>方式2：truncate语句 清空数据</p><pre><code>truncate table 表名</code></pre><p>两种方式的区别【面试题】</p><pre><code>#1.truncate不能加where条件，而delete可以加where条件#2.truncate的效率高一丢丢#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始#4.truncate删除不能回滚，delete删除可以回滚</code></pre>]]></content>
    
    
    <summary type="html">MySQL DML数据操作语言小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL DDL数据定义语言</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-ddl%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-ddl%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/</id>
    <published>2022-08-30T14:23:44.196Z</published>
    <updated>2022-08-30T14:34:18.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p><pre><code>一、创建库create database 库名二、删除库drop database 库名</code></pre><p>表的管理：</p><pre><code>#1.创建表    CREATE TABLE IF NOT EXISTS stuinfo(        stuId INT,        stuName VARCHAR(20),        gender CHAR,        bornDate DATETIME    );    DESC studentinfo;查看表结构    SHOW INDEX FORM info;查看表索引、主键、外键、唯一#2.修改表 alter    语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型 约束】;    #①修改字段名        ALTER TABLE studentinfo CHANGE [COLUMN] 原名 新名 类型;    #②修改表名        ALTER TABLE stuinfo RENAME [TO]  studentinfo;    #③修改字段类型和列级约束        ALTER TABLE studentinfo MODIFY COLUMN borndate DATE;    #④添加字段        ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;    #⑤删除字段        ALTER TABLE studentinfo DROP COLUMN email;#3.删除表        DROP TABLE [IF EXISTS] studentinfo;#4.表复制    仅复制表结构    CREATE TABLE newTable LIKE oldTable;    复制结构+数据    CREATE TABLE newTAble     SELECT * FORM oldTable WHERE ..;</code></pre>]]></content>
    
    
    <summary type="html">MySQL DDL数据定义语言小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库概念</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T14:23:43.949Z</published>
    <updated>2022-08-30T14:34:31.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><pre><code>1.持久化数据到本地2.可以实现结构化查询，方便管理</code></pre><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><pre><code>1、DB：Database数据库，保存一组有组织的数据的容器2、DBMS：Database Management System数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据3、SQL：Structure Query Language结构化查询语言，用于和DBMS通信的语言</code></pre><h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><pre><code>1、将数据放到表中，表再放到库中2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。3、表具有一些特性，这些特性定义了数据在表中如何存储。4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的。5、表中的数据是按行存储的。</code></pre><h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><pre><code>1、计算机——右击管理——服务2、通过管理员身份运行    net start 服务名（启动服务）    net stop 服务名（停止服务）</code></pre><h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><pre><code>1、通过mysql自带的客户端    只限于root用户2、通过windows自带的客户端    登录：        mysql 【-h主机名 -P端口号 】-u用户名 -p密码    退出：        exit或ctrl+C</code></pre><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库    show databases;2.打开指定的库    use 库名3.查看当前库的所有表    show tables;4.查看其它库的所有表    show tables from 库名;5.创建表    create table 表名(        列名 列类型,        列名 列类型，        ...    );6.查看表结构    desc 表名;7.显示表中的所有数据    select * from 表名;7.查看服务器的版本    登录到mysql服务端        select version();    没有登录到mysql服务端        mysql --version 或 mysql --V</code></pre><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><pre><code>1.不区分大小写,但建议关键字大写，表名、列名小写2.每条命令最好用分号结尾3.每条命令根据需要，可以进行缩进 或换行4.注释    单行注释：#注释文字    单行注释：-- 注释文字    多行注释：/* 注释文字  */</code></pre><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><pre><code>DQL（Data Query Language）：数据查询语言    select DML(Data Manipulate Language):数据操作语言    insert 、update、deleteDDL（Data Define Languge）：数据定义语言    create、drop、alterTCL（Transaction Control Language）：事务控制语言    commit、rollback</code></pre>]]></content>
    
    
    <summary type="html">MySQL数据库概念小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL视图</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E8%A7%86%E5%9B%BE/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E8%A7%86%E5%9B%BE/</id>
    <published>2022-08-30T14:23:43.892Z</published>
    <updated>2022-08-30T14:34:42.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表，通过表动态生成的数据</p><p>视图和表的区别：</p><pre><code>        使用方式    占用物理空间视图    完全相同    不占用，仅仅保存的是sql逻辑表      完全相同    占用</code></pre><p>视图的好处：</p><pre><code>1、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性</code></pre><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><pre><code>语法：CREATE VIEW 视图名AS查询语句;</code></pre><h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><pre><code>对视图增删改，也会修改原表1、查看视图的数据 ★SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&apos;Partners&apos;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&apos;虚竹&apos;,90);3、修改视图的数据UPDATE my_v4 SET last_name =&apos;梦姑&apos; WHERE last_name=&apos;虚竹&apos;;4、删除视图的数据DELETE FROM my_v4;</code></pre><h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><pre><code>包含以下关键字的    sql语句：分组函数、distinct、group  by、having、union或者union all    常量视图    Select中包含子查询    join    from一个不能更新的视图    where子句的子查询引用了from子句中的表</code></pre><h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><pre><code>#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7;</code></pre><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><pre><code>DROP VIEW test_v1,test_v2,test_v3;</code></pre><h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><pre><code>DESC test_v7;SHOW CREATE VIEW test_v7;</code></pre>]]></content>
    
    
    <summary type="html">MySQL视图小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL流量控制</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</id>
    <published>2022-08-30T14:23:43.570Z</published>
    <updated>2022-08-30T14:34:51.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre><code>一、if函数语法：    if(表达式1，表达式2，表达式3)    1成立则返回2，否则返回3特点：    可以用在任何位置二、case语句语法：    情况一：类似于switch-case    case 变量|表达式|字段    when 值1 then 值1|表达式1;    when 值2 then 值2|表达式2;    ...    else 值n|表达式n;    end [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）    情况二：类似于多重if    case     when 条件1 then 值1|表达式1;    when 条件2 then 值2|表达式2;    ...    else 值n|表达式n;    end [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）特点：    可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，可以放在任何地方；可以作为独立语句去使用，只能放begin end中    所有条件不满足有ELSE则执行，无ELSE则返回NULL三、if elseif语句语法：    if 条件1 then 语句1;    elseif 条件2 then 语句2;    ...    else 语句n;    end if;特点：    只能用在begin end中！！！！！！！！！！！！！！！</code></pre><h3 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h3><pre><code>            应用场合if函数      简单双分支case结构    等值判断 的多分支if结构      区间判断 的多分支</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code>语法：    [标签：]WHILE 循环条件DO        循环体    END WHILE [标签];    leave 标签; //像break    iterate 标签; //像continue特点：    只能放在BEGIN END里面    如果要搭配leave跳转语句，需要使用标签，否则可以不用标签    [标签：]loop        循环体    END loop [标签];    [标签：]repeat        循环体    untile 结束循环的条件    END repeat [标签];    //像do while</code></pre>]]></content>
    
    
    <summary type="html">MySQL流量控制小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储过程和函数</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</id>
    <published>2022-08-30T14:23:43.300Z</published>
    <updated>2022-08-30T14:35:07.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率，简化操作3、减少编译次数和连接次数</code></pre><p>分类：</p><pre><code>1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)begin    存储过程体end</code></pre><p>注意</p><pre><code>1、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)BEGIN    sql语句1;    sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in：该参数只能作为输入（该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出</code></pre><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><pre><code>call 存储过程名(实参列表)</code></pre><p><img src="/数据库/mysql存储过程和函数/function_call.png" alt=""></p><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><pre><code>drop procedure 存储过程名</code></pre><h3 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h3><pre><code>show create procedure 存储过程名</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p><pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN    函数体END</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code>SELECT 函数名（实参列表）</code></pre><h3 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h3><pre><code>drop function 存储过程名</code></pre><h3 id="查看函数"><a href="#查看函数" class="headerlink" title="查看函数"></a>查看函数</h3><pre><code>show create function 存储过程名</code></pre><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><pre><code>        关键字        调用语法        返回值        应用场景函数        FUNCTION    SELECT 函数()    有且仅有一个    一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程        PROCEDURE    CALL 存储过程()    可以有0个或多个    一般用于增删改、批量操作</code></pre>]]></content>
    
    
    <summary type="html">MySQL存储过程和函数小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用类型与约束</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BA%A6%E6%9D%9F/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BA%A6%E6%9D%9F/</id>
    <published>2022-08-30T14:23:43.106Z</published>
    <updated>2022-08-30T14:30:46.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h1><h3 id="整型："><a href="#整型：" class="headerlink" title="整型："></a>整型：</h3><pre><code>Tinyint 1ByteSmallint 2BMediumint 3BInt、integer 4BBigint 8B* 加上unsigned会表示无符号* 超过会报out of range value，但是会插入边界值不设置长度，那会有默认的长度，表示显示宽度，加上ZEROFILL约束后，自动变成unsigned，显示时不够长用0补充</code></pre><h3 id="小数："><a href="#小数：" class="headerlink" title="小数："></a>小数：</h3><pre><code>浮点型    float(M,D) 4B    double(M,D) 8B定点型，下面两者是一样的    DEC(M,D) M+2    DECIMAL(M,D) M+2* D表示小数点位数，M表示小数+整数一共多少位，但是都可以省略不写，DECIMAL(10,0)默认，float和double会根据精度决定* 精度要求高的用DEC</code></pre><h3 id="字符型："><a href="#字符型：" class="headerlink" title="字符型："></a>字符型：</h3><pre><code>较短    char(M)    0~255 比varchara效率高    varchar(M) 0~65535 会根据实际给内存    binary 类似上面的，保存二进制    varbinary较长    text    blob(较长的二进制数据)ENUM  v的值只能是a或者b，不然为空    CREATE TABLE T (        v ENUM(&apos;a&apos;,&apos;b&apos;)    );SET   v的值由set内容组成，不分大小写，多个用逗号分开a,B    CREATE TABLE T (        v SET(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)    );* M表示字符数，中文也只算个，char可以省略，为1，varchar不可以</code></pre><h3 id="日期型："><a href="#日期型：" class="headerlink" title="日期型："></a>日期型：</h3><pre><code>data 4 只有日期 datatime 8 有日期和时间timestamp 4 时刻 受时区影响time 3 只有时间year 1 只有年</code></pre><h3 id="Blob类型："><a href="#Blob类型：" class="headerlink" title="Blob类型："></a>Blob类型：</h3><h1 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h1><p>一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p><pre><code>CREATE TABLE 表名(    字段名 字段类型 约束)NOT NULL 非空，用于保证该字段的值不能为空DEFAULT 默认，用于保证该字段有默认值UNIQUE 唯一，值具有唯一性，可以为空CHECK 检查约束【mysql中不支持，但是不报错】PRIMARY KEY 主键，值具有唯一性且非空FOREIGN KEY 外键，用于限制两个表的关系，保证该字段的值必须来自于主表的关联列的值。就是该值能在别的表中找到。在从表添加外键约束，用于引用主表中某列的值。（数据在主表中，从表只有个编号）如 员工表的部门编号，学生表的专业编号主键和唯一：    都有唯一性    唯一只可以有一个null，主键不可以有；一个表只能有一个主键    **可使用多个值共同作为主键**，唯一也可以由多个值组成外键    在从表中设置外键关系    从表的外键列的类型和主表的关联列类型一致或兼容    主表的关联列必须唯一性（主键或者唯一）    插入数据时，先插入主表，再插入从表，删除则相反</code></pre><p>约束的类型：</p><pre><code>CREATE TABLE 表名(        名 类型 列级约束,        表级约束)列级约束    六大约束语法上都支持，但外键约束没有效果    CREATE TABLE 表名(        id int primary key,        stuname varchar(20) not null,        gender char(1) check(gender=&apos;b&apos; or gender=&apos;g&apos;),        seat int unique,        age int default 18,        majorid int references major(id)  //无效    )    CREATE TABLE major(        id int primary key,        majorname varchar(20)    )表级约束    除了非空、默认，其它都支持    [CONSTRAINT name] 这是可选的    CREATE TABLE 表名(        id int,        stuname varchar(20),        gender char(1) ,        seat int,        age int,        majorid int，        CONSTRAINT pk primary key(id),        CONSTRAINT uq unique(seat),        CONSTRAINT ck CHECK(gender=&apos;b&apos; or gender=&apos;g&apos;),        CONSTRAINT fk_表名_major foreign key(majorid) references major(id)    )</code></pre><p>添加约束的时机：</p><pre><code>创建表时修改表时    ALTER TABLE T MODIFY COLUMN 字段名 字段类型 新约束    只要支持列级约束    ALTER TABLE T ADD COLUMN [constraint 约束名] 约束    只要支持表级约束    ALTER TABLE T DROP PRIMARY KEY    ALTER TABLE T DROP INDEX 唯一键名    ALTER TABLE T DROP FOREIGN KEY 外键名</code></pre><h1 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h1><p>又称自增长列，可以不用手动的插入值，系统提供默认的序列值</p><pre><code>创建表时    CREATE TABLE T(        id int primary key auto_increment,        name varchar(20)    )    插入时，id这一位传入null就行，或者直接省略    必须配合唯一性的键使用    一个表只能有一个标识列，一个auto_increment关键字    标识列只能是数字型     auto_increment_increment 步行 这是系统的值 用SET ...=n 修改    auto_increment_offset 起始    也可以插入一行，修改offset当前值修改表时    ALTER TABLE T MODIFY COLUMN 字段名 字段类型 约束 auto_increment;</code></pre>]]></content>
    
    
    <summary type="html">MySQL常用类型与约束小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用函数</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</id>
    <published>2022-08-30T14:23:43.024Z</published>
    <updated>2022-08-30T14:35:20.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><pre><code>一、单行函数1、字符函数    concat拼接    substr截取子串 索引从1开始    upper转换成大写    lower转换成小写    trim去前后指定的空格和字符 trim(&apos;a&apos; from &apos;aaababbaaa&apos;) 输出babb    ltrim去左边空格    rtrim去右边空格    replace替换    lpad左填充    rpad右填充    instr返回子串第一次出现的索引    length 获取字节个数2、数学函数    round 四舍五入    rand 随机数    floor向下取整    ceil向上取整    mod取余    truncate截断3、日期函数    now()当前系统日期+时间        year(now()) 截取年 month()    curdate()当前系统日期    curtime()当前系统时间    str_to_date(&apos;时间&apos;,&apos;如何解析&apos;) 返回合规的时间    date_format(&apos;时间&apos;,&apos;如何输出&apos;) 返回想要的时间4、流程控制函数    1. if(条件,true_ret,false_ret)    2. case key        when val then 处理        when val then 处理        ...        else 处理        end        * key可以不写，有时val与key要合规，无时则val为条件5、其他函数    version版本    database当前库    user当前连接用户二、分组函数        sum 求和        max 最大值        min 最小值        avg 平均值        count 计数        特点：        1、以上五个分组函数都忽略null值，除了count(*)        2、sum和avg一般用于处理数值型            max、min、count可以处理任何数据类型        3、都可以搭配distinct使用，用于统计去重后的结果        4、count的参数可以支持：            字段、*、常量值，一般放1，都是求表中有多少行        建议使用 count(*)，在MYISAM中，count(*)有缓存，效率高，INNODB中，count(*)和count(1)类似        5、分组函数一般要求是group by后的字段，否则没有意义</code></pre>]]></content>
    
    
    <summary type="html">MySQL常用函数小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL变量概念</title>
    <link href="http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%8F%98%E9%87%8F%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%8F%98%E9%87%8F%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T14:23:42.857Z</published>
    <updated>2022-08-30T14:35:26.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><pre><code>一、全局变量作用域：针对于所有会话（连接）有效，但不能跨重启    查看所有全局变量    SHOW GLOBAL VARIABLES;    查看满足条件的部分系统变量    SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;;    查看指定的系统变量的值    SELECT @@global.autocommit;    为某个系统变量赋值    SET @@global.autocommit=0;    SET GLOBAL autocommit=0;二、会话变量作用域：针对于当前会话（连接）有效    查看所有会话变量    SHOW SESSION VARIABLES;    查看满足条件的部分会话变量    SHOW SESSION VARIABLES LIKE &apos;%char%&apos;;    查看指定的会话变量的值    SELECT @@autocommit;    SELECT @@session.tx_isolation;    为某个会话变量赋值    SET @@session.tx_isolation=&apos;read-uncommitted&apos;;    SET SESSION tx_isolation=&apos;read-committed&apos;;show 模糊或者多个selece 指定不写global默认是session</code></pre><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><pre><code>一、用户变量声明并初始化：    SET @变量名=值;    SET @变量名:=值;    SELECT @变量名:=值;赋值：    方式一：一般用于赋简单的值    SET 变量名=值;    SET 变量名:=值;    SELECT 变量名:=值;    方式二：一般用于赋表 中的字段值    SELECT 字段名或表达式 INTO 变量    FROM 表;使用：    select @变量名;二、局部变量    仅仅在定义它的begin和end中有效声明：    declare 变量名 类型 【default 值】;赋值和使用，与用户变量一样</code></pre><p>二者的区别：</p><pre><code>            作用域            定义位置            语法用户变量            当前会话            会话的任何地方        加@符号，不用指定类型局部变量            定义它的BEGIN END中    BEGIN END的第一句话    一般不用加@,需要指定类型</code></pre>]]></content>
    
    
    <summary type="html">MySQL变量概念小记</summary>
    
    
    
    <category term="数据库" scheme="http://bugnull.com/categories/数据库/"/>
    
    
    <category term="MySQL" scheme="http://bugnull.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>物理层基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:12:20.788Z</published>
    <updated>2022-08-30T12:22:44.851Z</updated>
    
    <content type="html"><![CDATA[<p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流<br>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么</p><p>物理层协议主要任务：<br>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置<br>电气特性：指明在接口电缆的各条线上出现的电压范围<br>功能特性：指明某条线上出现的某一电平的电压表示何种意义<br>过程特性：指明对于不同功能的各种可能事的出现顺序</p><p>传输媒体（不同媒体对应不同的物理层协议）：<br>1、导引型：双绞线（网线）、同轴电缆、光纤、电力线<br>2、非导引型：微波通信（2~40GHz)、无线电波、红外线、可见光</p><p>传输方式<br>1、串行（远距离传输，如计算机网络）。并行（CPU与内存之间，通过总线进行传输）<br>2、同步：以稳定的比特流传输，字节间没有间隔，接收端在中间时刻进行检测0或1，此时会有时钟累计误差。需要保持时钟同步。外同步：在收发双方间添加一条单独的时钟信号线。内同步：发送端将时钟同步信号编码到发送数据中一起传输（曼彻斯特编码）。异步：以一个字节为单位传输，字节间异步，在字节前后增加头和尾作为判断。<br>3、单工：单向通信（收音机）。半双工：双向交替通信，可以相互通信但不能同时（对讲机）。全双工：双向同时通信（电话）</p><p><img src="/网络/物理层基本概念/调制与编码.png" alt="编码与调制"></p><p>常用编码：不归零编码（存在同步问题，需要额外传输时钟，不常用），归零编码（自同步，编码效率低，用零电频做隔断），曼彻斯特编码（用码元间跳变表示时钟，又表示数据），差分曼彻斯特编码</p><p><img src="/网络/物理层基本概念/常用编码.png" alt="常用编码方法"></p><p><img src="/网络/物理层基本概念/常用调制.png" alt="常用调制方法"></p><p>频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位中的一个。相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。</p><p>信号在信道中传输会存在失帧的可能，其中因素娄：码元传输速率，信号传输距离，噪声干扰，传输媒体质量。</p><p><img src="/网络/物理层基本概念/信道极限容量.png" alt="奈氏准则和香农公式"></p>]]></content>
    
    
    <summary type="html">物理层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>MAC、IP、ARP基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/mac%E3%80%81ip%E3%80%81arp%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/mac%E3%80%81ip%E3%80%81arp%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:11:57.657Z</published>
    <updated>2022-08-30T12:28:19.542Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/网络/mac、ip、arp基本概念/MAC、IP、ARP三者关系.png" alt="三者关系"><br><img src="/网络/mac、ip、arp基本概念/MAC地址定义.png" alt="三者关系"><br><img src="/网络/mac、ip、arp基本概念/MAC地址小结.png" alt="三者关系"><br>单播：表示只传给指定MAC地址，多播：表示该网络接口所在的多播地址，一个接口可以在多个多播地址，与帧的目的MAC地址符合，即接收该帧，广播：地址为FF:FF:FF:FF:FF:FF，所有人都接收<br><img src="/网络/mac、ip、arp基本概念/IP地址定义.png" alt="三者关系"><br><img src="/网络/mac、ip、arp基本概念/MAC与IP的关系与传输过程.png" alt="三者关系"></p><p><img src="/网络/mac、ip、arp基本概念/ARP地址解析协议过程.png" alt="三者关系"><br><img src="/网络/mac、ip、arp基本概念/ARP地址解析协议过程1.png" alt="三者关系"><br>ARP只能在同一个链路或者同一个网络上使用</p><p><img src="/网络/mac、ip、arp基本概念/MAC、IP、ARP三者关系小结.png" alt="三者关系"></p>]]></content>
    
    
    <summary type="html">MAC、IP、ARP基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:11:57.287Z</published>
    <updated>2022-08-30T12:29:01.150Z</updated>
    
    <content type="html"><![CDATA[<p>封装成帧：在链路层会对IP数据报文添加帧头和帧尾</p><ul><li>帧头和帧尾包含重要的控制信息</li><li>帧头和帧尾作为帧定界，可以通过物理层交付的比特流中提取一个个的帧（PPP帧），并不是所有都包含帧定界标志（以太网V2 MAC帧），而物理层会在传输前增加8字节前导码（前7位是同步码，作为时钟同步，之后一字节作为定界符）再转为电信号发送，以太网规定帧间间隔（96比特时间）</li><li>透明传输，指数据链路层对上层交付的传输数据没有任何限制，若数据中存在帧尾字段，链路层会在该位置做字符标记（在前增加esc  ascill=27）做比特处理（每5位1后插入1个0）等，以防止在解析时提前结束帧（字符填充或者零比特填充）</li></ul><p>差错检测：比特在实际传输过程中可能会产生差错，称为比特差错或误码。一段时间内，传输错误的比特占总传输比特的比率为误码率BER。检错后一般进行重传来纠正传输中的差错或者仅仅是德育检测到差错的帧，取决于是可靠传输还是不可靠传输</p><ul><li>在以太网V2 MAC帧中，帧尾包含4字节的帧检验序列FCS字段，检测是否有误码</li><li>在PPP帧中，帧尾包含2字节FCS</li><li>奇偶校验，在待发送数据后面添加1位奇偶校验，使整个数据（包括校验位）中1的个数为奇数或者偶数，漏检率高</li><li>循环冗余校验，约定一个生成多项式，基于数据和多项式计算出冗余码，添加到数据后面一起传输，漏检率非常低，易于硬件实现，广泛用于数据链路层<br><img src="/网络/数据链路层基本概念/循环冗余校验.png" alt="循环冗余检验CRC"><br><img src="/网络/数据链路层基本概念/循环冗余计算过程.png" alt="循环冗余检验CRC"></li><li>检测码只能检测出是否出错，不能定位，无法纠正错误，可以使用冗余信息更多的纠错码进行前向纠错，开销较大</li></ul><p>可靠传输：根据数据链路层向上层提供的服务类型，其可靠性不一定由数据链路层实现，其它各层均可选择实现可靠传输</p><ul><li>不可靠传输服务：仅仅丢弃有误码的帧</li><li>可靠传输服务：想办法实现发送端发送什么，接收端就收到什么</li><li>有线误码率低，不要求数据链路层向上提供可靠传输。即使出现误码，可靠传输的问题由其上层处理。</li><li>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</li><li><p>传输差错类型，比特差错、分组丢失、分组失序、分组重复，分组表示的是帧<br><img src="/网络/数据链路层基本概念/各层对可靠及不可靠传输类型.png" alt="各层可靠性类型"></p><p>可靠传输实现机制的原理，不仅限于数据链路层</p></li><li>停止-等待协议SW（自动请求重传ARQ）<br><img src="/网络/数据链路层基本概念/停止-等待.png" alt="传输机制"><br><img src="/网络/数据链路层基本概念/停止-等待信道利用率.png" alt="传输机制"></li><li>回退N帧协议GBN（连续ARQ，滑动窗口协议）<ul><li>制定比特给分组编号，发送窗口尺寸，表示一次发多个组，尺寸不能大于分组号-1，接收窗口尺寸为1，（若发送尺寸==分组数，则会接口窗口检测不到错误，依然把0号放置于0号，认为正确，实际是忽略了一个组），接收窗口只能等于1，只能按序接收，数据分组内出现误码后面的分组都会丢弃。</li><li>由停止-等待发送1个改为多个，串行改并行</li><li>累积确认，在接收到前N组时，可以直接发送ACKn表示已经接收到N组数据，减少资源占用</li><li>当多个到达接收方时，出现误码，不仅会丢弃该帧，还会把序号不匹配的丢弃，重新发送多个已经接收到最大序号的ACKn<br><img src="/网络/数据链路层基本概念/回退N帧定义.png" alt="传输机制"><br><img src="/网络/数据链路层基本概念/回退N帧，发送与接收工作机制.png" alt="传输机制"></li></ul></li><li>选择重传协议SR<ul><li>对回退N帧进行扩展，发送滑动窗口&gt;=接收窗口&gt;=1，可进行多组分别确认，但是取消累积确认<br><img src="/网络/数据链路层基本概念/选择重传协议定义.png" alt="传输机制"><br><img src="/网络/数据链路层基本概念/选择重传协议工作机制.png" alt="传输机制"></li></ul></li></ul><p>点对点协议PPP：目前使用最广泛的点对点数据链路层协议，向上不提供可靠传输<br>  <img src="/网络/数据链路层基本概念/点对点协议定义.png" alt="点对点协议"><br>  <img src="/网络/数据链路层基本概念/PPP帧格式.png" alt="点对点协议"></p><ul><li><p>实现透明传输，面向字节的异步链路，字节填充法，对特殊字符前插入转义字符，转义字符再插入转义字符。面向比特的同步链路，比特填充法，对于连续5位1的后面插入一个0。<br><img src="/网络/数据链路层基本概念/PPP工作状态.png" alt="点对点协议"></p><p><img src="/网络/数据链路层基本概念/媒体接入控制.png" alt="媒体接入控制"></p><p>信道复用：</p></li><li>频分复用FDM：根据频带划分出多个了频带（信道），频带间需要有隔离频带</li><li>时分复用TDM：将传输带宽资源按时隙轮流分配给不同用户，用户只能在对应的时隙进行通信，周期性出现，一周期就是一个TDM帧</li><li>波分复用WDM：即光的频分复用，将每路（1310nm波长，2.5Gb/s）变换到1550~1561.2nm，共8路，相隔1.6nm，在同一根光纤传输，光传输会损失，中间需要掺铒光纤放大器EDFA。</li><li><p>码分复用CDM：</p><p><img src="/网络/数据链路层基本概念/码分复用例子.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/静态划分信道小结.png" alt="媒体接入控制"></p><p>动态接入控制：<br>CSMA-CD适用于有线<br><img src="/网络/数据链路层基本概念/CSMA-CD概念.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD争用期.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD最小帧长.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD最大帧长.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD退避算法.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD信道利用率.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD发送流程.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CD接收流程.png" alt="媒体接入控制"><br>CSMA/CA适用于无线<br><img src="/网络/数据链路层基本概念/CSMA-CA与CD区别.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CA与CD应用.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CA帧间间隔IFS.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CA工作原理.png" alt="媒体接入控制"><br>等待DIFS表示有高优先级让其先传。等待SIFS表示最短帧间间隔，用来分隔属于一次对话的各帧。<br><img src="/网络/数据链路层基本概念/CSMA-CA退避算法.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CA退避算法例子.png" alt="媒体接入控制"><br><img src="/网络/数据链路层基本概念/CSMA-CA信道预约.png" alt="媒体接入控制"><br>请求发送RTS:帧包括源地址、目的地址及所需要时间 允许发送CTS:也包括此次通信时间<br><img src="/网络/数据链路层基本概念/CSMA-CA虚拟载波监听.png" alt="媒体接入控制"><br>解决A C互为隐蔽站的问题，C通过CTS知道B被占用的时间</p></li></ul>]]></content>
    
    
    <summary type="html">数据链路层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>集线器与交换机基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:11:57.238Z</published>
    <updated>2022-08-30T13:07:34.216Z</updated>
    
    <content type="html"><![CDATA[<p>总线型使用大量机械接头和无源电缆并不可靠</p><p><img src="/网络/集线器与交换机基本概念/总线型以太网和集线器HUB的星型以太网.png" alt="总线型与星型"></p><p>可以使用集线器HUB在物理层扩展以太网，将多个碰撞域（冲突域）合并成一个更大的冲突域，在一系中的一台主机要发送给二系中一台主机，该帧信号会传输到整个网络的各个主机。</p><p>交换机会把单播帧转发到目的主机（忽略ARP过程，假设交换机的帧交换表已“学习好了”）<br><img src="/网络/集线器与交换机基本概念/集线器与交换机SWITCH的区别.png" alt="集线器与交换机"></p><p>集线器一般使用CSMA/CD争取总线资源，只能半双工，而交换机可以进行全双工，同时进行收发工作。<br><img src="/网络/集线器与交换机基本概念/交换机工作状态.png" alt="交换机工作状态"></p><p><img src="/网络/集线器与交换机基本概念/对比集线器和交换机.png" alt="交换机工作状态"></p><p>交换机工作在数据链路层（也包括物理层—），集线器工作在物理层，前者性能快<br><img src="/网络/集线器与交换机基本概念/集线器与交换机小结.png" alt="交换机工作状态"></p><p>以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。是即插即用设备，刚上电内部帧交换表是空的，随通信进行处学习算法，自动逐渐建立起帧交换表。</p><p>盲目泛洪类似广播，登录会在发送方时登记，每条记录都有时效，到期自动删除，MAC与交换机接口关系不是永久性的，更换主机、更换网卡。ARP高速缓存表中IP与MAC对应关系同样会到期自动删除。<br><img src="/网络/集线器与交换机基本概念/交换机自学习过程.png" alt="交换机自学习"></p><p><img src="/网络/集线器与交换机基本概念/交换机网络环路和广播风暴.png" alt="交换机自学习"></p><p>使用生成树协议，保证没有环路网络<br><img src="/网络/集线器与交换机基本概念/生成树协议STP.png" alt="交换机自学习"></p><p>当交换机以太网足够大时，进行广播会有很大的开销<br>路由器工作在网络层，一般不转发广播，可以将交换机以太网分割成小的广播域<br><img src="/网络/集线器与交换机基本概念/广播频繁.png" alt="虚拟VLAN"></p><p><img src="/网络/集线器与交换机基本概念/虚拟局域网VLAN.png" alt="虚拟VLAN"></p><p><img src="/网络/集线器与交换机基本概念/IEEE802-1Q帧.png" alt="虚拟局域网VLAN实现机制"></p><p>交换机端口类型有以下三种：Access Trunk Hybrid<br>交换机各端口的缺少VLAN ID  思科上称为Native VLAN 即本征VLAN  华为上称Port VLAN ID即端口VLAN ID,PVID</p><p><img src="/网络/集线器与交换机基本概念/Access端口打标签与去标签.png" alt="虚拟局域网VLAN实现机制"></p><p><img src="/网络/集线器与交换机基本概念/Trunk端口转发.png" alt="虚拟局域网VLAN实现机制"></p><p><img src="/网络/集线器与交换机基本概念/VLAN端口类型转发.png" alt="虚拟局域网VLAN实现机制"></p><p><img src="/网络/集线器与交换机基本概念/Hybrid端口转发.png" alt="虚拟局域网VLAN实现机制"></p>]]></content>
    
    
    <summary type="html">集线器与交换机概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>网络层基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:11:56.808Z</published>
    <updated>2022-08-30T12:30:07.030Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/网络/网络层基本概念/网络层概述.png" alt="网络层概述"></p><p><img src="/网络/网络层基本概念/面向连接的虚电路服务.png" alt="网络层提供的两种服务"><br><img src="/网络/网络层基本概念/无连接的数据报服务.png" alt="网络层提供的两种服务"><br><img src="/网络/网络层基本概念/虚电路与数据报服务对比.png" alt="网络层提供的两种服务"></p><p>32比特的IPV4地址不便阅读、记录、输入，因此采用点分十进制表示方法，8个一组，用.分开<br><img src="/网络/网络层基本概念/IPV4地址概述.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4地址分类.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4-A类地址.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4-B类地址.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4-C类地址.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4编址例题.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4编址例题2.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPV4小结.png" alt="IPV4"></p><p>增加子网时候，需要申请新的网络号，等待时间和钱，增加路由路中路由表记录数量，浪费原网络中剩余的IP。此时需要引入子网掩码，通过与运算，取出IPV4地址所在子网的网络地址<br><img src="/网络/网络层基本概念/子网掩码.png" alt="IPV4"><br><img src="/网络/网络层基本概念/子网掩码例题.png" alt="IPV4"></p><p><img src="/网络/网络层基本概念/无分类编址的IPV4.png" alt="IPV4"><br><img src="/网络/网络层基本概念/无分类编址的IPV4_2.png" alt="IPV4"><br><img src="/网络/网络层基本概念/无分类编址的IPV4_3.png" alt="IPV4"><br><img src="/网络/网络层基本概念/无分类编址的IPV4小结.png" alt="IPV4"></p><p>定长即使用同一个子网掩码来划分子网，只能划分出2^n个子网，从主机号借用的。容易造成IP地址浪费。使用不同的子网掩码来划分子网，更灵活，按需分配，子网数量可以不同，减少浪费。<br><img src="/网络/网络层基本概念/定长的子网掩码FLSM.png" alt="IPV4"><br><img src="/网络/网络层基本概念/变长的子网掩码VLSM.png" alt="IPV4"></p><p>路由器收到出错的数据报，丢弃后，向源主机发送ICMP数据报。<br><img src="/网络/网络层基本概念/IP数据报的发送和转发.png" alt="路由器"></p><p>产生环路，会使用TTL进行计算，为零时抛弃，或者加入黑洞路由，使用默认路由后，当不知道转发给哪里就会转发到默认路由<br><img src="/网络/网络层基本概念/静态路由配置及路由环路.png" alt="路由器"></p><p><img src="/网络/网络层基本概念/静态路由选择和动态路由选择.png" alt="路由器"></p><p>在两个自治系统中，内部使用的是IGP或IRP内部网关（路由）协议，之间使用的是EGP或ERP外部网关（路由）协议，仅表示协议，不表示实际使用什么算法<br><img src="/网络/网络层基本概念/因特网路由选择协议特点.png" alt="路由器"><br><img src="/网络/网络层基本概念/常见路由选择协议.png" alt="路由器"><br>路由器会定期发送自己的路由信息<br><img src="/网络/网络层基本概念/路由器基本结构.png" alt="路由器"><br><img src="/网络/网络层基本概念/路由信息协议RIP工作原理.png" alt="路由器"><br><img src="/网络/网络层基本概念/RIP更新规则.png" alt="路由器"><br><img src="/网络/网络层基本概念/RIP坏消息传播慢问题.png" alt="路由器"><br><img src="/网络/网络层基本概念/RIP小结.png" alt="路由器"></p><p><img src="/网络/网络层基本概念/基于LSDB进行最短路径优先SPF计算.png" alt="路由器"><br><img src="/网络/网络层基本概念/OSPF五种分组类型.png" alt="路由器"><br><img src="/网络/网络层基本概念/OSPF工作过程.png" alt="路由器"><br><img src="/网络/网络层基本概念/OSPF多点网络路由器邻居关系建立.png" alt="路由器"><br>减少信息洪泛，一个区域一般最多200个路由<br><img src="/网络/网络层基本概念/OSPF把自治系统再划分为更小的区域.png" alt="路由器"><br><img src="/网络/网络层基本概念/OSPF小结.png" alt="路由器"></p><p><img src="/网络/网络层基本概念/边界网关协议BGP.png" alt="路由器"><br><img src="/网络/网络层基本概念/BGP发言人.png" alt="路由器"><br><img src="/网络/网络层基本概念/BCP发言人构造的连通图.png" alt="路由器"><br>BGP-4报文封装在TCP报文段中<br><img src="/网络/网络层基本概念/BGP-4的四种报文.png" alt="路由器"><br><img src="/网络/网络层基本概念/封装报文的协议.png" alt="路由器"><br><img src="/网络/网络层基本概念/BGP小结.png" alt="路由器"></p><p><img src="/网络/网络层基本概念/IPV4数据报分片.png" alt="IPV4"><br><img src="/网络/网络层基本概念/IPv4数据报首部格式.png" alt="IPV4"></p><p><img src="/网络/网络层基本概念/ICMP网际控制报文.png" alt="ICMP"><br><img src="/网络/网络层基本概念/ICMP小结.png" alt="ICMP"></p><p>R1与R2之间类似点对点，也称IP隧道技术<br><img src="/网络/网络层基本概念/VPN虚拟专用网.png" alt="VPN"></p><p><img src="/网络/网络层基本概念/NAP网络地址转换.png" alt="NAP"><br><img src="/网络/网络层基本概念/NAPT网络地址与端口号转换.png" alt="NAPT"><br><img src="/网络/网络层基本概念/VPN与NAT小结.png" alt="NAPT"></p>]]></content>
    
    
    <summary type="html">网络层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>运输层基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:11:56.616Z</published>
    <updated>2022-08-30T12:30:24.567Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/网络/运输层基本概念/运输层概念.png" alt="运输层"><br><img src="/网络/运输层基本概念/运输层概念小结.png" alt="运输层"><br><img src="/网络/运输层基本概念/端口号.png" alt="运输层"><br><img src="/网络/运输层基本概念/分用与复用.png" alt="运输层"><br><img src="/网络/运输层基本概念/应用层常用协议端口号.png" alt="运输层"></p><p>UDP无连接，TCP三次握手、四次挥手<br><img src="/网络/运输层基本概念/UDP与TCP对比1.png" alt="运输层"><br><img src="/网络/运输层基本概念/UDP与TCP对比2.png" alt="运输层"><br><img src="/网络/运输层基本概念/UDP与TCP对比3.png" alt="运输层"><br><img src="/网络/运输层基本概念/UDP与TCP对比4.png" alt="运输层"><br>TCP规定，即使接收窗口为0，也要接收零窗口探测报文、确认报文、带有紧急数据的报文<br><img src="/网络/运输层基本概念/TCP流量控制.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP流量控制过程1.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP流量控制例题.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP拥塞控制.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP拥塞控制过程.png" alt="运输层"></p><p>慢开始会以2倍数增长拥塞窗口，拥塞避免是线性增加1<br><img src="/网络/运输层基本概念/TCP的拥塞算法慢开始与拥塞避免.png" alt="运输层"><br>不等超时，就进行重传，需要接收连续三个确认<br><img src="/网络/运输层基本概念/TCP的拥塞算法慢开始与拥塞避免的不足.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP拥塞算法快重传.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP拥塞算法快恢复.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP拥塞控制综合.png" alt="运输层"></p><p><img src="/网络/运输层基本概念/TCP超时重传时间的选择.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP超时重传时间计算公式.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP超时重传往返时间.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP超时重传时间出错纠正方法.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP超时重传时间例题.png" alt="运输层"></p><p>不推荐发送窗口前沿收缩，有可能这些数据已经发送了<br><img src="/网络/运输层基本概念/TCP可靠传输的实现滑动窗口滑动.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP可靠传输的实现滑动窗口状态.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP可靠传输的实现滑动窗口过程.png" alt="运输层"></p><p><img src="/网络/运输层基本概念/TCP连接的三个阶段.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP连接建立解决的问题.png" alt="运输层"><br>建立连接前，服务器会先创建传输控制块（TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针、当前的发送和接收序号、。。。），然后进行LISTEN<br>客户端要发起连接时，也先创建传输控制块<br>第三次握手是为了防止多连接，而消耗掉服务器资源<br>SYN=1的报文段不能携带数据，但要消耗一个序号、普通确认报文如果不带数据，则不消耗序号<br>x客户端选择作为初始序号，y为服务端选择的初始序号<br><img src="/网络/运输层基本概念/TCP三次握手连接过程.png" alt="运输层"></p><p>FIN=1的报文段不能携带数据，但要消耗一个序号。v等于TCP客户进程之前收到的最后一个字节序号+1。u等于TCP客户进程之前已传送过数据的最后一个字节序号+1。<br><img src="/网络/运输层基本概念/TCP四次挥手过程.png" alt="运输层"><br><img src="/网络/运输层基本概念/TCP保活机制.png" alt="运输层"></p>]]></content>
    
    
    <summary type="html">运输层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
  <entry>
    <title>应用层基本概念</title>
    <link href="http://bugnull.com/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://bugnull.com/%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2022-08-30T12:11:56.286Z</published>
    <updated>2022-08-30T12:30:37.121Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/网络/应用层基本概念/应用层概念.png" alt="应用层"><br><img src="/网络/应用层基本概念/CS方式.png" alt="应用层"><br><img src="/网络/应用层基本概念/P2P方式.png" alt="应用层"><br><img src="/网络/应用层基本概念/DHCP动态主机配置协议.png" alt="应用层"><br>请求中会带有《事务ID》，用带确保是自己发出而得到的回应<br><img src="/网络/应用层基本概念/DHCP过程.png" alt="应用层"><br>路由器不会转发广播，需要在上面配置DHCP服务器IP，才能进行单播传送<br><img src="/网络/应用层基本概念/DHCP中继代理.png" alt="应用层"><br><img src="/网络/应用层基本概念/DHCP小结.png" alt="应用层"></p><p>DNS服务器，用于查找域名-&gt;IP  使用UDP 端口53<br><img src="/网络/应用层基本概念/域名结构.png" alt="应用层"><br><img src="/网络/应用层基本概念/域名服务器类别.png" alt="应用层"><br><img src="/网络/应用层基本概念/域名查询方式.png" alt="应用层"><br><img src="/网络/应用层基本概念/域名缓存.png" alt="应用层"></p><p><img src="/网络/应用层基本概念/FTP概念.png" alt="应用层"><br>控制连接会保持打开，数据连接传输完成就关闭<br><img src="/网络/应用层基本概念/FTP工作原理.png" alt="应用层"></p><p>基于TCP<br><img src="/网络/应用层基本概念/电子邮件概念.png" alt="应用层"><br><img src="/网络/应用层基本概念/SMTP工作原理.png" alt="应用层"><br>STMP只能传输ASCII，因而引进了MIME，将图片、文件转为ASCII或者将ASCII进行逆转换。MIME同样应用于HTTP<br><img src="/网络/应用层基本概念/SMTP补充.png" alt="应用层"><br><img src="/网络/应用层基本概念/POP3邮局协议.png" alt="应用层"><br><img src="/网络/应用层基本概念/基于万维网的电子邮件.png" alt="应用层"></p><p><img src="/网络/应用层基本概念/WWW万维网概念.png" alt="应用层"><br><img src="/网络/应用层基本概念/URL的组成.png" alt="应用层"><br><img src="/网络/应用层基本概念/HTTP请求报文.png" alt="应用层"><br><img src="/网络/应用层基本概念/HTTP响应报文.png" alt="应用层"><br><img src="/网络/应用层基本概念/Cookie概念.png" alt="应用层"><br><img src="/网络/应用层基本概念/Cookie工作流程.png" alt="应用层"><br><img src="/网络/应用层基本概念/WWW缓存与代理服务器.png" alt="应用层"><br><img src="/网络/应用层基本概念/HTTP请求例题.png" alt="应用层"><br><img src="/网络/应用层基本概念/WWW小结.png" alt="应用层"></p>]]></content>
    
    
    <summary type="html">应用层基本概念小记</summary>
    
    
    
    <category term="网络" scheme="http://bugnull.com/categories/网络/"/>
    
    
    <category term="网络知识" scheme="http://bugnull.com/tags/网络知识/"/>
    
  </entry>
  
</feed>
